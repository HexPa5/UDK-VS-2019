// Decompiled with JetBrains decompiler
// Type: <Module>
// Assembly: UDK, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 03787CDB-4638-4E03-874B-43F342731149
// Assembly location: C:\UDK\BatmanMods\Binaries\Win64\UDK.exe

using \u003CCppImplementationDetails\u003E;
using \u003CCrtImplementationDetails\u003E;
using AgentInterface;
using ColorPickerConstants;
using ContentBrowser;
using ExportLocalizationWindow;
using InteropTools;
using MatineeWindows;
using Microsoft.Win32;
using msclr;
using NSwarm;
using ObjectTools;
using OC3Ent.Face;
using SpeedTree;
using std;
using std.tr1;
using SubstanceAir;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Packaging;
using System.Management;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Forms;
using System.Windows.Interop;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Xml;
using System.Xml.Serialization;
using UDKSurveyPostProcessor;
using UnrealEd;

internal class \u003CModule\u003E
{
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003F\u003F_C\u0040_11LOCGONAA\u0040\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15KNBIKKIN\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19CKCBDCMG\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13GAMECHAC\u0040\u003F\u0024AAF\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BC\u0040MOGJFHKK\u0040tr1\u003F3\u003F3bad_weak_ptr\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040PNHGCNJL\u0040\u003F\u0024AAE\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D22;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D23;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17BJDGDONN\u0040\u003F\u0024AAT\u003F\u0024AAa\u003F\u0024AAb\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17PCJOKADA\u0040\u003F\u0024AAF\u003F\u0024AA1\u003F\u0024AA1\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040FCNBKECH\u0040\u003F\u0024AAE\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040PODDHOFJ\u0040\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAb\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAA\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BG\u0040KOCKIEFP\u0040\u003F\u0024AA\u0024\u003F\u0024AAp\u003F\u0024AAi\u003F\u0024AAx\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAs\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040BHIJFMNA\u0040\u003F\u0024AA\u0024\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040CPKHCPMN\u0040\u003F\u0024AA\u0024\u003F\u0024AAn\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CC\u0040JJIDPJAH\u0040\u003F\u0024AAT\u003F\u0024AAR\u003F\u0024AAA\u003F\u0024AAN\u003F\u0024AAS\u003F\u0024AAA\u003F\u0024AAC\u003F\u0024AAT\u003F\u0024AAI\u003F\u0024AAO\u003F\u0024AAN\u003F\u0024AA\u003F5\u003F\u0024AAU\u003F\u0024AAN\u003F\u0024AAD\u003F\u0024AAO\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GE\u0040HIIPMDKD\u0040\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAx\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAf\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAc\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040FCNBIPHN\u0040\u003F\u0024AA\u0024\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040JBFAEMPA\u0040\u003F\u0024AA\u0024\u003F\u0024AAo\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AAs\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DG\u0040PFIDJNII\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAE\u003F\u0024AAy\u003F\u0024AAe\u003F\u0024AAD\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAp\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAI\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F4\u003F\u0024AAp\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EM\u0040MODEKJJE\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAb\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAA\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AAI\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAp\u003F\u0024AAu\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FG\u0040MNDLGINM\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAb\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAA\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAI\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAg\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FE\u0040NNFLKIIE\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAb\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAA\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAI\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EA\u0040GFNBHGBO\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAS\u003F\u0024AAu\u003F\u0024AAb\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAA\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AA_\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAn\u003F\u0024AAc\u003F\u0024AAC\u003F\u0024AAB\u003F\u0024AA\u003F4\u003F\u0024AAp\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040JAOOKING\u0040\u003F\u0024AAM\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAp\u003F\u0024AAu\u003F\u0024AAt\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D24;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DI\u0040NCDJAPHE\u0040d\u003F3\u003F2depot\u003F2unrealengine3\u003F2developme\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CM\u0040IOEOIMHE\u0040i\u003F\u0024DO\u003F\u0024DN0\u003F5\u003F\u0024CG\u003F\u0024CG\u003F5\u003F\u0024CIi\u003F\u0024DMArrayNum\u003F\u0024HM\u003F\u0024HM\u003F\u0024CIi\u003F\u0024DN\u003F\u0024DN0\u003F5\u003F\u0024CG\u003F\u0024CG\u003F5Ar\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BI\u0040CFPLBAOH\u0040invalid\u003F5string\u003F5position\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0DL\u0040LKDOMIAP\u0040d\u003F3\u003F2depot\u003F2unrealengine3\u003F2developme\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BK\u0040ECNPCLCB\u0040Index\u003F\u0024DO\u003F\u0024DN0\u003F5\u003F\u0024CG\u003F\u0024CG\u003F5Index\u003F\u0024DMNumBits\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040JFNIOLAK\u0040string\u003F5too\u003F5long\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D25;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D27;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D28;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D29;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D30;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D31;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D32;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D33;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D34;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D35;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D36;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D37;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D38;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D39;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D40;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D41;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D42;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D43;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D44;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D45;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D46;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D47;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D48;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D49;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D50;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D51;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D52;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D53;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D54;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D55;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D56;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D57;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D58;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D59;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D60;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D61;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D62;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D63;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D64;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D65;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D66;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D67;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D68;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D69;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D70;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D71;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D72;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D73;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D74;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D75;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D76;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D77;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D78;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D79;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D80;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D81;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D82;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D83;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D84;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D85;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D86;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D87;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D88;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D89;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D90;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FxUseAllocator\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static VectorRegister \u003FA0x230b4690\u002EVECTOR_ZERO;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EVECTOR_ZERO\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir10X;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir10X\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FCallbackEventDevice\u0040\u00408;
  internal static float OC3Ent\u002EFace\u002E\u003FA0x230b4690\u002EFxInvalidValue;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_32 \u003F\u003F_R2FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static wxColour \u003FA0x230b4690\u002EkErrorColor;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FOutputDevice\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_14 \u003F\u003F_R0\u003FAVwxEvent\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FStateFrame\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FViewportConfig_Viewport\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FxNamedObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir6;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir6\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_18 \u003F\u003F_R0\u003FAVWxDockEvent\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_weak_ptr\u0040tr1\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FViewportConfig_Data\u0040\u00406B\u0040;
  internal static _s__ThrowInfo _TI2\u003FAVbad_weak_ptr\u0040tr1\u0040std\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7WxDockEvent\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2bad_weak_ptr\u0040tr1\u0040std\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FGraphInstanceEditorWindow\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxObject\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7FFrame\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040exception\u0040std\u0040\u00408;
  internal static unsafe char* OutputDeviceColor\u002E\u003FA0x230b4690\u002ECOLOR_GRAY;
  internal static unsafe char* OutputDeviceColor\u002E\u003FA0x230b4690\u002ECOLOR_DARK_WHITE;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Out;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Out\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVFViewportConfig_Data\u0040\u0040\u00408;
  internal static FRotator EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewRotation;
  internal static __FnPtr<void ()> EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewRotation\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_33 \u003F\u003F_R0\u003FAVFxUseAllocator\u0040Face\u0040OC3Ent\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir10Y;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir10Y\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FStateFrame\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FFrame\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3IFloatingViewportCallback\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FVCD_Viewport\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Right;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Right\u0024initializer\u0024;
  internal static wxString \u003FA0x230b4690\u002EAPP_NAME;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FCallbackEventDevice\u0040\u00408;
  internal static wxString \u003FA0x230b4690\u002EAPP_TITLE;
  internal static wxString \u003FA0x230b4690\u002EPRODUCT_NAME;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVFCallbackEventDevice\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_15 \u003F\u003F_R0\u003FAVwxObject\u0040\u0040\u00408;
  internal static FVector EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewLocation;
  internal static __FnPtr<void ()> EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewLocation\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FFrame\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVexception\u0040std\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FViewportConfig_Viewport\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Up;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Up\u0024initializer\u0024;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Up;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Up\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_alloc\u0040std\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVFOutputDevice\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040bad_weak_ptr\u0040tr1\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4bad_weak_ptr\u0040tr1\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_32 \u003F\u003F_R0\u003FAVIFloatingViewportCallback\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FCallbackEventDevice\u0040\u00406B\u0040;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat111_Minus1;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat111_Minus1\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FGraphInstanceEditorWindow\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FxObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static wxString \u003FA0x230b4690\u002EAPP_VERSION;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EAPP_VERSION\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FViewportConfig_Viewport\u0040\u00408;
  internal static VectorRegister \u003FA0x230b4690\u002EVECTOR_ONE;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2wxObject\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Out;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Out\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FOutputDevice\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FxUseAllocator\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R17\u003F0A\u0040EA\u0040FxUseAllocator\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FGraphInstanceEditorWindow\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FFrame\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7FStateFrame\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FViewportConfig_Viewport\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FVCD_Viewport\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_18 \u003F\u003F_R0\u003FAUFStateFrame\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FCallbackEventDevice\u0040\u00406B\u0040;
  internal static TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E \u003FA0x230b4690\u002EPathStepCache;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3WxDockEvent\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EAPP_TITLE\u0024initializer\u0024;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQINV_SIGN_MASK;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQINV_SIGN_MASK\u0024initializer\u0024;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Up;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Right;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Out;
  internal static Vec3 SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Right;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FStateFrame\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK1;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK1\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FxNamedObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FViewportConfig_Data\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FViewportConfig_Data\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBVFColor\u0040\u0040 \u003FA0x230b4690\u002EDebugUtilColor;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir10Z;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir10Z\u0024initializer\u0024;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Right\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FGraphInstanceEditorWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FFrame\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FOutputDevice\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EkErrorColor\u0024initializer\u0024;
  internal static wxColour \u003FA0x230b4690\u002EkWarningColor;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EkWarningColor\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3bad_alloc\u0040std\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4WxDockEvent\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040IFloatingViewportCallback\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FViewportConfig_Data\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat0001;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat0001\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxEvent\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EDebugUtilColor\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxObject\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7FViewportConfig_Data\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxEvent\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVbad_alloc\u0040std\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EAPP_NAME\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FxUseAllocator\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FGraphInstanceEditorWindow\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002ERotationSignificantThreshold;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002ERotationSignificantThreshold\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FVCD_Viewport\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x230b4690\u002EKDopDir18;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir18\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FCallbackEventDevice\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EPRODUCT_NAME\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2exception\u0040std\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK2;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK2\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_33 \u003F\u003F_R0\u003FAVFGraphInstanceEditorWindow\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVFxObject\u0040Face\u0040OC3Ent\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2IFloatingViewportCallback\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3exception\u0040std\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_24 \u003F\u003F_R2FxNamedObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_16 _CTA2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static unsafe FGraphInstance* \u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_31 \u003F\u003F_R0\u003FAVFViewportConfig_Viewport\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_24 \u003F\u003F_R2FStateFrame\u0040\u00408;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Right\u0024initializer\u0024;
  internal static wxColour \u003FA0x230b4690\u002EkNormalColor;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EkNormalColor\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EPathStepCache\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_24 \u003F\u003F_R2WxDockEvent\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7bad_weak_ptr\u0040tr1\u0040std\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVbad_weak_ptr\u0040tr1\u0040std\u0040\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002ESmallLengthThreshold;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHalf;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHundredth;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EAnimWeightThreshold;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK0;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FxObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__ThrowInfo _TI2\u003FAVbad_alloc\u0040std\u0040\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FViewportConfig_Viewport\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHalf\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FxObject\u0040Face\u0040OC3Ent\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4bad_alloc\u0040std\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EAnimWeightThreshold\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_13 \u003F\u003F_R0\u003FAUFFrame\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2wxEvent\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FVCD_Viewport\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK0\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FOutputDevice\u0040\u00408;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Out\u0024initializer\u0024;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002ESmallLengthThreshold\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_34 \u003F\u003F_R0\u003FAVFxGestureConfig\u0040Face\u0040OC3Ent\u0040\u0040\u00408;
  internal static \u0024_s__CatchableTypeArray\u0024_extraBytes_16 _CTA2\u003FAVbad_weak_ptr\u0040tr1\u0040std\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04Q6AXXZ \u003F\u003F_7FOutputDevice\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_32 \u003F\u003F_R0\u003FAVFxNamedObject\u0040Face\u0040OC3Ent\u0040\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EKDopDir26\u0024initializer\u0024;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHundredth\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FVCD_Viewport\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x230b4690\u002EVECTOR_ONE\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040WxDockEvent\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_20 \u003F\u003F_R0\u003FAVFVCD_Viewport\u0040\u0040\u00408;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Up\u0024initializer\u0024;
  public static __FnPtr<FGraphInstanceEditorWindow* (FGraphInstance*, HWND__*)> __m2mep\u0040\u003FCreateGraphInstanceEditorWindow\u0040FGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FGraphInstanceEditorWindow*, uint)> __m2mep\u0040\u003F\u003F_EFGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FGraphInstanceEditorWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (FGraphInstanceEditorWindow*, ECallbackEventType, UObject*)> __m2mep\u0040\u003FSend\u0040FGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040PEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<void (FGraphInstanceEditorWindow*, ECallbackEventType, FString*, UObject*)> __m2mep\u0040\u003FSend\u0040FGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040AEBVFString\u0040\u0040PEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<FGraphInstance* ()> __m2mep\u0040\u003FGetEditedInstance\u0040FGraphInstanceEditorWindow\u0040\u0040\u0024\u0024FSAPEAUFGraphInstance\u0040SubstanceAir\u0040\u0040XZ;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D11;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D12;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D13;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D14;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D15;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D16;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D17;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D18;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D19;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D20;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D21;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D22;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D23;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D24;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003F\u003F_C\u0040_15HBBGCAG\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAf\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13FPGAJAPJ\u0040\u003F\u0024AA\u003F2\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CC\u0040IFBFNDKF\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA0\u003F\u0024AA8\u003F\u0024AAX\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA0\u003F\u0024AA8\u003F\u0024AAX\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA0\u003F\u0024AA8\u003F\u0024AAX\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA0\u003F\u0024AA8\u003F\u0024AAX\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040OIKEGNDA\u0040\u003F\u0024AAE\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DG\u0040DGABGDJK\u0040\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AA_\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA_\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AA_\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003F\u003F_C\u0040_19KLMLHLJG\u0040\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040LBCGAGN\u0040\u003F\u0024AA\u003F\u0024DM\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAz\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AA\u003F\u0024DO\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13JOFGPIOO\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D25;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D27;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D28;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D29;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D30;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040BILDELMA\u0040\u003F\u0024AAU\u003F\u0024AAn\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAE\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13HOIJIPNN\u0040\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D31;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D32;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040EKOJHNNP\u0040\u003F\u0024AAP\u003F\u0024AAC\u003F\u0024AA\u003F2\u003F\u0024AAE\u003F\u0024AAd\u003F\u0024AAS\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AA\u003F4\u003F\u0024AAb\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CBD \u003F\u003F_C\u0040_08HEMPMHEM\u0040UDKTitle\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BF\u0040INEMABHN\u0040UnrealEdVersionTitle\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BA\u0040MKHFAHFE\u0040UnrealEdVersion\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EK\u0040LENMEHCL\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AA\u003F4\u003F\u0024AAf\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAe\u003F\u0024AAb\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAk\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAU\u003F\u0024AAn\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAE\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D33;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D34;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D35;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D36;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D37;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D38;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003F\u003F_C\u0040_09GGDLDJIK\u0040Importing\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040OIOADBNO\u0040\u003F\u0024AAM\u003F\u0024AAy\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAk\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040DDEDBBPN\u0040\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAh\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BI\u0040MLKPIDDG\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAS\u003F\u0024AAy\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CM\u0040PKKKPCEN\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAU\u003F\u0024AAI\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EN\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1JK\u0040BLOEMIIA\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAU\u003F\u0024AAI\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAu\u003F\u0024AAl\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040OIGHNOMD\u0040\u003F\u0024AAF\u003F\u0024AAa\u003F\u0024AAv\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAT\u003F\u0024AAy\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AA0\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CK\u0040PIPBOMPF\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040LCMCLLAC\u0040\u003F\u0024AAb\u003F\u0024AAI\u003F\u0024AAs\u003F\u0024AAU\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAT\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAA\u003F\u0024AAd\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CO\u0040GNOMGEAA\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAu\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAy\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DA\u0040GCFDMHPE\u0040\u003F\u0024AAb\u003F\u0024AAI\u003F\u0024AAs\u003F\u0024AAU\u003F\u0024AAs\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAs\u003F\u0024AAA\u003F\u0024AAd\u003F\u0024AAm\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CG\u0040DCPDBNEJ\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F2\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F2\u003F\u0024AAN\u003F\u0024AAe\u003F\u0024AAw\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAk\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040ICKGFOFN\u0040\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F2\u003F\u0024AA\u003F4\u003F\u0024AA\u003F4\u003F\u0024AA\u003F2\u003F\u0024AAE\u003F\u0024AAx\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AA\u003F2\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BE\u0040LBNJGNAP\u0040SCC_Checkin_Aborted\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D39;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D40;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D41;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D42;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D43;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D44;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D45;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D46;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D47;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D48;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D49;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D50;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D51;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D52;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D53;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D54;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D55;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D56;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D57;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D58;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D59;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D60;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D61;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D62;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D63;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D64;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D65;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D66;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D67;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D68;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D69;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D70;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D71;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D72;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D73;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D74;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D75;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D76;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D77;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D78;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D79;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D80;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D81;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D82;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D83;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D84;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D85;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D86;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D87;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D88;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D89;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D90;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D91;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D92;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D93;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D94;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D95;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D96;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D97;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D98;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D99;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D100;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D101;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D102;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D103;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D104;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D105;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D106;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D107;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D108;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D109;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D110;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D111;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D112;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D113;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D114;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D115;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D116;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D117;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D118;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D119;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D120;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D121;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D122;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D123;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D124;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D125;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D126;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D127;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D128;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D129;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D130;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D131;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D132;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D133;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D134;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D135;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DP\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D136;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D137;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D138;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D139;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D140;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D141;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D142;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D143;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D144;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D145;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EC\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D146;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D147;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D148;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D149;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D150;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D151;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D152;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D153;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D154;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D155;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D156;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D157;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CA\u0040DGIBDPIB\u0040\u003F\u0024AAT\u003F\u0024AAg\u003F\u0024AAa\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F\u0024HM\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAt\u003F\u0024AAg\u003F\u0024AAa\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CBD \u003F\u003F_C\u0040_04DNCDCIAE\u0040Open\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D158;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D159;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040HAOEHKBE\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024FL\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024FN\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040HAMADPKO\u0040\u003F\u0024AAK\u003F\u0024AAB\u003F\u0024AAy\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040JPPNJKEO\u0040\u003F\u0024AAM\u003F\u0024AAB\u003F\u0024AAy\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003F\u003F_C\u0040_1BC\u0040FPJAHJMF\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA5\u003F\u0024AA\u003F4\u003F\u0024AA2\u003F\u0024AAf\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DC\u0040MPBJKACG\u0040\u003F\u0024AAA\u003F\u0024AAv\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAb\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAU\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAo\u003F\u0024AA\u003F5\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AA\u003F3\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CO\u0040DAOLCMAK\u0040\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAP\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAk\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAW\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AA\u003F4\u003F\u0024AAx\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAl\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003F\u003F_C\u0040_17MJEANDKP\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F6\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BL\u0040JNCDIAJD\u0040Warning_ExternalPackageRef\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D160;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D161;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CM\u0040OGICJLGM\u0040PerforceLogin_Error_UnableToConn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D162;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0GG\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D163;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0GI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D164;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D165;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D166;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D167;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D168;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D169;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D170;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D171;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D172;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D173;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D174;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D175;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D176;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D177;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D178;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D179;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D180;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D181;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D182;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D183;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D184;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D185;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D186;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D187;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D188;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D189;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D190;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D191;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D192;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DO\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D193;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D194;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D195;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D196;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D197;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D198;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D199;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D200;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D201;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D202;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D203;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D204;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D205;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D206;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D207;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D208;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D209;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D210;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D211;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D212;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D213;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D214;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D215;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D216;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D217;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D218;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D219;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D220;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D221;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D222;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D223;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D224;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D225;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D226;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D227;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D228;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D229;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D230;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D231;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D232;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D233;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FG\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D234;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0JJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D235;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D236;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D237;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D238;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D239;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D240;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D241;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D242;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D243;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D244;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D245;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D246;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D247;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D248;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D249;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D250;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D251;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D252;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D253;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D254;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D255;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D256;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0FI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D257;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D258;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D259;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D260;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D261;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D262;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D263;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D264;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D265;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CP\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CP\u0040EKIELBLP\u0040SourceControlSubmit_DescriptionV\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D266;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D267;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D268;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D269;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D270;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D271;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D272;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D273;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D274;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D275;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D276;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D277;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D278;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D279;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D280;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D281;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D282;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D283;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EO\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D284;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0GO\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D285;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D286;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D287;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D288;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D289;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D290;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D291;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BF\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D292;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D293;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D294;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D295;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D296;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D297;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D298;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01\u0024\u0024CB_W \u003F\u003F_C\u0040_13GMDMCADD\u0040\u003F\u0024AA\u003F\u0024CD\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0P\u0040BMEEIAJH\u0040http\u003F3\u003F1\u003F1udk\u003F4com\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0O\u0040JMIFCMPP\u0040documentation\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D299;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BP\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D300;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D301;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D302;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D303;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D304;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D305;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D306;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D307;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D308;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D309;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D310;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D311;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D312;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D313;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D314;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DD\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D315;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D316;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D317;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D318;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D319;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EE\u0040BHFOPCJF\u0040\u003F\u0024AAA\u003F\u0024AAd\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAi\u003F\u0024AAe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BK\u0040BLCEKPGK\u0040\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAL\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FA\u0040IKJIEMA\u0040\u003F\u0024AAI\u003F\u0024AAn\u003F\u0024AAv\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAd\u003F\u0024AA\u003F5\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AA\u003F5\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u003F\u0024AA\u003F5\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D320;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D321;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D322;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D323;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D324;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D325;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D326;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D327;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D328;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D329;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CF\u0040OCDHJCPK\u0040BuildSubmitWindow_Error_HiddenLe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D330;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D331;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D332;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D333;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D334;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D335;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D336;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D337;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D338;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D339;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D340;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D341;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D342;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D343;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D344;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EO\u0040KHJDFLBN\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AA_\u003F\u0024AAH\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAm\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FG\u0040CGBIHMBE\u0040\u003F\u0024AA\u003F5\u003F\u0024AA\u003F9\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CD\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AAs\u003F\u0024AA\u003F3\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F1\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F0\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CD\u003F\u0024AAC\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AAQ\u003F\u0024AAu\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AA\u003F3\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAd\u003F\u0024AA\u003F0\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CD\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CF\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EK\u0040EGBMNDOL\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAv\u003F\u0024AAe\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EO\u0040HDMBGKGD\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EO\u0040EMOANNPP\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAa\u003F\u0024AAb\u003F\u0024AAl\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FA\u0040ODMFIDBP\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EM\u0040CKGMGBMM\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAv\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FA\u0040NMOEDEID\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAB\u003F\u0024AAr\u003F\u0024AAu\u003F\u0024AAs\u003F\u0024AAh\u003F\u0024AA_\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA_\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAa\u003F\u0024AAb\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DO\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HM\u0040JNPOJEGC\u0040\u003F\u0024AAH\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F0\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AA1\u003F\u0024AA6\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F\u0024HM\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CBD \u003F\u003F_C\u0040_06IBNLALPJ\u0040Import\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HA\u0040IALJPGIP\u0040\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAy\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F5\u003F\u0024AA\u003F\u0024CI\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F0\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AA8\u003F\u0024AA\u003F\u0024CJ\u003F\u0024AA\u003F\u0024HM\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F\u0024DL\u003F\u0024AA\u003F\u0024CK\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BK\u0040GJIONLDJ\u0040LandscapeMode_RemoveLayer\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BO\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BO\u0040FJGLCHEB\u0040LandscapeReImport_BadFileSize\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BO\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DM\u0040GOADLMLL\u0040\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAI\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAt\u003F\u0024AA_\u003F\u0024AAB\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAF\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CA\u0040JKJDHIBP\u0040LandscapeMode_AddLayerEnterName\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CA\u0040JKBAFLG\u0040LandscapeMode_AddLayerDuplicate\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CB\u0040MILJFHCM\u0040LandscapeImport_BadHeightmapSize\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BN\u0040CGAMHGJ\u0040LandscapeImport_BadLayerSize\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BN\u0040EGMNAJEA\u0040LandscapeImport_BadLayerName\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CC\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0CC\u0040JIJJMCND\u0040LandscapeExport_HeightmapFilenam\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040MKNOLGLH\u0040\u003F\u0024AAH\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EE\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1II\u0040MKALCGKI\u0040\u003F\u0024AAH\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAm\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F5\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F\u0024HM\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F\u0024HM\u003F\u0024AAH\u003F\u0024AAe\u003F\u0024AAi\u003F\u0024AAg\u003F\u0024AAh\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BO\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BO\u0040MAALCGFM\u0040LandscapeExport_LayerFilename\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY06\u0024\u0024CB_W \u003F\u003F_C\u0040_1O\u0040LOPGCCNN\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DK\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HE\u0040GIFLOPIK\u0040\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAy\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F5\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F5\u003F\u0024AAf\u003F\u0024AAi\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F\u0024HM\u003F\u0024AA\u003F\u0024CK\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AAa\u003F\u0024AAw\u003F\u0024AA\u003F\u0024HM\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAy\u003F\u0024AAe\u003F\u0024AAr\u003F\u0024AA\u003F5\u003F\u0024AA\u003F4\u003F\u0024AAr\u003F\u0024AA8\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BO\u0040HIJHGGBN\u0040\u003F\u0024AAb\u003F\u0024AAS\u003F\u0024AAh\u003F\u0024AAo\u003F\u0024AAw\u003F\u0024AAA\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAt\u003F\u0024AAu\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1BM\u0040HKLKNCGP\u0040\u003F\u0024AAW\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAS\u003F\u0024AAc\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GO\u0040PNKHGKJL\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAn\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAp\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAg\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AA\u003F1\u003F\u0024AAD\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DD\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GG\u0040HEGHJACO\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAu\u003F\u0024AAd\u003F\u0024AAn\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAp\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAg\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAT\u003F\u0024AAh\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAe\u003F\u0024AA\u003F1\u003F\u0024AAV\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FG\u0040IHJOFBJM\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAu\u003F\u0024AAm\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAe\u003F\u0024AAp\u003F\u0024AAi\u003F\u0024AAc\u003F\u0024AAg\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAf\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAu\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1HA\u0040PFGEAIMJ\u0040\u003F\u0024AAh\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAp\u003F\u0024AA\u003F3\u003F\u0024AA\u003F1\u003F\u0024AA\u003F1\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AAw\u003F\u0024AA\u003F4\u003F\u0024AAu\u003F\u0024AAn\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AA\u003F4\u003F\u0024AAc\u003F\u0024AAo\u003F\u0024AAm\u003F\u0024AA\u003F1\u003F\u0024AAn\u003F\u0024AAe\u003F\u0024AAw\u003F\u0024AAs\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0P\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D345;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D346;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D347;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BE\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D348;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0O\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D349;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D350;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CBD \u003F\u003F_C\u0040_0BB\u0040GPNJFID\u0040ChooseADirectory\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D351;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D352;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D353;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BO\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D354;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EI\u0040BPHFJCOM\u0040\u003F\u0024AAF\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AAi\u003F\u0024AAa\u003F\u0024AAg\u003F\u0024AAe\u003F\u0024AAM\u003F\u0024AAo\u003F\u0024AAd\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAN\u003F\u0024AAo\u003F\u0024AAt\u003F\u0024AAS\u003F\u0024AAh\u003F\u0024AAa\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAd\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AAs\u003F\u0024AAO\u003F\u0024AAb\u003F\u0024AAj\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040HFECKDGI\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AA1\u003F\u0024AA\u003F4\u003F\u0024AA0\u003F\u0024AAf\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CI\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FA\u0040BDEGNJEH\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AA_\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FE\u0040CCLOFJKN\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AA_\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAa\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CK\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FE\u0040OGJIHIKD\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAy\u003F\u0024AA_\u003F\u0024AAa\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FI\u0040HBHFFGJH\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAR\u003F\u0024AAe\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAy\u003F\u0024AA_\u003F\u0024AAi\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CM\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FI\u0040MOFOKHGI\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FM\u0040POPJJFKP\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAS\u003F\u0024AAe\u003F\u0024AAl\u003F\u0024AAe\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u003F\u0024AAo\u003F\u0024AAn\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EO\u0040PPDKNCGA\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA_\u003F\u0024AAa\u003F\u0024AAc\u003F\u0024AAt\u003F\u0024AAi\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CJ\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FC\u0040DJDILJGC\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAs\u003F\u0024AAk\u003F\u0024AA_\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAa\u003F\u0024AAc\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CO\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1FM\u0040FKPHHMPL\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAc\u003F\u0024AAk\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DA\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GA\u0040FIHHFBMJ\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAc\u003F\u0024AAk\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DF\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GK\u0040LMCFAMKB\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAc\u003F\u0024AAk\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DH\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1GO\u0040FCFBDGIP\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAL\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAd\u003F\u0024AAs\u003F\u0024AAc\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAe\u003F\u0024AA_\u003F\u0024AAT\u003F\u0024AAo\u003F\u0024AAo\u003F\u0024AAl\u003F\u0024AA_\u003F\u0024AAP\u003F\u0024AAa\u003F\u0024AAi\u003F\u0024AAn\u003F\u0024AAt\u003F\u0024AAB\u003F\u0024AAu\u003F\u0024AAc\u003F\u0024AAk\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CB_W \u003F\u003F_C\u0040_1BE\u0040CINDKFIE\u0040\u003F\u0024AAB\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAk\u003F\u0024AA\u003F5\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DI\u0040OKEPKFLI\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAN\u003F\u0024AAe\u003F\u0024AAw\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA_\u003F\u0024AAB\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAn\u003F\u0024AAk\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA\u003F4\u003F\u0024AAp\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1DG\u0040NPDDGNJD\u0040\u003F\u0024AA\u003F\u0024CF\u003F\u0024AAs\u003F\u0024AAw\u003F\u0024AAx\u003F\u0024AAr\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F2\u003F\u0024AAN\u003F\u0024AAe\u003F\u0024AAw\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AA_\u003F\u0024AAD\u003F\u0024AAe\u003F\u0024AAf\u003F\u0024AAa\u003F\u0024AAu\u003F\u0024AAl\u003F\u0024AAt\u003F\u0024AA\u003F4\u003F\u0024AAp\u003F\u0024AAn\u003F\u0024AAg\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1CG\u0040LMOLEGMD\u0040\u003F\u0024AAE\u003F\u0024AAd\u003F\u0024AAi\u003F\u0024AAt\u003F\u0024AAo\u003F\u0024AAr\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAT\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAs\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CB\u0040\u0024\u0024CB_W \u003F\u003F_C\u0040_1EC\u0040DCDEBCLI\u0040\u003F\u0024AAT\u003F\u0024AAe\u003F\u0024AAm\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AAM\u003F\u0024AAa\u003F\u0024AAp\u003F\u0024AAM\u003F\u0024AAe\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AAd\u003F\u0024AAa\u003F\u0024AAt\u003F\u0024AAa\u003F\u0024AA\u003F4\u003F\u0024AAD\u003F\u0024AAi\u003F\u0024AAs\u003F\u0024AAp\u003F\u0024AAl\u003F\u0024AAa\u003F\u0024AAy\u003F\u0024AAN\u003F\u0024AAa\u003F\u0024AAm\u003F\u0024AAe\u003F\u0024AAs\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D355;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BD\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D356;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D357;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D358;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CB_W \u003F\u003F_C\u0040_1M\u0040HFMKHCCP\u0040\u003F\u0024AAG\u003F\u0024AAB\u003F\u0024AAy\u003F\u0024AAt\u003F\u0024AAe\u003F\u0024AA\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBD \u003F\u003F_C\u0040_03LKILIBFM\u0040\u003F4\u003F4\u003F2\u003F\u0024AA\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D359;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BH\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D360;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D361;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D362;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D363;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D364;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D365;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D366;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D367;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D368;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D369;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D370;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D371;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D372;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D373;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D374;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D375;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D376;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D377;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D378;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D379;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D380;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D381;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D382;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D383;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D384;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D385;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D386;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D387;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D388;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D389;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D390;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D391;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D392;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D393;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D394;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D395;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D396;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D397;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D398;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D399;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D400;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D401;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D402;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D403;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DI\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D404;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D405;
  internal static \u0024ArrayType\u0024\u0024\u0024BY04\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D406;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D407;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D409;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D410;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D411;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D412;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D413;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D414;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D415;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D416;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D417;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D418;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D419;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D420;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D421;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D422;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D423;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D424;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D425;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D426;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D427;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D428;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D429;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D430;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BG\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D431;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D432;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D433;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D434;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D435;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D436;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0N\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D437;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D438;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D439;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D440;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D441;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0DL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D442;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CL\u0040\u0024\u0024CBD \u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D443;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_72 \u003F\u003F_R2wxDialog\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FFoliageEditWindow\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FContentBrowser\u0040\u00406BFSourceControlEventListener\u0040\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples;
  internal static gcroot\u003CMColorPickerPanel\u0020\u005E\u003E GColorPickerPanel;
  internal static TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E \u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002E\u003FStartPageInstances\u0024initializer\u0024\u0040FStartPage\u0040\u00401P6MXXZEA;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAVFFoliageEditWindow\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_108 \u003F\u003F_R0\u003FAVUpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040UObject\u0040\u00408;
  internal static VectorRegister \u003FA0x3a4a4fc4\u002EVECTOR_ZERO;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EVECTOR_ZERO\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir10X;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir10X\u0024initializer\u0024;
  internal static float OC3Ent\u002EFace\u002E\u003FA0x3a4a4fc4\u002EFxInvalidValue;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FContentBrowser\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
  internal static wxColour \u003FA0x3a4a4fc4\u002EkErrorColor;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY08PEB_W \u003FA0x3a4a4fc4\u002EInterpEdFPSSnapSizeLocNames;
  internal static TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E \u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxDialog\u0040\u00408;
  internal static TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E \u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FDeferredInitializationWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir6;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir6\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_15 \u003F\u003F_R0\u003FAVwxDialog\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_14 \u003F\u003F_R0\u003FAVwxFrame\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BK\u0040\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir26;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EEightRefiningSamples;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FLightmapResRatioWindow\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R17\u003F0A\u0040EA\u0040FCallbackEventDevice\u0040\u00408;
  internal static gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E MatineeWindows\u002EGDirectorPanelHelper;
  internal static __FnPtr<void ()> MatineeWindows\u002E\u003FA0x3a4a4fc4\u002EGDirectorPanelHelper\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_36 \u003F\u003F_R0\u003FAVFDeferredInitializationWindow\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FConsolidateWindow\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7FRenderCommand\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FDeferredInitializationWindow\u0040\u00406B\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVwxWindowBase\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FImportColorsScreen\u0040\u00408;
  internal static unsafe char* OutputDeviceColor\u002E\u003FA0x3a4a4fc4\u002ECOLOR_GRAY;
  internal static unsafe char* OutputDeviceColor\u002E\u003FA0x3a4a4fc4\u002ECOLOR_DARK_WHITE;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FLandscapeEditWindow\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FStartPage\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Out;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Out\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FLightingToolsWindow\u0040\u00408;
  internal static FRotator EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewRotation;
  internal static __FnPtr<void ()> EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewRotation\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FContentBrowser\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FContentBrowser\u0040\u00406BFSourceControlEventListener\u0040\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BA\u0040\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002ESixteenSampleOffsets;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002ESixteenSampleOffsets\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_30 \u003F\u003F_R0\u003FAVFLightmapResRatioWindow\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FConsolidateWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_48 \u003F\u003F_R2wxTopLevelWindowMSW\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FWelcomeScreen\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir10Y;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir10Y\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R17\u003F0A\u0040EA\u0040FTickableObject\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FTickableObject\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_88 \u003F\u003F_R2WxPropertyWindowFrame\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_24 \u003F\u003F_R2wxWindowBase\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FSourceControlEventListener\u0040\u00406B\u0040;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Right;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Right\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002E\u003FContentBrowserInstances\u0024initializer\u0024\u0040FContentBrowser\u0040\u00401P6MXXZEA;
  internal static wxString \u003FA0x3a4a4fc4\u002EAPP_NAME;
  internal static wxString \u003FA0x3a4a4fc4\u002EAPP_TITLE;
  internal static wxString \u003FA0x3a4a4fc4\u002EPRODUCT_NAME;
  internal static uint \u003FA0x3a4a4fc4\u002E\u003F\u0024S58\u0040\u003F1\u003F\u003FQueryTagsForAsset\u0040FGameAssetDatabase\u0040\u0040QEBAXVFName\u0040\u0040W4Type\u0040ETagQueryOptions\u0040\u0040AEAV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z\u00404IA;
  internal static gcroot\u003CMWPFFrame\u0020\u005E\u003E GColorPickerFrame;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FImportColorsScreen\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FImportColorsScreen\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxEvtHandler\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0MG\u0040Q6AXXZ \u003F\u003F_SwxDialog\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FFoliageEditWindow\u0040\u00408;
  internal static FVector EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewLocation;
  internal static __FnPtr<void ()> EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewLocation\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FLightingToolsWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FLightmapResRatioWindow\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EFourEdgeSamples;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_64 \u003F\u003F_R2wxFrameBase\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FGameAssetDatabase\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Up;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Up\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_72 \u003F\u003F_R2wxFrame\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxWindowBase\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Up;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Up\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4wxDialog\u0040\u00406B\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FWelcomeScreen\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY07\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EEightEdgeSamples;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EEightEdgeSamples\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FDeferredInitializationWindow\u0040\u00406B\u0040;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat111_Minus1;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat111_Minus1\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxDialogBase\u0040\u00408;
  internal static wxString \u003FA0x3a4a4fc4\u002EAPP_VERSION;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EAPP_VERSION\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_28 \u003F\u003F_R0\u003FAVWxPropertyWindowFrame\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EFourRefiningSamples;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EFourRefiningSamples\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FMeshPaintWindow\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxTopLevelWindow\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxFrameBase\u0040\u00408;
  internal static VectorRegister \u003FA0x3a4a4fc4\u002EVECTOR_ONE;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAVFRenderCommand\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FAboutScreen\u0040\u00408;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Out;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Out\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040CleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FContentBrowser\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxDialogBase\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0NI\u0040Q6AXXZ \u003F\u003F_7WxPropertyWindowFrame\u0040\u00406BwxFrame\u0040\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_24 \u003F\u003F_R0\u003FAVUObjectSerializer\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FFoliageEditWindow\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FWelcomeScreen\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0M\u0040\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002ETwelveRefiningSamples;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002ETwelveRefiningSamples\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4WxPropertyWindowFrame\u0040\u00406BFDeferredInitializationWindow\u0040\u0040\u0040;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxWindowBase\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVwxTopLevelWindowBase\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FAboutScreen\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FSerializableObject\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_14 \u003F\u003F_R0\u003FAVUObject\u0040\u0040\u00408;
  internal static TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E \u003FA0x3a4a4fc4\u002EPathStepCache;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxDialog\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FAboutScreen\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EAPP_TITLE\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxTopLevelWindowBase\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2CleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_34 \u003F\u003F_R0\u003FAVFSourceControlEventListener\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3WxPropertyWindowFrame\u0040\u00408;
  internal static unsafe FWelcomeScreen* \u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FSourceControlEventListener\u0040\u00406B\u0040;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQINV_SIGN_MASK;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQINV_SIGN_MASK\u0024initializer\u0024;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Up;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Right;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Out;
  internal static Vec3 SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Right;
  internal static unsafe FNewProjectScreen* \u003FInstance\u0040FNewProjectScreen\u0040\u00400PEAV1\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FStartPage\u0040\u00406B\u0040;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK1;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK1\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_26 \u003F\u003F_R0\u003FAVwxTopLevelWindowMSW\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FFoliageEditWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FSourceControlEventListener\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FConsolidateWindow\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7WxPropertyWindowFrame\u0040\u00406BFDeferredInitializationWindow\u0040\u0040\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FContentBrowser\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_40 \u003F\u003F_R2FContentBrowser\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EGColorPickerPanel\u0024initializer\u0024;
  internal static FPickColorStruct GPickColorStruct;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EGPickColorStruct\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FGameAssetDatabase\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CA\u0040\u0024\u0024CBVFColor\u0040\u0040 \u003FA0x3a4a4fc4\u002EDebugUtilColor;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FSerializableObject\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY09\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir10Z;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir10Z\u0024initializer\u0024;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Right\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxTopLevelWindowBase\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVwxEvtHandler\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FContentBrowser\u0040\u00406BFTickableObject\u0040\u0040\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FStartPage\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_26 \u003F\u003F_R0\u003FAVFSerializableObject\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FMeshPaintWindow\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FConsolidateWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FRenderCommand\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FConsolidateWindow\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_32 \u003F\u003F_R2wxWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EO\u0040Q6AXXZ \u003F\u003F_7UObjectSerializer\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03\u0024\u0024CBUFVector2D\u0040\u0040 \u003FA0x3a4a4fc4\u002EFourSampleOffsets;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EFourSampleOffsets\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVFMeshPaintWindow\u0040\u0040\u00408;
  internal static double ColorPickerConstants\u002E\u003FA0x3a4a4fc4\u002EMaxAllowedUpdateEventTime;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EkErrorColor\u0024initializer\u0024;
  internal static wxColour \u003FA0x3a4a4fc4\u002EkWarningColor;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EkWarningColor\u0024initializer\u0024;
  internal static unsafe FGameAssetDatabase* \u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FLandscapeEditWindow\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_103 \u003F\u003F_R0\u003FAVUpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_26 \u003F\u003F_R0\u003FAVFImportColorsScreen\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxEvtHandler\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat0001;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat0001\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FLightmapResRatioWindow\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FMeshPaintWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_40 \u003F\u003F_R2wxTopLevelWindowBase\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FTickableObject\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EDebugUtilColor\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_81 \u003F\u003F_R0\u003FAVCleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxFrame\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FLightmapResRatioWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7FContentBrowser\u0040\u00406BFTickableObject\u0040\u0040\u0040;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVFLandscapeEditWindow\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4WxPropertyWindowFrame\u0040\u00406BwxFrame\u0040\u0040\u0040;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EAPP_NAME\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FTickableObject\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EEightRefiningSamples\u0024initializer\u0024;
  internal static gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E GFileNotificationWrapper;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EGFileNotificationWrapper\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAVFContentBrowser\u0040\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1BA\u0040\u003F0A\u0040EA\u0040FCallbackEventDevice\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ERotationSignificantThreshold;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ERotationSignificantThreshold\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_23 \u003F\u003F_R0\u003FAVwxTopLevelWindow\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BC\u0040\u0024\u0024CBVFVector\u0040\u0040 \u003FA0x3a4a4fc4\u002EKDopDir18;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir18\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_27 \u003F\u003F_R0\u003FAVFLightingToolsWindow\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FContentBrowser\u0040\u00408;
  internal static unsafe FAboutScreen* \u003FInstance\u0040FAboutScreen\u0040\u00400PEAV1\u0040EA;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxTopLevelWindowMSW\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4CleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxTopLevelWindow\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_17 \u003F\u003F_R0\u003FAVFStartPage\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVwxDialogBase\u0040\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxFrameBase\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EPRODUCT_NAME\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2UObjectSerializer\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FFoliageEditWindow\u0040\u00408;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK2;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK2\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3UObjectSerializer\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_24 \u003F\u003F_R2FConsolidateWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7FConsolidateWindow\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1BI\u0040\u003F0A\u0040EA\u0040FSourceControlEventListener\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY05Q6AXXZ \u003F\u003F_7FTickableObject\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static gcroot\u003CMWPFFrame\u0020\u005E\u003E MatineeWindows\u002EGRecordFrame;
  internal static __FnPtr<void ()> MatineeWindows\u002E\u003FA0x3a4a4fc4\u002EGRecordFrame\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_56 \u003F\u003F_R2wxTopLevelWindow\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FLandscapeEditWindow\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1CLA\u0040\u003F0A\u0040EA\u0040FDeferredInitializationWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7FGameAssetDatabase\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FLightmapResRatioWindow\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_15 \u003F\u003F_R0\u003FAVwxWindow\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FWelcomeScreen\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxFrame\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4UObjectSerializer\u0040\u00406B\u0040;
  internal static gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E MatineeWindows\u002EGRecordPanelHelper;
  internal static __FnPtr<void ()> MatineeWindows\u002E\u003FA0x3a4a4fc4\u002EGRecordPanelHelper\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_19 \u003F\u003F_R0\u003FAVFAboutScreen\u0040\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FTickableObject\u0040\u00408;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Right\u0024initializer\u0024;
  internal static wxColour \u003FA0x3a4a4fc4\u002EkNormalColor;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EkNormalColor\u0024initializer\u0024;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EPathStepCache\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FDeferredInitializationWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2UObject\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FMeshPaintWindow\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_18 \u003F\u003F_R0\u003FAVwxFrameBase\u0040\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FRenderCommand\u0040\u00408;
  internal static TArray\u003CFName\u002CFDefaultAllocator\u003E \u003FA0x3a4a4fc4\u002E\u003FFoundTags\u0040\u003F1\u003F\u003FQueryTagsForAsset\u0040FGameAssetDatabase\u0040\u0040QEBAXVFName\u0040\u0040W4Type\u0040ETagQueryOptions\u0040\u0040AEAV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z\u00404V\u003F\u0024TArray\u0040VFName\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FLightingToolsWindow\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FImportColorsScreen\u0040\u00406B\u0040;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ESmallLengthThreshold;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHalf;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHundredth;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EAnimWeightThreshold;
  internal static VectorRegister GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK0;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FGameAssetDatabase\u0040\u00408;
  internal static uint \u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FGameAssetDatabase\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FLandscapeEditWindow\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FImportColorsScreen\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FSerializableObject\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EFourEdgeSamples\u0024initializer\u0024;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHalf\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FLightingToolsWindow\u0040\u00408;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2wxEvtHandler\u0040\u00408;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EAnimWeightThreshold\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FStartPage\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040UObjectSerializer\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FSourceControlEventListener\u0040\u00408;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FStartPage\u0040\u00406B\u0040;
  internal static gcroot\u003CMWPFFrame\u0020\u005E\u003E MatineeWindows\u002EGDirectorFrame;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3wxWindow\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxWindow\u0040\u00408;
  internal static uint \u003FA0x3a4a4fc4\u002E\u003FbAlreadyWarned\u0040\u003FBA\u0040\u003F\u003FLoadSettings\u0040FPerforceSourceControlProvider\u0040\u0040AEAAXXZ\u00404IA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY03Q6AXXZ \u003F\u003F_7CleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u00406B\u0040;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK0\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdateGizmo\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAVFGameAssetDatabase\u0040\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7FSerializableObject\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FMeshPaintWindow\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FAboutScreen\u0040\u00406B\u0040;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Out\u0024initializer\u0024;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_25 \u003F\u003F_R0\u003FAVFConsolidateWindow\u0040\u0040\u00408;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ESmallLengthThreshold\u0024initializer\u0024;
  internal static __FnPtr<void ()> MatineeWindows\u002E\u003FA0x3a4a4fc4\u002EGDirectorFrame\u0024initializer\u0024;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FRenderCommand\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FLightingToolsWindow\u0040\u00406B\u0040;
  internal static \u0024ArrayType\u0024\u0024\u0024BY02Q6AXXZ \u003F\u003F_7FContentBrowser\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EKDopDir26\u0024initializer\u0024;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FAboutScreen\u0040\u00408;
  internal static unsafe FNewMapScreen* \u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA;
  internal static __FnPtr<void ()> GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHundredth\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FSerializableObject\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EVECTOR_ONE\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3UObject\u0040\u00408;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EGColorPickerFrame\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FRenderCommand\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FSourceControlEventListener\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_22 \u003F\u003F_R0\u003FAVFTickableObject\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_21 \u003F\u003F_R0\u003FAVFWelcomeScreen\u0040\u0040\u00408;
  internal static FVector \u003FA0x3a4a4fc4\u002EVecZero;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002EVecZero\u0024initializer\u0024;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_64 \u003F\u003F_R2wxDialogBase\u0040\u00408;
  internal static uint \u003FA0x3a4a4fc4\u002E\u003FbPerformingUpdate\u0040\u003F1\u003F\u003FOnColorPickerPropertyChanged\u0040MColorPickerPanel\u0040\u0040IE\u0024AAMXPE\u0024AAVObject\u0040System\u0040\u0040PE\u0024AAVPropertyChangedEventArgs\u0040ComponentModel\u00404\u0040\u0040Z\u00404IA;
  internal static __FnPtr<void ()> \u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples\u0024initializer\u0024;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3CleanupEditToolRenderData\u0040\u003F1\u003F\u003FCleanup\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXXZ\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FLandscapeEditWindow\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040WxPropertyWindowFrame\u0040\u00408;
  internal static unsafe FImportColorsScreen* \u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040wxTopLevelWindowMSW\u0040\u00408;
  internal static unsafe FConsolidateWindow* \u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FDeferredInitializationWindow\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0L\u0040Q6AXXZ \u003F\u003F_7FWelcomeScreen\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2UpdateEditToolRenderData\u0040\u003F1\u003F\u003FUpdate\u0040FLandscapeEditToolRenderData\u0040\u0040QEAAXPEAVUMaterialInterface\u0040\u0040\u0040Z\u00408;
  internal static __FnPtr<void ()> SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Up\u0024initializer\u0024;
  public static __FnPtr<void ()> __m2mep\u0040\u003FDisplayAboutScreen\u0040FAboutScreen\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void* (FAboutScreen*, uint)> __m2mep\u0040\u003F\u003F_EFAboutScreen\u0040\u0040\u0024\u0024FEEAAPEAXI\u0040Z;
  public static __FnPtr<void (FAboutScreen*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FAboutScreen\u0040\u0040\u0024\u0024FMEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FContentBrowser*)> __m2mep\u0040\u003FIsTickableWhenPaused\u0040FContentBrowser\u0040\u0040\u0024\u0024FMEBAIXZ;
  public static __FnPtr<uint (FContentBrowser*)> __m2mep\u0040\u003FIsTickableInEditor\u0040FContentBrowser\u0040\u0040\u0024\u0024FMEBAIXZ;
  public static __FnPtr<uint (FContentBrowser*)> __m2mep\u0040\u003FIsTickable\u0040FContentBrowser\u0040\u0040\u0024\u0024FMEBAIXZ;
  public static __FnPtr<void* (WxPropertyWindowFrame*, uint)> __m2mep\u0040\u003F\u003F_EWxPropertyWindowFrame\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<int (UClass*, UClass*)> __m2mep\u0040\u003FCompare\u0040CompareContentBrowserCLRUClassPointer\u0040\u0040\u0024\u0024FSAHPEAVUClass\u0040\u00400\u0040Z;
  public static __FnPtr<int (FContentBrowser*, FString*)> __m2mep\u0040\u003FGenerateSelectedAssetString\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAHPEAVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FContentBrowser*, UPackage*)> __m2mep\u0040\u003FAllowPackageSave\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAIPEAVUPackage\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FString*, TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FUnmarshalAssetItems\u0040FContentBrowser\u0040\u0040\u0024\u0024FSAIAEBVFString\u0040\u0040AEAV\u003F\u0024TArray\u0040UFSelectedAssetInfo\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FString*)> __m2mep\u0040\u003FIsAssetValidForLoading\u0040FContentBrowser\u0040\u0040\u0024\u0024FSAIAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FString*)> __m2mep\u0040\u003FIsAssetValidForPlacing\u0040FContentBrowser\u0040\u0040\u0024\u0024FSAIAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<FContentBrowser* (WxContentBrowserHost*, HWND__*)> __m2mep\u0040\u003FCreateContentBrowser\u0040FContentBrowser\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAVWxContentBrowserHost\u0040\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FContentBrowser*, uint)> __m2mep\u0040\u003F\u003F_EFContentBrowser\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FContentBrowser*, HWND__*, int, int, int, int)> __m2mep\u0040\u003FResize\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXPEAUHWND__\u0040\u0040HHHH\u0040Z;
  public static __FnPtr<void (FContentBrowser*)> __m2mep\u0040\u003FSetFocus\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* (FContentBrowser*)> __m2mep\u0040\u003FGetSharedThumbnailClasses\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEBAPEBV\u003F\u0024TArray\u0040PEAVUClass\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040XZ;
  public static __FnPtr<TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* (FContentBrowser*)> __m2mep\u0040\u003FGetBrowsableObjectTypeMap\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEBAAEBV\u003F\u0024TMap\u0040PEAVUClass\u0040\u0040V\u003F\u0024TArray\u0040PEAVUGenericBrowserType\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ;
  public static __FnPtr<void (FContentBrowser*, FArchive*)> __m2mep\u0040\u003FSerialize\u0040FContentBrowser\u0040\u0040\u0024\u0024FMEAAXAEAVFArchive\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, float)> __m2mep\u0040\u003FTick\u0040FContentBrowser\u0040\u0040\u0024\u0024FMEAAXM\u0040Z;
  public static __FnPtr<void (FContentBrowser*, TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FSyncToObjects\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXAEAV\u003F\u0024TArray\u0040PEAVUObject\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FSyncToPackages\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXAEBV\u003F\u0024TArray\u0040PEAVUPackage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, FString*)> __m2mep\u0040\u003FCreateLocalCollection\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, FString*)> __m2mep\u0040\u003FDestroyLocalCollection\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<bool (FContentBrowser*, FString*, TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FAddAssetsToLocalCollection\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAA_NAEBVFString\u0040\u0040AEBV\u003F\u0024TArray\u0040PEAVUObject\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, FString*, EGADCollection.Type)> __m2mep\u0040\u003FSelectCollection\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*)> __m2mep\u0040\u003FGoToSearch\u0040FContentBrowser\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<void (FContentBrowser*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FContentBrowser\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, ECallbackEventType, uint)> __m2mep\u0040\u003FSend\u0040FContentBrowser\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040K\u0040Z;
  public static __FnPtr<void (FContentBrowser*, ECallbackEventType, UObject*)> __m2mep\u0040\u003FSend\u0040FContentBrowser\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040PEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, FCallbackEventParameters*)> __m2mep\u0040\u003FSend\u0040FContentBrowser\u0040\u0040\u0024\u0024FUEAAXAEBUFCallbackEventParameters\u0040\u0040\u0040Z;
  public static __FnPtr<void (FContentBrowser*, FSourceControlCommand*)> __m2mep\u0040\u003FSourceControlCallback\u0040FContentBrowser\u0040\u0040\u0024\u0024FUEAAXPEAUFSourceControlCommand\u0040\u0040\u0040Z;
  public static __FnPtr<void (FGameAssetDatabaseStartupConfig*, FString*)> __m2mep\u0040\u003FInit\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FSAXAEBUFGameAssetDatabaseStartupConfig\u0040\u0040AEAVFString\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FDestroy\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FCheckJournalAlarm\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void* (FGameAssetDatabase*, uint)> __m2mep\u0040\u003F\u003F_EFGameAssetDatabase\u0040\u0040\u0024\u0024FEEAAPEAXI\u0040Z;
  public static __FnPtr<void (TMap\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TMap\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void (TSortableMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TSortableMapBase\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void (TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TMapBase\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<bool (FGameAssetDatabase*)> __m2mep\u0040\u003FIsReadOnly\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEBA_NXZ;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*)> __m2mep\u0040\u003FCreateTag\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*)> __m2mep\u0040\u003FDestroyTag\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, TArray\u003CFString\u002CFDefaultAllocator\u003E*, FString*)> __m2mep\u0040\u003FRemoveTagFromAssets\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040AEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, TArray\u003CFString\u002CFDefaultAllocator\u003E*, FString*)> __m2mep\u0040\u003FAddTagToAssets\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040AEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*, EGADCollection.Type)> __m2mep\u0040\u003FCreateCollection\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*, EGADCollection.Type)> __m2mep\u0040\u003FDestroyCollection\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*, EGADCollection.Type, TArray\u003CFString\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FAddAssetsToCollection\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040AEBV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FGameAssetDatabase*, FString*, EGADCollection.Type, TArray\u003CFString\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FRemoveAssetsFromCollection\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAIAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040AEBV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<void (FGameAssetDatabase*, FString*, EGADCollection.Type, TArray\u003CFString\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FQueryAssetsInCollection\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FQEAAXAEBVFString\u0040\u0040W4Type\u0040EGADCollection\u0040\u0040AEAV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<FString* (FString*, FString*)> __m2mep\u0040\u003FMakeObjectTypeSystemTag\u0040FGameAssetDatabase\u0040\u0040\u0024\u0024FSA\u003FAVFString\u0040\u0040AEBV2\u0040\u0040Z;
  public static __FnPtr<int (FString*, FString*)> __m2mep\u0040\u003FCompare\u0040CompareGameAssetDatabaseFStringConstRef\u0040\u0040\u0024\u0024FSAHAEBVFString\u0040\u00400\u0040Z;
  public static __FnPtr<ColorPickerResults (FPickColorStruct*)> __m2mep\u0040\u003FPickColorWPF\u0040\u0040\u0024\u0024FYA\u003FAW4ColorPickerResults\u0040ColorPickerConstants\u0040\u0040AEBUFPickColorStruct\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FTickColorPickerWPF\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void (wxWindow*)> __m2mep\u0040\u003FUnBindColorPickers\u0040\u0040\u0024\u0024FYAXPEAVwxWindow\u0040\u0040\u0040Z;
  public static __FnPtr<void (FPropertyNode*)> __m2mep\u0040\u003FUnBindColorPickers\u0040\u0040\u0024\u0024FYAXPEAVFPropertyNode\u0040\u0040\u0040Z;
  public static __FnPtr<void (UObject*)> __m2mep\u0040\u003FUnBindColorPickers\u0040\u0040\u0024\u0024FYAXPEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FCloseColorPickers\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FShutdown\u0040FImportColorsScreen\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void* (FImportColorsScreen*, uint)> __m2mep\u0040\u003F\u003F_EFImportColorsScreen\u0040\u0040\u0024\u0024FEEAAPEAXI\u0040Z;
  public static __FnPtr<void (FImportColorsScreen*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FImportColorsScreen\u0040\u0040\u0024\u0024FMEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<FMeshPaintWindow* (FEdModeMeshPaint*)> __m2mep\u0040\u003FCreateMeshPaintWindow\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAVFEdModeMeshPaint\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FMeshPaintWindow*, uint)> __m2mep\u0040\u003F\u003F_EFMeshPaintWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FMeshPaintWindow*)> __m2mep\u0040\u003FRefreshAllProperties\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<uint (FMeshPaintWindow*)> __m2mep\u0040\u003FIsMouseOverWindow\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FQEAAIXZ;
  public static __FnPtr<void (FMeshPaintWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (FMeshPaintWindow*, ECallbackEventType, UObject*)> __m2mep\u0040\u003FSend\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040PEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<void (FMeshPaintWindow*, ECallbackEventType, FViewport*, uint)> __m2mep\u0040\u003FSend\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040PEAVFViewport\u0040\u0040I\u0040Z;
  public static __FnPtr<void (FMeshPaintWindow*, ECallbackEventType, FString*, UObject*)> __m2mep\u0040\u003FSend\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040AEBVFString\u0040\u0040PEAVUObject\u0040\u0040\u0040Z;
  public static __FnPtr<void (FMeshPaintWindow*)> __m2mep\u0040\u003FRefreshTextureTargetListProperties\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<void (FMeshPaintWindow*, bool)> __m2mep\u0040\u003FTransactionBufferSizeBreech\u0040FMeshPaintWindow\u0040\u0040\u0024\u0024FQEAAX_N\u0040Z;
  public static __FnPtr<void (FPerforceSourceControlProvider*)> __m2mep\u0040\u003FInit\u0040FPerforceSourceControlProvider\u0040\u0040\u0024\u0024FMEAAXXZ;
  public static __FnPtr<uint (FPerforceSourceControlProvider*, FSourceControlCommand*)> __m2mep\u0040\u003FExecuteCommand\u0040FPerforceSourceControlProvider\u0040\u0040\u0024\u0024FUEBAIPEAUFSourceControlCommand\u0040\u0040\u0040Z;
  public static __FnPtr<void (FPerforceSourceControlProvider*, FSourceControlCommand*)> __m2mep\u0040\u003FRespondToCommandErrorType\u0040FPerforceSourceControlProvider\u0040\u0040\u0024\u0024FUEAAXAEBUFSourceControlCommand\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FAddResolveHandler\u0040InteropTools\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FInitUnrealEdCSharpBackend\u0040InteropTools\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FLoadResourceDictionaries\u0040InteropTools\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<int (char*, HINSTANCE__*, HINSTANCE__*, int)> __m2mep\u0040\u003FManagedGuardedMain\u0040\u0040\u0024\u0024FYAHPEB_WPEAUHINSTANCE__\u0040\u00401H\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FPerformHardwareSurveyDumpCLR\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void (TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FPerformHardwareSurveyCLR\u0040\u0040\u0024\u0024FYAXAEAV\u003F\u0024TArray\u0040EVFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z;
  public static __FnPtr<FStartPage* (WxStartPageHost*, HWND__*)> __m2mep\u0040\u003FCreateStartPage\u0040FStartPage\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAVWxStartPageHost\u0040\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FStartPage*, uint)> __m2mep\u0040\u003F\u003F_EFStartPage\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FStartPage*, HWND__*, int, int, int, int)> __m2mep\u0040\u003FResize\u0040FStartPage\u0040\u0040\u0024\u0024FQEAAXPEAUHWND__\u0040\u0040HHHH\u0040Z;
  public static __FnPtr<void (FStartPage*)> __m2mep\u0040\u003FSetFocus\u0040FStartPage\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<FLightmapResRatioWindow* (HWND__*)> __m2mep\u0040\u003FCreateLightmapResRatioWindow\u0040FLightmapResRatioWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FLightmapResRatioWindow*, uint)> __m2mep\u0040\u003F\u003F_EFLightmapResRatioWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FLightmapResRatioWindow*, uint)> __m2mep\u0040\u003FShowWindow\u0040FLightmapResRatioWindow\u0040\u0040\u0024\u0024FQEAAXI\u0040Z;
  public static __FnPtr<void (FLightmapResRatioWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FLightmapResRatioWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (WxInterpEd*)> __m2mep\u0040\u003FLaunchDirectorWindow\u0040MatineeWindows\u0040\u0040\u0024\u0024FYAXPEAVWxInterpEd\u0040\u0040\u0040Z;
  public static __FnPtr<void (WxInterpEd*)> __m2mep\u0040\u003FCloseDirectorWindow\u0040MatineeWindows\u0040\u0040\u0024\u0024FYAXPEAVWxInterpEd\u0040\u0040\u0040Z;
  public static __FnPtr<void (WxInterpEd*)> __m2mep\u0040\u003FCloseRecordWindow\u0040MatineeWindows\u0040\u0040\u0024\u0024FYAXPEAVWxInterpEd\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FFocusRecordWindow\u0040MatineeWindows\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FShutdown\u0040FConsolidateWindow\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<uint (TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*, TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*)> __m2mep\u0040\u003FDetermineAssetCompatibility\u0040FConsolidateWindow\u0040\u0040\u0024\u0024FSAIAEBV\u003F\u0024TArray\u0040PEAVUObject\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040AEAV2\u0040\u0040Z;
  public static __FnPtr<void (FConsolidateWindow*, FArchive*)> __m2mep\u0040\u003FSerialize\u0040FConsolidateWindow\u0040\u0040\u0024\u0024FUEAAXAEAVFArchive\u0040\u0040\u0040Z;
  public static __FnPtr<void (FConsolidateWindow*, ECallbackEventType, uint)> __m2mep\u0040\u003FSend\u0040FConsolidateWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040K\u0040Z;
  public static __FnPtr<void* (FConsolidateWindow*, uint)> __m2mep\u0040\u003F\u003F_EFConsolidateWindow\u0040\u0040\u0024\u0024FEEAAPEAXI\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FTickFileSystemNotifications\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void (uint, uint)> __m2mep\u0040\u003FSetFileSystemNotificationsForEditor\u0040\u0040\u0024\u0024FYAXII\u0040Z;
  public static __FnPtr<void (uint)> __m2mep\u0040\u003FSetFileSystemNotificationsForAnimSet\u0040\u0040\u0024\u0024FYAXI\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FCloseFileSystemNotification\u0040\u0040\u0024\u0024FYAXXZ;
  public static __FnPtr<void (FSourceControlEventListener*)> __m2mep\u0040\u003FPromptForBuildAndSubmit\u0040BuildWindows\u0040\u0040\u0024\u0024FYAXPEAVFSourceControlEventListener\u0040\u0040\u0040Z;
  public static __FnPtr<FLightingToolsWindow* (HWND__*)> __m2mep\u0040\u003FCreateLightingToolsWindow\u0040FLightingToolsWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FLightingToolsWindow*, uint)> __m2mep\u0040\u003F\u003F_EFLightingToolsWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FLightingToolsWindow*, uint)> __m2mep\u0040\u003FShowWindow\u0040FLightingToolsWindow\u0040\u0040\u0024\u0024FQEAAXI\u0040Z;
  public static __FnPtr<void (FLightingToolsWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FLightingToolsWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<FLandscapeEditWindow* (FEdModeLandscape*, HWND__*)> __m2mep\u0040\u003FCreateLandscapeEditWindow\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAVFEdModeLandscape\u0040\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FLandscapeEditWindow*, uint)> __m2mep\u0040\u003F\u003F_EFLandscapeEditWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FLandscapeEditWindow*)> __m2mep\u0040\u003FSaveWindowSettings\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<void (FLandscapeEditWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (FLandscapeEditWindow*, FString*)> __m2mep\u0040\u003FNotifyCurrentToolChanged\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FQEAAXAEBVFString\u0040\u0040\u0040Z;
  public static __FnPtr<void (FLandscapeEditWindow*, uint)> __m2mep\u0040\u003FNotifyMaskEnableChanged\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FQEAAXI\u0040Z;
  public static __FnPtr<void (FLandscapeEditWindow*, float)> __m2mep\u0040\u003FNotifyBrushSizeChanged\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FQEAAXM\u0040Z;
  public static __FnPtr<void (FLandscapeEditWindow*, int)> __m2mep\u0040\u003FNotifyBrushComponentSizeChanged\u0040FLandscapeEditWindow\u0040\u0040\u0024\u0024FQEAAXH\u0040Z;
  public static __FnPtr<uint ()> __m2mep\u0040\u003FShouldDisplayWelcomeScreenAtStartup\u0040FWelcomeScreen\u0040\u0040\u0024\u0024FSAIXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FDisplayWelcomeScreen\u0040FWelcomeScreen\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void ()> __m2mep\u0040\u003FShutdown\u0040FWelcomeScreen\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void* (FWelcomeScreen*, uint)> __m2mep\u0040\u003F\u003F_EFWelcomeScreen\u0040\u0040\u0024\u0024FEEAAPEAXI\u0040Z;
  public static __FnPtr<void (FWelcomeScreen*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FWelcomeScreen\u0040\u0040\u0024\u0024FMEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<uint (FExportLocalizationOptions*)> __m2mep\u0040\u003FPromptForExportLocalizationOptions\u0040ExportLocalizationWindow\u0040\u0040\u0024\u0024FYAIAEAUFExportLocalizationOptions\u00401\u0040\u0040Z;
  public static __FnPtr<FFoliageEditWindow* (FEdModeFoliage*, HWND__*)> __m2mep\u0040\u003FCreateFoliageEditWindow\u0040FFoliageEditWindow\u0040\u0040\u0024\u0024FSAPEAV1\u0040PEAVFEdModeFoliage\u0040\u0040QEAUHWND__\u0040\u0040\u0040Z;
  public static __FnPtr<void* (FFoliageEditWindow*, uint)> __m2mep\u0040\u003F\u003F_EFFoliageEditWindow\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<void (FFoliageEditWindow*)> __m2mep\u0040\u003FSaveWindowSettings\u0040FFoliageEditWindow\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<void (FFoliageEditWindow*, ECallbackEventType)> __m2mep\u0040\u003FSend\u0040FFoliageEditWindow\u0040\u0040\u0024\u0024FUEAAXW4ECallbackEventType\u0040\u0040\u0040Z;
  public static __FnPtr<void (FFoliageEditWindow*)> __m2mep\u0040\u003FRefreshMeshListProperties\u0040FFoliageEditWindow\u0040\u0040\u0024\u0024FQEAAXXZ;
  public static __FnPtr<int (TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E*, FString*)> __m2mep\u0040\u003FDisplayNewMapScreen\u0040FNewMapScreen\u0040\u0040\u0024\u0024FSAHAEBV\u003F\u0024TArray\u0040PEAVUTemplateMapMetadata\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040AEAVFString\u0040\u0040\u0040Z;
  public static __FnPtr<void ()> __m2mep\u0040\u003FShutdown\u0040FNewMapScreen\u0040\u0040\u0024\u0024FSAXXZ;
  public static __FnPtr<void (TSortableMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TSortableMapBase\u0040PEAVUClass\u0040\u0040V\u003F\u0024TArray\u0040PEAVUGenericBrowserType\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void (TSortableMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TSortableMapBase\u0040PEAVUGenericBrowserType\u0040\u0040V\u003F\u0024TArray\u0040PEAVUClass\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void (TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TMapBase\u0040PEAVUClass\u0040\u0040V\u003F\u0024TArray\u0040PEAVUGenericBrowserType\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void (TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E*)> __m2mep\u0040\u003F\u003F1\u003F\u0024TMapBase\u0040PEAVUGenericBrowserType\u0040\u0040V\u003F\u0024TArray\u0040PEAVUClass\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void* (FObjectSupportedCommandType*, uint)> __m2mep\u0040\u003F\u003F_GFObjectSupportedCommandType\u0040\u0040\u0024\u0024FQEAAPEAXI\u0040Z;
  public static __FnPtr<void* (FSourceControl.FSourceControlFileHistoryInfo*, uint)> __m2mep\u0040\u003F\u003F_GFSourceControlFileHistoryInfo\u0040FSourceControl\u0040\u0040\u0024\u0024FQEAAPEAXI\u0040Z;
  public static __FnPtr<void (TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.FPair*)> __m2mep\u0040\u003F\u003F1FPair\u0040\u003F\u0024TMapBase\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAA\u0040XZ;
  public static __FnPtr<void* (TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E.FElement*, uint)> __m2mep\u0040\u003F\u003F_GFElement\u0040\u003F\u0024TSet\u0040VFPair\u0040\u003F\u0024TMapBase\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040UKeyFuncs\u00402\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAAPEAXI\u0040Z;
  public static __FnPtr<void* (TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.FPair*, uint)> __m2mep\u0040\u003F\u003F_GFPair\u0040\u003F\u0024TMapBase\u0040VFName\u0040\u0040V\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u00240A\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040\u0024\u0024FQEAAPEAXI\u0040Z;
  public static __FnPtr<void* (FContentBrowser*, uint)> __m2mep\u0040\u003F\u003F_EFContentBrowser\u0040\u0040\u0024\u0024FW7EAAPEAXI\u0040Z;
  public static __FnPtr<void* (FContentBrowser*, uint)> __m2mep\u0040\u003F\u003F_EFContentBrowser\u0040\u0040\u0024\u0024FWBA\u0040EAAPEAXI\u0040Z;
  public static __FnPtr<void* (FConsolidateWindow*, uint)> __m2mep\u0040\u003F\u003F_EFConsolidateWindow\u0040\u0040\u0024\u0024FG7EAAPEAXI\u0040Z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D0;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BL\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D1;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D2;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D3;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D4;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BN\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D5;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BM\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D6;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D7;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CG\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D8;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BI\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D9;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0CE\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D10;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BJ\u0040\u0024\u0024CB_W \u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D11;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FSwarmInterfaceImpl\u0040NSwarm\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040Q6AXXZ \u003F\u003F_7FSwarmInterfaceImpl\u0040NSwarm\u0040\u00406B\u0040;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FSwarmInterfaceImpl\u0040NSwarm\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_8 \u003F\u003F_R2FSwarmInterface\u0040NSwarm\u0040\u00408;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u00408;
  internal static unsafe FSwarmInterface* \u003FGInstance\u0040FSwarmInterface\u0040NSwarm\u0040\u00400PEAV12\u0040EA;
  internal static _s__RTTICompleteObjectLocator2 \u003F\u003F_R4FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
  internal static \u0024_s__RTTIBaseClassArray\u0024_extraBytes_16 \u003F\u003F_R2FSwarmInterfaceImpl\u0040NSwarm\u0040\u00408;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0BB\u0040Q6AXXZ \u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
  internal static _s__RTTIBaseClassDescriptor2 \u003F\u003F_R1A\u0040\u003F0A\u0040EA\u0040FSwarmInterface\u0040NSwarm\u0040\u00408;
  internal static _s__RTTIClassHierarchyDescriptor \u003F\u003F_R3FSwarmInterface\u0040NSwarm\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_29 \u003F\u003F_R0\u003FAVFSwarmInterface\u0040NSwarm\u0040\u0040\u00408;
  internal static \u0024_TypeDescriptor\u0024_extraBytes_33 \u003F\u003F_R0\u003FAVFSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u00408;
  public static __FnPtr<void* (FSwarmInterface*, uint)> __m2mep\u0040\u003F\u003F_EFSwarmInterface\u0040NSwarm\u0040\u0040\u0024\u0024FMEAAPEAXI\u0040Z;
  public static __FnPtr<void* (FSwarmInterfaceImpl*, uint)> __m2mep\u0040\u003F\u003F_EFSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAPEAXI\u0040Z;
  public static __FnPtr<FSwarmInterface* ()> __m2mep\u0040\u003FGet\u0040FSwarmInterface\u0040NSwarm\u0040\u0040\u0024\u0024FSAAEAV12\u0040XZ;
  public static __FnPtr<int (FSwarmInterfaceImpl*, __FnPtr<void (FMessage*, void*)>, void*, TLogFlags)> __m2mep\u0040\u003FOpenConnection\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHP6AXPEAVFMessage\u00402\u0040PEAX\u0040Z1W4TLogFlags\u00402\u0040\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*)> __m2mep\u0040\u003FCloseConnection\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHXZ;
  public static __FnPtr<int (FSwarmInterfaceImpl*, FMessage*)> __m2mep\u0040\u003FSendMessage\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHAEBVFMessage\u00402\u0040\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, char*, char*)> __m2mep\u0040\u003FAddChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHPEB_W0\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, char*)> __m2mep\u0040\u003FTestChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHPEB_W\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, char*, TChannelFlags)> __m2mep\u0040\u003FOpenChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHPEB_WW4TChannelFlags\u00402\u0040\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, int)> __m2mep\u0040\u003FCloseChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHH\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, int, void*, int)> __m2mep\u0040\u003FWriteChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHHPEBXH\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, int, void*, int)> __m2mep\u0040\u003FReadChannel\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHHPEAXH\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, NSwarm.FGuid*)> __m2mep\u0040\u003FOpenJob\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHAEBUFGuid\u00402\u0040\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, FJobSpecification*, FJobSpecification*)> __m2mep\u0040\u003FBeginJobSpecification\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHAEBVFJobSpecification\u00402\u00400\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*, FTaskSpecification*)> __m2mep\u0040\u003FAddTask\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHAEBVFTaskSpecification\u00402\u0040\u0040Z;
  public static __FnPtr<int (FSwarmInterfaceImpl*)> __m2mep\u0040\u003FEndJobSpecification\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHXZ;
  public static __FnPtr<int (FSwarmInterfaceImpl*)> __m2mep\u0040\u003FCloseJob\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHXZ;
  public static __FnPtr<int (FSwarmInterfaceImpl*, TVerbosityLevel, uint, char*)> __m2mep\u0040\u003FLog\u0040FSwarmInterfaceImpl\u0040NSwarm\u0040\u0040\u0024\u0024FUEAAHW4TVerbosityLevel\u00402\u0040IPEB_W\u0040Z;
  internal static __s_GUID _GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02;
  internal static __s_GUID _GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xc_mp_z;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xi_vt_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FInitializedVtables\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  [FixedAddressValueType]
  internal static bool \u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FIsDefaultDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xc_ma_a;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FInitializedPerAppDomain\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xc_ma_z;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FInitializedNative\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static __s_GUID _GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xi_vt_z;
  [FixedAddressValueType]
  internal static int \u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FUninitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  [FixedAddressValueType]
  internal static int \u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FInitialized\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  internal static bool \u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  [FixedAddressValueType]
  internal static Progress.State \u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A;
  internal static bool \u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static bool \u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static int \u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA;
  internal static TriBool.State \u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static TriBool.State \u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A;
  internal static bool \u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY00Q6MPEBXXZ \u003FA0x73b2ab14\u002E__xc_mp_a;
  internal static __s_GUID _GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02;
  internal static __FnPtr<void ()> \u003FA0x73b2ab14\u002E\u003FInitializedPerProcess\u0024initializer\u0024\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2P6MXXZEA;
  public static __FnPtr<int (void*)> __m2mep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static __FnPtr<int (void*)> __m2mep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static unsafe int** __unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  public static unsafe int** __unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z;
  internal static __FnPtr<void ()> std\u002E\u003FA0x89bca58d\u002E_Fac_tidy_reg\u0024initializer\u0024;
  internal static unsafe _Fac_node* std\u002E\u003FA0x89bca58d\u002E_Fac_head;
  [FixedAddressValueType]
  internal static ulong __exit_list_size_app_domain;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitbegin_app_domain;
  internal static ulong \u003FA0x47cf2733\u002E__exit_list_size;
  [FixedAddressValueType]
  internal static unsafe __FnPtr<void ()>* __onexitend_app_domain;
  internal static unsafe __FnPtr<void ()>* \u003FA0x47cf2733\u002E__onexitbegin_m;
  internal static unsafe __FnPtr<void ()>* \u003FA0x47cf2733\u002E__onexitend_m;
  [FixedAddressValueType]
  internal static int \u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  [FixedAddressValueType]
  internal static unsafe void* \u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA;
  internal static unsafe FxClass* \u003F_pClassDesc\u0040FxGestureConfig\u0040Face\u0040OC3Ent\u0040\u00400PEAVFxClass\u004023\u0040EA;
  internal static unsafe FDynamicRHI* GDynamicRHI;
  internal static \u0024ArrayType\u0024\u0024\u0024BY01Q6AXXZ \u003F\u003F_7type_info\u0040\u00406B\u0040;
  internal static unsafe FCallbackEventObserver* GCallbackEvent;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040USubstanceAirImageInput\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UUnrealEdEngine* GUnrealEd;
  internal static unsafe UEditorEngine* GEditor;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040K GCRCTable;
  internal static uint GIsEditor;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040USubstanceAirTexture2D\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UClass\u0040\u00400PEAV1\u0040EA;
  internal static unsafe FOutputDeviceRedirectorBase* GLog;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UObject\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static uint GExitPurge;
  internal static unsafe WxUnrealEdApp* GApp;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UInterface\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe \u0024ArrayType\u0024\u0024\u0024BY0A\u0040\u0024\u0024CB_W* __imp_wxDirDialogNameStr;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040AStaticMeshActor\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe wxCursor* __imp_wxNullCursor;
  internal static TStaticBitArray\u003C128\u003E SHOW_DefaultEditor;
  internal static unsafe FOutputDeviceError* GError;
  internal static TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E \u003FGObjObjects\u0040UObject\u0040\u00400V\u003F\u0024TArray\u0040PEAVUObject\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UTexture\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe wxSize* __imp_wxDefaultSize;
  internal static unsafe wxPoint* __imp_wxDefaultPosition;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EAA\u0040_W GEditorIni;
  internal static int GBuiltFromChangeList;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040ATerrain\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe FPackageFileCache* GPackageFileCache;
  internal static FNewUDKProjectSettings \u003FStaticNewUDKProjectSettings\u0040FNewUDKProjectSettings\u0040\u00401V1\u0040A;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UIconThumbnailRenderer\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static uint GIsUCC;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UObjectSerializer\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe FConfigCacheIni* GConfig;
  internal static TStaticBitArray\u003C128\u003E SHOW_DefaultGame;
  internal static TArrayNoInit\u003CFTickableObject\u0020\u002A\u003E \u003FTickableObjects\u0040FTickableObject\u0040\u00402V\u003F\u0024TArrayNoInit\u0040PEAVFTickableObject\u0040\u0040\u0040\u0040A;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EA\u0040_W GGameName;
  internal static uint GIsBuildMachine;
  internal static FName \u003FDataWeightmapName\u0040ALandscape\u0040\u00402VFName\u0040\u0040A;
  internal static uint GIsAffectingClassDefaultObject;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UUIRoot\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static TStaticBitArray\u003C128\u003E SHOW_ViewMode_Lit;
  internal static TStaticBitArray\u003C128\u003E SHOW_ViewMode_LightingOnly;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UGenericBrowserType\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static FMeshPaintSettings \u003FStaticMeshPaintSettings\u0040FMeshPaintSettings\u0040\u00401V1\u0040A;
  internal static uint GIsUnitTesting;
  internal static ulong GNumTimingCodeCalls;
  internal static uint GIsAssociatingLevel;
  internal static unsafe \u0024ArrayType\u0024\u0024\u0024BY0A\u0040\u0024\u0024CB_W* __imp_wxDialogNameStr;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UGenericBrowserType_Sounds\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UArchetypeThumbnailRenderer\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static FString \u003FDefaultMapExt\u0040FURL\u0040\u00402VFString\u0040\u0040A;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UStaticMesh\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static FLightmapResRatioAdjustSettings \u003FLightmapResRatioAdjustSettings\u0040FLightmapResRatioAdjustSettings\u0040\u00401V1\u0040A;
  internal static unsafe UWorld* GWorld;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EAA\u0040_W GEditorUserSettingsIni;
  internal static unsafe FEditorLevelViewportClient* GCurrentLevelEditingViewportClient;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040AActor\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EAA\u0040_W GEngineIni;
  internal static unsafe UObjectSerializer* \u003FGObjectSerializer\u0040FSerializableObject\u0040\u00402PEAVUObjectSerializer\u0040\u0040EA;
  internal static int GEngineVersion;
  internal static int wxEVT_DOCKINGCHANGE;
  internal static uint GIsUnattended;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UMaterialInterface\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static ELandscapeViewMode.Type GLandscapeViewMode;
  internal static unsafe char* \u003FFILE_HISTORY_ITEM_DELIMITER\u0040FSourceControlFileHistoryInfo\u0040FSourceControl\u0040\u00402PEB_WEB;
  internal static unsafe UEngine* GEngine;
  internal static uint GIsPlayInEditorWorld;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UGenericBrowserType_All\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static uint GIsGame;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UPackage\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static uint GIsWatchingEndLoad;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040_W GPackage;
  internal static unsafe UPropertyWindowManager* GPropertyWindowManager;
  internal static uint GIsAsyncLoading;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UMaterial\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040USoundCue\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0EAAA\u0040_W GErrorHist;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UInstancedFoliageSettings\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UGenericBrowserType_Archetype\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static uint GEdSelectionLock;
  internal static unsafe FFileManager* GFileManager;
  internal static unsafe int* __imp_wxEVT_NULL;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040ADynamicSMActor\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static int \u003FGObjFirstGCIndex\u0040UObject\u0040\u00400HA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040USoundNodeWave\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040ALandscape\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UPhysicalMaterial\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe FFeedbackContext* GWarn;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040ULandscapeLayerInfoObject\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static FLightingToolsSettings \u003FLightingToolsSettings\u0040FLightingToolsSettings\u0040\u00401V1\u0040A;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UFactory\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static double GSecondsPerCycle;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UTexture2D\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static unsafe UClass* \u003FPrivateStaticClass\u0040UGenericBrowserType_Custom\u0040\u00400PEAVUClass\u0040\u0040EA;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_z;
  internal static volatile uint __native_vcclrit_reason;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AXXZ __xc_a;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_a;
  internal static volatile __enative_startup_state __native_startup_state;
  internal static \u0024ArrayType\u0024\u0024\u0024BY0A\u0040P6AHXZ __xi_z;
  internal static volatile unsafe void* __native_startup_lock;
  internal static volatile uint __native_dllmain_reason;

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040VECTOR_ZERO\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x230b4690\u002EVECTOR_ZERO = \u003CModule\u003E.MakeVectorRegister(0.0f, 0.0f, 0.0f, 0.0f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040VECTOR_ONE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x230b4690\u002EVECTOR_ONE = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, 1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040Float0001\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat0001 = \u003CModule\u003E.MakeVectorRegister(0.0f, 0.0f, 0.0f, 1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040SmallLengthThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002ESmallLengthThreshold = \u003CModule\u003E.MakeVectorRegister(1E-08f, 1E-08f, 1E-08f, 1E-08f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040FloatOneHundredth\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHundredth = \u003CModule\u003E.MakeVectorRegister(0.01f, 0.01f, 0.01f, 0.01f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040Float111_Minus1\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloat111_Minus1 = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, -1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040FloatOneHalf\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EFloatOneHalf = \u003CModule\u003E.MakeVectorRegister(0.5f, 0.5f, 0.5f, 0.5f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040QINV_SIGN_MASK\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQINV_SIGN_MASK = \u003CModule\u003E.MakeVectorRegister(-1f, -1f, -1f, 1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040QMULTI_SIGN_MASK0\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK0 = \u003CModule\u003E.MakeVectorRegister(1f, -1f, 1f, -1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040QMULTI_SIGN_MASK1\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK1 = \u003CModule\u003E.MakeVectorRegister(1f, 1f, -1f, -1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040QMULTI_SIGN_MASK2\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EQMULTI_SIGN_MASK2 = \u003CModule\u003E.MakeVectorRegister(-1f, 1f, 1f, -1f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040AnimWeightThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002EAnimWeightThreshold = \u003CModule\u003E.MakeVectorRegister(1E-05f, 1E-05f, 1E-05f, 1E-05f);

  internal static void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040RotationSignificantThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x230b4690\u002ERotationSignificantThreshold = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, 1f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040DebugUtilColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor, (byte) 20, (byte) 226, (byte) 64, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 4), (byte) 210, (byte) 21, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 8), (byte) 72, (byte) 100, (byte) 224, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 12), (byte) 14, (byte) 153, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 16), (byte) 186, (byte) 0, (byte) 186, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 20), (byte) 54, (byte) 0, (byte) 175, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 24), (byte) 25, (byte) 204, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 28), (byte) 15, (byte) 189, (byte) 147, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 32), (byte) 23, (byte) 165, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 36), (byte) 26, (byte) 206, (byte) 120, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 40), (byte) 28, (byte) 163, (byte) 176, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 44), (byte) 29, (byte) 0, (byte) 188, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 48), (byte) 130, (byte) 0, (byte) 50, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 52), (byte) 31, (byte) 0, (byte) 163, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 56), (byte) 147, (byte) 0, (byte) 190, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 60), (byte) 1, (byte) 0, (byte) 109, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 64), (byte) 2, (byte) 126, (byte) 203, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 68), (byte) 3, (byte) 0, (byte) 58, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 72), (byte) 4, (byte) 92, (byte) 218, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 76), (byte) 5, (byte) 151, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 80), (byte) 18, (byte) 221, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 84), (byte) 6, (byte) 0, (byte) 131, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 88), (byte) 7, (byte) 163, (byte) 176, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 92), (byte) 8, (byte) 0, (byte) 151, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 96), (byte) 102, (byte) 0, (byte) 216, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 100), (byte) 10, (byte) 0, (byte) 171, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 104), (byte) 11, (byte) 112, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 108), (byte) 12, (byte) 167, (byte) 172, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 112), (byte) 13, (byte) 189, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 116), (byte) 16, (byte) 155, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 120), (byte) 178, (byte) 161, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EDebugUtilColor + 124), (byte) 19, (byte) 25, (byte) 126, byte.MaxValue);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040PathStepCache\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EPathStepCache);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040PathStepCache\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040PathStepCache\u0040\u0040YMXXZ() => \u003CModule\u003E.TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EPathStepCache);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vRHCS_Yup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Out, 0.0f, 0.0f, -1f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vRHCS_Yup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vRHCS_Yup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vRHCS_Yup_Up, 0.0f, 1f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Yup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Out, 0.0f, 0.0f, 1f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Yup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Yup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Yup_Up, 0.0f, 1f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Zup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Out, 0.0f, -1f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Zup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040c_vLHCS_Zup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x230b4690\u002Ec_vLHCS_Zup_Up, 0.0f, 0.0f, 1f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir6\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir6 + 60), 0.0f, 0.0f, -1f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir10X\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10X + 108), 0.0f, -0.7071068f, 0.7071068f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir10Y\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 72), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 84), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 96), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Y + 108), -0.7071068f, 0.0f, 0.7071068f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir10Z\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 72), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 84), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 96), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir10Z + 108), -0.7071068f, 0.7071068f, 0.0f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir18\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 108), 0.0f, -0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 120), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 132), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 144), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 156), -0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 168), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 180), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 192), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir18 + 204), -0.7071068f, 0.7071068f, 0.0f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040KDopDir26\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 108), 0.0f, -0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 120), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 132), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 144), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 156), -0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 168), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 180), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 192), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 204), -0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 216), 0.5773503f, 0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 228), 0.5773503f, 0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 240), 0.5773503f, -0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 252), 0.5773503f, -0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 264), -0.5773503f, 0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 276), -0.5773503f, 0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 288), -0.5773503f, -0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x230b4690\u002EKDopDir26 + 300), -0.5773503f, -0.5773503f, -0.5773503f);
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040DefaultPerspectiveViewLocation\u0040EditorViewportDefs\u0040\u0040YMXXZ() => \u003CModule\u003E.FVector\u002E\u007Bctor\u007D(&\u003CModule\u003E.EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewLocation, -1024f, 0.0f, 512f);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040DefaultPerspectiveViewRotation\u0040EditorViewportDefs\u0040\u0040YMXXZ() => \u003CModule\u003E.FRotator\u002E\u007Bctor\u007D(&\u003CModule\u003E.EditorViewportDefs\u002E\u003FA0x230b4690\u002EDefaultPerspectiveViewRotation, -2730, 0, 0);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040PRODUCT_NAME\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EPRODUCT_NAME, \u003CModule\u003E.wxGetTranslation((char*) &\u003CModule\u003E.\u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D22, (char*) 0L));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040PRODUCT_NAME\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040PRODUCT_NAME\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EPRODUCT_NAME);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040APP_VERSION\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_VERSION, \u003CModule\u003E.wxGetTranslation((char*) &\u003CModule\u003E.\u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D23, (char*) 0L));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_VERSION\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_VERSION\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_VERSION);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040APP_NAME\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_NAME, &\u003CModule\u003E.\u003FA0x230b4690\u002EPRODUCT_NAME);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_NAME\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_NAME\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_NAME);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040APP_TITLE\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_TITLE, &\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_NAME);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_TITLE\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040APP_TITLE\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EAPP_TITLE);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040kNormalColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkNormalColor, (byte) 192, (byte) 192, (byte) 192, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kNormalColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kNormalColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkNormalColor);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040kWarningColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkWarningColor, byte.MaxValue, byte.MaxValue, (byte) 128, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kWarningColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kWarningColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkWarningColor);

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__E\u003FA0x230b4690\u0040kErrorColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkErrorColor, byte.MaxValue, (byte) 128, (byte) 128, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kErrorColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x230b4690\u002E\u003F\u003F__F\u003FA0x230b4690\u0040kErrorColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x230b4690\u002EkErrorColor);

  internal static unsafe FGraphInstanceEditorWindow* FGraphInstanceEditorWindow\u002ECreateGraphInstanceEditorWindow(
    FGraphInstance* InGraphInstance,
    HWND__* InParentWindowHandle)
  {
    FGraphInstanceEditorWindow* instanceEditorWindowPtr1 = (FGraphInstanceEditorWindow*) \u003CModule\u003E.@new(148UL);
    FGraphInstanceEditorWindow* instanceEditorWindowPtr2;
    // ISSUE: fault handler
    try
    {
      instanceEditorWindowPtr2 = (IntPtr) instanceEditorWindowPtr1 == IntPtr.Zero ? (FGraphInstanceEditorWindow*) 0L : \u003CModule\u003E.FGraphInstanceEditorWindow\u002E\u007Bctor\u007D(instanceEditorWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) instanceEditorWindowPtr1);
    }
    if (\u003CModule\u003E.FGraphInstanceEditorWindow\u002EInitGraphInstanceEditorWindow(instanceEditorWindowPtr2, InGraphInstance, InParentWindowHandle) == 0U)
    {
      if ((IntPtr) instanceEditorWindowPtr2 != IntPtr.Zero)
      {
        FGraphInstanceEditorWindow* instanceEditorWindowPtr3 = instanceEditorWindowPtr2;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) instanceEditorWindowPtr2)((uint) instanceEditorWindowPtr3, new IntPtr(1));
      }
      return (FGraphInstanceEditorWindow*) 0L;
    }
    \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA = InGraphInstance;
    return instanceEditorWindowPtr2;
  }

  internal static unsafe FGraphInstanceEditorWindow* FGraphInstanceEditorWindow\u002E\u007Bctor\u007D(
    [In] FGraphInstanceEditorWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FGraphInstanceEditorWindow\u0040\u00406B\u0040;
      \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 8L));
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FLinearColor\u002E\u007Bctor\u007D((FLinearColor*) ((IntPtr) obj0 + 116L));
        *(long*) ((IntPtr) obj0 + 132L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
        // ISSUE: fault handler
        try
        {
          *(long*) ((IntPtr) obj0 + 140L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
          // ISSUE: fault handler
          try
          {
            FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
            FGraphInstanceEditorWindow* instanceEditorWindowPtr1 = obj0;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 51, (IntPtr) instanceEditorWindowPtr1);
            FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
            FGraphInstanceEditorWindow* instanceEditorWindowPtr2 = obj0;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 10, (IntPtr) instanceEditorWindowPtr2);
            FCallbackEventObserver* gcallbackEvent3 = \u003CModule\u003E.GCallbackEvent;
            FGraphInstanceEditorWindow* instanceEditorWindowPtr3 = obj0;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent3, (ECallbackEventType) 84, (IntPtr) instanceEditorWindowPtr3);
            FCallbackEventObserver* gcallbackEvent4 = \u003CModule\u003E.GCallbackEvent;
            FGraphInstanceEditorWindow* instanceEditorWindowPtr4 = obj0;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent4, (ECallbackEventType) 36, (IntPtr) instanceEditorWindowPtr4);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 140L));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 132L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FGraphInstanceEditorWindow\u002E__vecDelDtor(
    [In] FGraphInstanceEditorWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FGraphInstanceEditorWindow* instanceEditorWindowPtr = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 148UL, *(int*) instanceEditorWindowPtr, (__FnPtr<void (void*)>) __methodptr(FGraphInstanceEditorWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) instanceEditorWindowPtr);
      return (void*) instanceEditorWindowPtr;
    }
    \u003CModule\u003E.FGraphInstanceEditorWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FPickColorStruct\u002E\u007Bdtor\u007D([In] FPickColorStruct* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 80L));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 64L));
          }
          \u003CModule\u003E.TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 64L));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 48L));
        }
        \u003CModule\u003E.TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 48L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32L));
      }
      \u003CModule\u003E.TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 32L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
    }
    \u003CModule\u003E.TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 16L));
  }

  internal static unsafe void FGraphInstanceEditorWindow\u002E\u007Bdtor\u007D(
    [In] FGraphInstanceEditorWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FGraphInstanceEditorWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        FGraphInstanceEditorWindow* instanceEditorWindowPtr1;
        // ISSUE: fault handler
        try
        {
          FGraphInstanceEditorWindow* instanceEditorWindowPtr2;
          // ISSUE: fault handler
          try
          {
            instanceEditorWindowPtr1 = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 132L);
            auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E* autoGcrootMwpfFramePtr = (auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E*) instanceEditorWindowPtr1;
            if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr) != null)
            {
              if ((\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr) != null ? 1 : 0) != 0)
                \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr)?.Dispose();
              \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr, (MWPFFrame) null);
            }
            instanceEditorWindowPtr2 = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 140L);
            auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* instanceEditorWindowPtr3 = (auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2;
            if (\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3) != null)
            {
              if ((\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3) != null ? 1 : 0) != 0)
                \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3)?.Dispose();
              \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3, (MGraphInstanceEditorWindow) null);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 140L));
          }
          auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* instanceEditorWindowPtr4 = (auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2;
          // ISSUE: fault handler
          try
          {
            if ((\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr4) != null ? 1 : 0) != 0)
              \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr4)?.Dispose();
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) instanceEditorWindowPtr4);
          }
          \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr4);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 132L));
        }
        auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E* autoGcrootMwpfFramePtr1 = (auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E*) instanceEditorWindowPtr1;
        // ISSUE: fault handler
        try
        {
          if ((\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr1) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr1)?.Dispose();
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) autoGcrootMwpfFramePtr1);
        }
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) autoGcrootMwpfFramePtr1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 8L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe uint FGraphInstanceEditorWindow\u002EInitGraphInstanceEditorWindow(
    [In] FGraphInstanceEditorWindow* obj0,
    FGraphInstance* InGraphInstance,
    HWND__* InParentWindowHandle)
  {
    WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
    InSettings.WindowTitle = "Graph Instance Editor";
    InSettings.bShowCloseButton = 1U;
    InSettings.bUseWxDialog = 1U;
    InSettings.PositionX = -1;
    InSettings.PositionY = -1;
    FGraphInstanceEditorWindow* instanceEditorWindowPtr1 = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 116L);
    FLinearColor* flinearColorPtr = (FLinearColor*) instanceEditorWindowPtr1;
    \u003CModule\u003E.TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem((TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 56L), &flinearColorPtr);
    *(int*) ((IntPtr) obj0 + 108L) = 0;
    *(int*) ((IntPtr) obj0 + 112L) = 0;
    FString fstring;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring, (char*) &\u003CModule\u003E.\u003FA0x230b4690\u002Eunnamed\u002Dglobal\u002D24);
    FGraphInstanceEditorWindow* instanceEditorWindowPtr2;
    // ISSUE: fault handler
    try
    {
      MWPFFrame _new_ptr = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring);
      instanceEditorWindowPtr2 = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 132L);
      \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E*) instanceEditorWindowPtr2, _new_ptr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    MGraphInstanceEditorWindow _new_ptr1 = new MGraphInstanceEditorWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) instanceEditorWindowPtr2), InGraphInstance, (FPickColorStruct*) ((IntPtr) obj0 + 8L), (FLinearColor*) instanceEditorWindowPtr1);
    FGraphInstanceEditorWindow* instanceEditorWindowPtr3 = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 140L);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3, _new_ptr1);
    MGraphInstanceEditorWindow instanceEditorWindow = \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr3);
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) instanceEditorWindowPtr2).SetContentAndShow((MWPFPanel) instanceEditorWindow);
    return 1;
  }

  internal static unsafe void FGraphInstanceEditorWindow\u002ESend(
    [In] FGraphInstanceEditorWindow* obj0,
    ECallbackEventType Event)
  {
    if (Event != (ECallbackEventType) 10)
      return;
    \u003CModule\u003E.CloseColorPickers();
    FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
    FGraphInstanceEditorWindow* instanceEditorWindowPtr1 = obj0;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) instanceEditorWindowPtr1);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 132L), (MWPFFrame) null);
    auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* instanceEditorWindowPtr2 = (auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 140L);
    if (\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2) != null)
    {
      if ((\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2)?.Dispose();
      \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr2, (MGraphInstanceEditorWindow) null);
    }
    \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA = (FGraphInstance*) 0L;
  }

  internal static unsafe void FGraphInstanceEditorWindow\u002ESend(
    [In] FGraphInstanceEditorWindow* obj0,
    ECallbackEventType InType,
    UObject* InObject)
  {
    if (InType != (ECallbackEventType) 36 || (IntPtr) \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA == IntPtr.Zero || (IntPtr) InObject != *(long*) ((IntPtr) \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA + 72L))
      return;
    FGraphInstanceEditorWindow* instanceEditorWindowPtr = (FGraphInstanceEditorWindow*) ((IntPtr) obj0 + 140L);
    \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr).BuildInputList();
    \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr).BuildImageInputList();
    \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) instanceEditorWindowPtr).SynchColorPicker();
  }

  internal static unsafe void FGraphInstanceEditorWindow\u002ESend(
    [In] FGraphInstanceEditorWindow* obj0,
    ECallbackEventType InType,
    FString* InString,
    UObject* InObject)
  {
    if (InType != (ECallbackEventType) 51 || (IntPtr) \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA == IntPtr.Zero || (\u003CModule\u003E.UObject\u002EGetOutermost((UObject*) *(long*) ((IntPtr) \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA + 72L)) != InObject || *(int*) ((IntPtr) \u003CModule\u003E.GApp + 168L) == 1))
      return;
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 132L), (MWPFFrame) null);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 140L), (MGraphInstanceEditorWindow) null);
    \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA = (FGraphInstance*) 0L;
  }

  internal static unsafe FGraphInstance* FGraphInstanceEditorWindow\u002EGetEditedInstance() => \u003CModule\u003E.\u003FGraphInstance\u0040FGraphInstanceEditorWindow\u0040\u00402PEAUFGraphInstance\u0040SubstanceAir\u0040\u0040EA;

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0,
    MWPFFrame _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* obj0,
    MGraphInstanceEditorWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMWPFFrame\u0020\u005E\u003E* gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0,
    MWPFFrame t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MWPFFrame gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(
    [In] gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0)
  {
    return (MWPFFrame) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* obj0,
    MGraphInstanceEditorWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MGraphInstanceEditorWindow gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGraphInstanceEditorWindow\u0040\u0040(
    [In] gcroot\u003CMGraphInstanceEditorWindow\u0020\u005E\u003E* obj0)
  {
    return (MGraphInstanceEditorWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040VECTOR_ZERO\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EVECTOR_ZERO = \u003CModule\u003E.MakeVectorRegister(0.0f, 0.0f, 0.0f, 0.0f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040VECTOR_ONE\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EVECTOR_ONE = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, 1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040Float0001\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat0001 = \u003CModule\u003E.MakeVectorRegister(0.0f, 0.0f, 0.0f, 1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040SmallLengthThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ESmallLengthThreshold = \u003CModule\u003E.MakeVectorRegister(1E-08f, 1E-08f, 1E-08f, 1E-08f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040FloatOneHundredth\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHundredth = \u003CModule\u003E.MakeVectorRegister(0.01f, 0.01f, 0.01f, 0.01f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040Float111_Minus1\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloat111_Minus1 = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, -1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040FloatOneHalf\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EFloatOneHalf = \u003CModule\u003E.MakeVectorRegister(0.5f, 0.5f, 0.5f, 0.5f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040QINV_SIGN_MASK\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQINV_SIGN_MASK = \u003CModule\u003E.MakeVectorRegister(-1f, -1f, -1f, 1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040QMULTI_SIGN_MASK0\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK0 = \u003CModule\u003E.MakeVectorRegister(1f, -1f, 1f, -1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040QMULTI_SIGN_MASK1\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK1 = \u003CModule\u003E.MakeVectorRegister(1f, 1f, -1f, -1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040QMULTI_SIGN_MASK2\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EQMULTI_SIGN_MASK2 = \u003CModule\u003E.MakeVectorRegister(-1f, 1f, 1f, -1f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040AnimWeightThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002EAnimWeightThreshold = \u003CModule\u003E.MakeVectorRegister(1E-05f, 1E-05f, 1E-05f, 1E-05f);

  internal static void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040RotationSignificantThreshold\u0040GlobalVectorConstants\u0040\u0040YMXXZ() => \u003CModule\u003E.GlobalVectorConstants\u002E\u003FA0x3a4a4fc4\u002ERotationSignificantThreshold = \u003CModule\u003E.MakeVectorRegister(1f, 1f, 1f, 1f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040DebugUtilColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor, (byte) 20, (byte) 226, (byte) 64, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 4), (byte) 210, (byte) 21, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 8), (byte) 72, (byte) 100, (byte) 224, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 12), (byte) 14, (byte) 153, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 16), (byte) 186, (byte) 0, (byte) 186, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 20), (byte) 54, (byte) 0, (byte) 175, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 24), (byte) 25, (byte) 204, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 28), (byte) 15, (byte) 189, (byte) 147, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 32), (byte) 23, (byte) 165, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 36), (byte) 26, (byte) 206, (byte) 120, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 40), (byte) 28, (byte) 163, (byte) 176, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 44), (byte) 29, (byte) 0, (byte) 188, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 48), (byte) 130, (byte) 0, (byte) 50, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 52), (byte) 31, (byte) 0, (byte) 163, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 56), (byte) 147, (byte) 0, (byte) 190, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 60), (byte) 1, (byte) 0, (byte) 109, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 64), (byte) 2, (byte) 126, (byte) 203, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 68), (byte) 3, (byte) 0, (byte) 58, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 72), (byte) 4, (byte) 92, (byte) 218, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 76), (byte) 5, (byte) 151, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 80), (byte) 18, (byte) 221, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 84), (byte) 6, (byte) 0, (byte) 131, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 88), (byte) 7, (byte) 163, (byte) 176, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 92), (byte) 8, (byte) 0, (byte) 151, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 96), (byte) 102, (byte) 0, (byte) 216, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 100), (byte) 10, (byte) 0, (byte) 171, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 104), (byte) 11, (byte) 112, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 108), (byte) 12, (byte) 167, (byte) 172, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 112), (byte) 13, (byte) 189, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 116), (byte) 16, (byte) 155, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 120), (byte) 178, (byte) 161, (byte) 0, byte.MaxValue);
    \u003CModule\u003E.FColor\u002E\u007Bctor\u007D((FColor*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EDebugUtilColor + 124), (byte) 19, (byte) 25, (byte) 126, byte.MaxValue);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040PathStepCache\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EPathStepCache);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040PathStepCache\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040PathStepCache\u0040\u0040YMXXZ() => \u003CModule\u003E.TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EPathStepCache);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vRHCS_Yup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Out, 0.0f, 0.0f, -1f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vRHCS_Yup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vRHCS_Yup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vRHCS_Yup_Up, 0.0f, 1f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Yup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Out, 0.0f, 0.0f, 1f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Yup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Yup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Yup_Up, 0.0f, 1f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Zup_Out\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Out, 0.0f, -1f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Zup_Right\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Right, 1f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040c_vLHCS_Zup_Up\u0040SpeedTree\u0040\u0040YMXXZ() => \u003CModule\u003E.SpeedTree\u002EVec3\u002E\u007Bctor\u007D(&\u003CModule\u003E.SpeedTree\u002E\u003FA0x3a4a4fc4\u002Ec_vLHCS_Zup_Up, 0.0f, 0.0f, 1f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir6\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir6 + 60), 0.0f, 0.0f, -1f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir10X\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10X + 108), 0.0f, -0.7071068f, 0.7071068f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir10Y\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 72), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 84), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 96), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Y + 108), -0.7071068f, 0.0f, 0.7071068f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir10Z\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 72), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 84), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 96), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir10Z + 108), -0.7071068f, 0.7071068f, 0.0f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir18\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 108), 0.0f, -0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 120), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 132), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 144), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 156), -0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 168), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 180), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 192), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir18 + 204), -0.7071068f, 0.7071068f, 0.0f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040KDopDir26\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26, 1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 12), -1f, 0.0f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 24), 0.0f, 1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 36), 0.0f, -1f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 48), 0.0f, 0.0f, 1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 60), 0.0f, 0.0f, -1f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 72), 0.0f, 0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 84), 0.0f, -0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 96), 0.0f, 0.7071068f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 108), 0.0f, -0.7071068f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 120), 0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 132), -0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 144), 0.7071068f, 0.0f, -0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 156), -0.7071068f, 0.0f, 0.7071068f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 168), 0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 180), -0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 192), 0.7071068f, -0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 204), -0.7071068f, 0.7071068f, 0.0f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 216), 0.5773503f, 0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 228), 0.5773503f, 0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 240), 0.5773503f, -0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 252), 0.5773503f, -0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 264), -0.5773503f, 0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 276), -0.5773503f, 0.5773503f, -0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 288), -0.5773503f, -0.5773503f, 0.5773503f);
    \u003CModule\u003E.FVector\u002E\u007Bctor\u007D((FVector*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EKDopDir26 + 300), -0.5773503f, -0.5773503f, -0.5773503f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040DefaultPerspectiveViewLocation\u0040EditorViewportDefs\u0040\u0040YMXXZ() => \u003CModule\u003E.FVector\u002E\u007Bctor\u007D(&\u003CModule\u003E.EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewLocation, -1024f, 0.0f, 512f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040DefaultPerspectiveViewRotation\u0040EditorViewportDefs\u0040\u0040YMXXZ() => \u003CModule\u003E.FRotator\u002E\u007Bctor\u007D(&\u003CModule\u003E.EditorViewportDefs\u002E\u003FA0x3a4a4fc4\u002EDefaultPerspectiveViewRotation, -2730, 0, 0);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040PRODUCT_NAME\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EPRODUCT_NAME, \u003CModule\u003E.wxGetTranslation((char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D31, (char*) 0L));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040PRODUCT_NAME\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040PRODUCT_NAME\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EPRODUCT_NAME);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040APP_VERSION\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_VERSION, \u003CModule\u003E.wxGetTranslation((char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D32, (char*) 0L));
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_VERSION\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_VERSION\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_VERSION);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040APP_NAME\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_NAME, &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EPRODUCT_NAME);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_NAME\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_NAME\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_NAME);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040APP_TITLE\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxString\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_TITLE, &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_NAME);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_TITLE\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040APP_TITLE\u0040\u0040YMXXZ() => \u003CModule\u003E.wxString\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EAPP_TITLE);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040kNormalColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkNormalColor, (byte) 192, (byte) 192, (byte) 192, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kNormalColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kNormalColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkNormalColor);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040kWarningColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkWarningColor, byte.MaxValue, byte.MaxValue, (byte) 128, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kWarningColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kWarningColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkWarningColor);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040kErrorColor\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.wxColour\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkErrorColor, byte.MaxValue, (byte) 128, (byte) 128, byte.MaxValue);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kErrorColor\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FA0x3a4a4fc4\u0040kErrorColor\u0040\u0040YMXXZ() => \u003CModule\u003E.wxColour\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EkErrorColor);

  internal static unsafe void FAboutScreen\u002EDisplayAboutScreen()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FAboutScreen\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FAboutScreen* faboutScreenPtr1 = (FAboutScreen*) \u003CModule\u003E.@new(24UL);
      FAboutScreen* faboutScreenPtr2;
      // ISSUE: fault handler
      try
      {
        faboutScreenPtr2 = (IntPtr) faboutScreenPtr1 == IntPtr.Zero ? (FAboutScreen*) 0L : \u003CModule\u003E.FAboutScreen\u002E\u007Bctor\u007D(faboutScreenPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) faboutScreenPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FAboutScreen\u0040\u00400PEAV1\u0040EA = faboutScreenPtr2;
    }
    FAboutScreen* faboutScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FAboutScreen\u0040\u00400PEAV1\u0040EA;
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) faboutScreen0PeaV1Ea + 8L)).SetContentAndShow((MWPFPanel) \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMAboutScreenPanel\u0040\u0040((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) ((IntPtr) faboutScreen0PeaV1Ea + 16L)));
  }

  internal static unsafe FAboutScreen* FAboutScreen\u002E\u007Bctor\u007D(
    [In] FAboutScreen* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FAboutScreen\u0040\u00406B\u0040;
      FAboutScreen* faboutScreenPtr1 = (FAboutScreen*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) faboutScreenPtr1);
      // ISSUE: fault handler
      try
      {
        FAboutScreen* faboutScreenPtr2 = (FAboutScreen*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2);
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
          FAboutScreen* faboutScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) faboutScreenPtr3);
          FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
          FAboutScreen* faboutScreenPtr4 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) faboutScreenPtr4);
          FString fstring1;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D33);
          // ISSUE: fault handler
          try
          {
            string InXaml = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring1), 0, \u003CModule\u003E.FString\u002ELen(&fstring1));
            \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2, new MAboutScreenPanel(InXaml));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
          InSettings.bCenterWindow = 1U;
          InSettings.bUseSaveLayout = 0U;
          FString fstring2;
          \u003CModule\u003E.Localize(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D35, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D34, (char*) &\u003CModule\u003E.GPackage, (char*) 0L, 0U);
          // ISSUE: fault handler
          try
          {
            if (\u003CModule\u003E.FString\u002ELen(&fstring2) > 0)
            {
              FString fstring3;
              FString* fstring4 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring3, \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2).AppName);
              // ISSUE: fault handler
              try
              {
                FString fstring5;
                FString* fstring6 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring5, \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2).AppName);
                // ISSUE: fault handler
                try
                {
                  FString fstring7;
                  FString* fstringPtr = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(&fstring7, \u003CModule\u003E.FormatLocalizedString\u003Cwchar_t\u0020const\u0020\u002A\u003E(\u003CModule\u003E.TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(\u003CModule\u003E.FString\u002EGetCharArray(&fstring2)), \u003CModule\u003E.FString\u002E\u002A(fstring6)), \u003CModule\u003E.FString\u002E\u002A(fstring4));
                  // ISSUE: fault handler
                  try
                  {
                    FString fstring8;
                    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring8, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
                    // ISSUE: fault handler
                    try
                    {
                      string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring8), 0, \u003CModule\u003E.FString\u002ELen(&fstring8));
                      InSettings.WindowTitle = str;
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring8);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring8);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring7);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring7);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
            }
            FString fstring9;
            \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring9, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D36);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) faboutScreenPtr1, new MWPFFrame((wxWindow*) 0L, InSettings, &fstring9));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring9);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring9);
            if (InSettings is IDisposable disposable8)
              disposable8.Dispose();
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FAboutScreen\u002E__vecDelDtor([In] FAboutScreen* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FAboutScreen* faboutScreenPtr = (FAboutScreen*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24UL, *(int*) faboutScreenPtr, (__FnPtr<void (void*)>) __methodptr(FAboutScreen\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) faboutScreenPtr);
      return (void*) faboutScreenPtr;
    }
    \u003CModule\u003E.FAboutScreen\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FAboutScreen\u002E\u007Bdtor\u007D([In] FAboutScreen* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FAboutScreen\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FAboutScreen* faboutScreenPtr1;
      // ISSUE: fault handler
      try
      {
        FAboutScreen* faboutScreenPtr2;
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
          FAboutScreen* faboutScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) faboutScreenPtr3);
          faboutScreenPtr2 = (FAboutScreen*) ((IntPtr) obj0 + 16L);
          if (\u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMAboutScreenPanel\u0040\u0040((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2) is IDisposable disposable6)
            disposable6.Dispose();
          faboutScreenPtr1 = (FAboutScreen*) ((IntPtr) obj0 + 8L);
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) faboutScreenPtr1)?.Dispose();
          IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E maboutScreenPanel;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref maboutScreenPanel = (long) num1.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) faboutScreenPtr2)).Target = (object) \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMAboutScreenPanel\u0040\u0040(&maboutScreenPanel);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &maboutScreenPanel);
          }
          \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&maboutScreenPanel);
          IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref gcrootMwpfFrame = (long) num2.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) faboutScreenPtr1)).Target = (object) \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
          }
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        \u003CModule\u003E.gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E*) faboutScreenPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) faboutScreenPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FAboutScreen\u002ESend([In] FAboutScreen* obj0, ECallbackEventType Event)
  {
    if (Event != (ECallbackEventType) 65)
    {
      if (Event != (ECallbackEventType) 66)
        return;
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 1);
    }
    else
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 0);
  }

  internal static unsafe uint FContentBrowser\u002EIsInitialized(int InstanceIndex) => (uint) (\u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A) > InstanceIndex);

  internal static unsafe FContentBrowser* FContentBrowser\u002EGetActiveInstance()
  {
    int num = 0;
    if (0 < \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A))
    {
      while (*(int*) (*(long*) \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, num) + 40L) == 0)
      {
        ++num;
        if (num >= \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A))
          goto label_4;
      }
      return (FContentBrowser*) *(long*) \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, num);
    }
label_4:
    return (FContentBrowser*) *(long*) \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, 0);
  }

  internal static unsafe uint FContentBrowser\u002EIsTickableWhenPaused([In] FContentBrowser* obj0) => 1;

  internal static unsafe uint FContentBrowser\u002EIsTickableInEditor([In] FContentBrowser* obj0) => 1;

  internal static unsafe uint FContentBrowser\u002EIsTickable([In] FContentBrowser* obj0) => 1;

  internal static unsafe uint \u003FA0x3a4a4fc4\u002ECloseFaceFX()
  {
    uint num = 1;
    wxWindow* mainWindow = \u003CModule\u003E.OC3Ent\u002EFace\u002EFxStudioApp\u002EGetMainWindow();
    if ((IntPtr) mainWindow != IntPtr.Zero)
    {
      FString fstring;
      FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D38, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D37, (char*) 0L);
      // ISSUE: fault handler
      try
      {
        num = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EappMsgf((EAppMsgType) 1, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
      if (num != 0U)
        \u003CModule\u003E.wxWindowBase\u002EClose((wxWindowBase*) mainWindow, false);
    }
    return num;
  }

  internal static AssetListRefreshMode \u003FA0x3a4a4fc4\u002ERefreshModeFromRefreshFlags(
    uint RefreshFlags)
  {
    return ((int) RefreshFlags & 128) != 0 ? AssetListRefreshMode.QuickRepopulate : (AssetListRefreshMode) ((int) (RefreshFlags >> 6) & 1);
  }

  internal static unsafe void TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void WxDlgNewGeneric\u002E\u007Bdtor\u007D([In] WxDlgNewGeneric* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 792L));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 728L));
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 728L));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 712L));
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 712L));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 696L));
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 696L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 688L));
      }
      \u003CModule\u003E.FSerializableObject\u002E\u007Bdtor\u007D((FSerializableObject*) ((IntPtr) obj0 + 688L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(wxDialog\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.wxDialog\u002E\u007Bdtor\u007D((wxDialog*) obj0);
  }

  internal static unsafe void* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E__delDtor(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    uint _param1)
  {
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe WxPropertyWindowFrame* WxPropertyWindowFrame\u002E\u007Bctor\u007D(
    [In] WxPropertyWindowFrame* obj0)
  {
    \u003CModule\u003E.wxFrame\u002E\u007Bctor\u007D((wxFrame*) obj0);
    // ISSUE: fault handler
    try
    {
      WxPropertyWindowFrame* propertyWindowFramePtr = (WxPropertyWindowFrame*) ((IntPtr) obj0 + 688L);
      \u003CModule\u003E.FDeferredInitializationWindow\u002E\u007Bctor\u007D((FDeferredInitializationWindow*) propertyWindowFramePtr);
      // ISSUE: fault handler
      try
      {
        *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7WxPropertyWindowFrame\u0040\u00406BwxFrame\u0040\u0040\u0040;
        *(long*) propertyWindowFramePtr = (long) &\u003CModule\u003E.\u003F\u003F_7WxPropertyWindowFrame\u0040\u00406BFDeferredInitializationWindow\u0040\u0040\u0040;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D((FString*) ((IntPtr) obj0 + 708L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FDeferredInitializationWindow\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 688L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(wxFrame\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* WxPropertyWindowFrame\u002E__vecDelDtor(
    [In] WxPropertyWindowFrame* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      WxPropertyWindowFrame* propertyWindowFramePtr = (WxPropertyWindowFrame*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 728UL, *(int*) propertyWindowFramePtr, (__FnPtr<void (void*)>) __methodptr(WxPropertyWindowFrame\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) propertyWindowFramePtr);
      return (void*) propertyWindowFramePtr;
    }
    \u003CModule\u003E.WxPropertyWindowFrame\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe int CompareContentBrowserCLRUClassPointer\u002ECompare(
    UClass* A,
    UClass* B)
  {
    return \u003CModule\u003E.appStricmp(\u003CModule\u003E.FString\u002E\u002A((FString*) ((IntPtr) \u003CModule\u003E.UClass\u002EGetDefaultObject\u003Cclass\u0020UFactory\u003E(A, 0U) + 112L)), \u003CModule\u003E.FString\u002E\u002A((FString*) ((IntPtr) \u003CModule\u003E.UClass\u002EGetDefaultObject\u003Cclass\u0020UFactory\u003E(B, 0U) + 112L)));
  }

  internal static unsafe void FObjectSupportedCommandType\u002E\u007Bdtor\u007D(
    [In] FObjectSupportedCommandType* obj0)
  {
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 8L));
  }

  internal static unsafe void FObjectThumbnail\u002E\u007Bdtor\u007D([In] FObjectThumbnail* obj0)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 24L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
    }
    \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 8L));
  }

  internal static unsafe void TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe int FContentBrowser\u002EGenerateSelectedAssetString(
    [In] FContentBrowser* obj0,
    FString* out_ResultString)
  {
    int num = 0;
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    if (mcontentBrowserControl != null && (IntPtr) out_ResultString != IntPtr.Zero)
      num = mcontentBrowserControl.GenerateSelectedAssetString(out_ResultString);
    return num;
  }

  internal static unsafe uint FContentBrowser\u002EAllowPackageSave(
    [In] FContentBrowser* obj0,
    UPackage* PackageToSave)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    return 1;
  }

  internal static unsafe uint FContentBrowser\u002EUnmarshalAssetItems(
    FString* MarshaledAssetString,
    TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* out_ClassPathPairs)
  {
    uint num1 = 0;
    \u0024ArrayType\u0024\u0024\u0024BY01_W arrayTypeBy01W;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ref arrayTypeBy01W = (short) 124;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(short&) ((IntPtr) &arrayTypeBy01W + 2) = (short) 0;
    TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FString\u002EParseIntoArray(MarshaledAssetString, &fdefaultAllocator, (char*) &arrayTypeBy01W, 1U);
      int num2 = 0;
      if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
      {
        do
        {
          FString* fstringPtr = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num2);
          FSelectedAssetInfo fselectedAssetInfo;
          \u003CModule\u003E.FSelectedAssetInfo\u002E\u007Bctor\u007D(&fselectedAssetInfo, fstringPtr);
          // ISSUE: fault handler
          try
          {
            if (\u003CModule\u003E.FSelectedAssetInfo\u002EIsValid(&fselectedAssetInfo, 0U) != 0U)
            {
              \u003CModule\u003E.TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002EAddItem(out_ClassPathPairs, &fselectedAssetInfo);
              num1 = 1U;
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSelectedAssetInfo\u002E\u007Bdtor\u007D), (void*) &fselectedAssetInfo);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) &fselectedAssetInfo + 8));
          ++num2;
        }
        while (num2 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
    return num1;
  }

  internal static unsafe void FSelectedAssetInfo\u002E\u007Bdtor\u007D([In] FSelectedAssetInfo* obj0) => \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 8L));

  internal static unsafe uint FContentBrowser\u002EIsAssetValidForLoading(FString* AssetPathName) => (uint) \u003CModule\u003E.CLRTools\u002EIsAssetValidForLoading(new string(\u003CModule\u003E.FString\u002E\u002A(AssetPathName), 0, \u003CModule\u003E.FString\u002ELen(AssetPathName)));

  internal static unsafe uint FContentBrowser\u002EIsAssetValidForPlacing(FString* AssetPathName) => (uint) \u003CModule\u003E.CLRTools\u002EIsAssetValidForPlacing(new string(\u003CModule\u003E.FString\u002E\u002A(AssetPathName), 0, \u003CModule\u003E.FString\u002ELen(AssetPathName)));

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A);

  internal static unsafe FContentBrowser* FContentBrowser\u002ECreateContentBrowser(
    WxContentBrowserHost* InParentBrowser,
    HWND__* InParentWindowHandle)
  {
    FContentBrowser* fcontentBrowserPtr1 = (FContentBrowser*) \u003CModule\u003E.@new(44UL);
    FContentBrowser* InNativeBrowserPtr;
    // ISSUE: fault handler
    try
    {
      InNativeBrowserPtr = (IntPtr) fcontentBrowserPtr1 == IntPtr.Zero ? (FContentBrowser*) 0L : \u003CModule\u003E.FContentBrowser\u002E\u007Bctor\u007D(fcontentBrowserPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) fcontentBrowserPtr1);
    }
    FContentBrowser* fcontentBrowserPtr2 = (FContentBrowser*) ((IntPtr) InNativeBrowserPtr + 32L);
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) fcontentBrowserPtr2, new MContentBrowserControl(InNativeBrowserPtr));
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) fcontentBrowserPtr2);
    if (mcontentBrowserControl != null && mcontentBrowserControl.InitContentBrowser(InParentBrowser, InParentWindowHandle) != 0U)
      return InNativeBrowserPtr;
    if ((IntPtr) InNativeBrowserPtr != IntPtr.Zero)
    {
      FContentBrowser* fcontentBrowserPtr3 = InNativeBrowserPtr;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) InNativeBrowserPtr)((uint) fcontentBrowserPtr3, new IntPtr(1));
    }
    return (FContentBrowser*) 0L;
  }

  internal static unsafe FContentBrowser* FContentBrowser\u002E\u007Bctor\u007D(
    [In] FContentBrowser* obj0)
  {
    \u003CModule\u003E.FSerializableObject\u002E\u007Bctor\u007D((FSerializableObject*) obj0);
    // ISSUE: fault handler
    try
    {
      FContentBrowser* fcontentBrowserPtr1 = (FContentBrowser*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.FTickableObject\u002E\u007Bctor\u007D((FTickableObject*) fcontentBrowserPtr1);
      // ISSUE: fault handler
      try
      {
        FContentBrowser* fcontentBrowserPtr2 = (FContentBrowser*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) fcontentBrowserPtr2);
        // ISSUE: fault handler
        try
        {
          FContentBrowser* fcontentBrowserPtr3 = (FContentBrowser*) ((IntPtr) obj0 + 24L);
          *(long*) fcontentBrowserPtr3 = (long) &\u003CModule\u003E.\u003F\u003F_7FSourceControlEventListener\u0040\u00406B\u0040;
          *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
          *(long*) fcontentBrowserPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFTickableObject\u0040\u0040\u0040;
          *(long*) fcontentBrowserPtr2 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
          *(long*) fcontentBrowserPtr3 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFSourceControlEventListener\u0040\u0040\u0040;
          \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
          // ISSUE: fault handler
          try
          {
            *(int*) ((IntPtr) obj0 + 40L) = 0;
            FContentBrowser* fcontentBrowserPtr4 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr5 = fcontentBrowserPtr4;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 23, (IntPtr) fcontentBrowserPtr5);
            FContentBrowser* fcontentBrowserPtr6 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr7 = fcontentBrowserPtr6;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 24, (IntPtr) fcontentBrowserPtr7);
            FContentBrowser* fcontentBrowserPtr8 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent3 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr9 = fcontentBrowserPtr8;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent3, (ECallbackEventType) 60, (IntPtr) fcontentBrowserPtr9);
            FContentBrowser* fcontentBrowserPtr10 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent4 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr11 = fcontentBrowserPtr10;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent4, (ECallbackEventType) 36, (IntPtr) fcontentBrowserPtr11);
            FContentBrowser* fcontentBrowserPtr12 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent5 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr13 = fcontentBrowserPtr12;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent5, (ECallbackEventType) 2, (IntPtr) fcontentBrowserPtr13);
            FContentBrowser* fcontentBrowserPtr14 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent6 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr15 = fcontentBrowserPtr14;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent6, (ECallbackEventType) 61, (IntPtr) fcontentBrowserPtr15);
            FContentBrowser* fcontentBrowserPtr16 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent7 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr17 = fcontentBrowserPtr16;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent7, (ECallbackEventType) 65, (IntPtr) fcontentBrowserPtr17);
            FContentBrowser* fcontentBrowserPtr18 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent8 = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr19 = fcontentBrowserPtr18;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent8, (ECallbackEventType) 66, (IntPtr) fcontentBrowserPtr19);
            FContentBrowser* fcontentBrowserPtr20 = obj0;
            \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, &fcontentBrowserPtr20);
            \u003CModule\u003E.FContentBrowser\u002EMakeActive(obj0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32L));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FTickableObject\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FContentBrowser\u002E__vecDelDtor(
    [In] FContentBrowser* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FContentBrowser* fcontentBrowserPtr = (FContentBrowser*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 44UL, *(int*) fcontentBrowserPtr, (__FnPtr<void (void*)>) __methodptr(FContentBrowser\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fcontentBrowserPtr);
      return (void*) fcontentBrowserPtr;
    }
    \u003CModule\u003E.FContentBrowser\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FContentBrowser\u002E\u007Bdtor\u007D([In] FContentBrowser* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
    FContentBrowser* fcontentBrowserPtr1 = (FContentBrowser*) ((IntPtr) obj0 + 8L);
    *(long*) fcontentBrowserPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFTickableObject\u0040\u0040\u0040;
    FContentBrowser* fcontentBrowserPtr2 = (FContentBrowser*) ((IntPtr) obj0 + 16L);
    *(long*) fcontentBrowserPtr2 = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
    *(long*) ((IntPtr) obj0 + 24L) = (long) &\u003CModule\u003E.\u003F\u003F_7FContentBrowser\u0040\u00406BFSourceControlEventListener\u0040\u0040\u0040;
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          FContentBrowser* fcontentBrowserPtr3;
          // ISSUE: fault handler
          try
          {
            FContentBrowser* fcontentBrowserPtr4 = obj0;
            \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, &fcontentBrowserPtr4);
            FContentBrowser* fcontentBrowserPtr5 = fcontentBrowserPtr2;
            FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
            FContentBrowser* fcontentBrowserPtr6 = fcontentBrowserPtr5;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) fcontentBrowserPtr6);
            fcontentBrowserPtr3 = (FContentBrowser*) ((IntPtr) obj0 + 32L);
            MContentBrowserControl mcontentBrowserControl1 = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) fcontentBrowserPtr3);
            if (mcontentBrowserControl1 != null)
            {
              mcontentBrowserControl1.WriteRecentObjectsToConfig();
              mcontentBrowserControl1.Dispose();
              IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
              gcroot\u003CMContentBrowserControl\u0020\u005E\u003E mcontentBrowserControl2;
              // ISSUE: cast to a reference type
              // ISSUE: explicit reference operation
              ^(long&) ref mcontentBrowserControl2 = (long) num.ToPointer();
              // ISSUE: fault handler
              try
              {
                ((GCHandle) new IntPtr((void*) *(long*) fcontentBrowserPtr3)).Target = (object) \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040(&mcontentBrowserControl2);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &mcontentBrowserControl2);
              }
              \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&mcontentBrowserControl2);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 32L));
          }
          \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) fcontentBrowserPtr3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) fcontentBrowserPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FTickableObject\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.FTickableObject\u002E\u007Bdtor\u007D((FTickableObject*) fcontentBrowserPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FSerializableObject\u002E\u007Bdtor\u007D((FSerializableObject*) obj0);
  }

  internal static unsafe void FContentBrowser\u002EResize(
    [In] FContentBrowser* obj0,
    HWND__* hWndParent,
    int x,
    int y,
    int Width,
    int Height)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L)).Resize(hWndParent, x, y, Width, Height);
  }

  internal static unsafe void FContentBrowser\u002ESetFocus([In] FContentBrowser* obj0)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.SetFocus();
    \u003CModule\u003E.FContentBrowser\u002EMakeActive(obj0);
  }

  internal static unsafe TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* FContentBrowser\u002EGetSharedThumbnailClasses(
    [In] FContentBrowser* obj0)
  {
    return \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L)).GetSharedThumbnailClasses();
  }

  internal static unsafe TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* FContentBrowser\u002EGetBrowsableObjectTypeMap(
    [In] FContentBrowser* obj0)
  {
    return \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L)).GetBrowsableObjectTypeMap();
  }

  internal static unsafe void FContentBrowser\u002ESerialize([In] FContentBrowser* obj0, FArchive* Ar)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    if (mcontentBrowserControl == null)
      return;
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      mcontentBrowserControl.QuerySerializableObjects(&fdefaultAllocator);
      int num = 0;
      if (0 < \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
      {
        do
        {
          UObject* uobjectPtr = (UObject*) *(long*) \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
          FArchive* farchivePtr1 = Ar;
          ref UObject* local = ref uobjectPtr;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          FArchive* farchivePtr2 = __calli((__FnPtr<FArchive* (IntPtr, UObject**)>) *(long*) (*(long*) Ar + 48L))((UObject**) farchivePtr1, (IntPtr) ref local);
          ++num;
        }
        while (num < \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
  }

  internal static unsafe void FContentBrowser\u002ETick([In] FContentBrowser* obj0, float DeltaTime) => \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 24L))?.Tick();

  internal static unsafe void FContentBrowser\u002ESyncToObjects(
    [In] FContentBrowser* obj0,
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* InObjects)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.SyncToObjects(InObjects);
  }

  internal static unsafe void FContentBrowser\u002ESyncToPackages(
    [In] FContentBrowser* obj0,
    TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* InPackages)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.SyncToPackages(InPackages);
  }

  internal static unsafe void FContentBrowser\u002ECreateLocalCollection(
    [In] FContentBrowser* obj0,
    FString* InCollectionName)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    if (mcontentBrowserControl == null)
      return;
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    mcontentBrowserControl.CreateCollection(InCollectionName1, (EBrowserCollectionType) 2);
  }

  internal static unsafe void FContentBrowser\u002EDestroyLocalCollection(
    [In] FContentBrowser* obj0,
    FString* InCollectionName)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    if (mcontentBrowserControl == null)
      return;
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    mcontentBrowserControl.DestroyCollection(InCollectionName1, (EBrowserCollectionType) 2);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FContentBrowser\u002EAddAssetsToLocalCollection(
    [In] FContentBrowser* obj0,
    FString* InCollectionName,
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* AssetsToAdd)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L));
    bool flag = false;
    if (mcontentBrowserControl != null)
    {
      List<string> stringList = new List<string>();
      int num = 0;
      if (0 < \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(AssetsToAdd))
      {
        do
        {
          FString fstring;
          FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName((UObject*) *(long*) \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(AssetsToAdd, num), &fstring, (UObject*) 0L);
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(fullName), 0, \u003CModule\u003E.FString\u002ELen(fullName));
            stringList.Add(str);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
          ++num;
        }
        while (num < \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(AssetsToAdd));
      }
      string str1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
      flag = mcontentBrowserControl.AddAssetsToCollection((ICollection<string>) stringList, new Collection(str1, true), (EBrowserCollectionType) 2);
    }
    return flag;
  }

  internal static unsafe void FContentBrowser\u002ESelectCollection(
    [In] FContentBrowser* obj0,
    FString* InCollectionToSelect,
    EGADCollection.Type InCollectionType)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.SelectCollection(new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionToSelect), 0, \u003CModule\u003E.FString\u002ELen(InCollectionToSelect)), (EBrowserCollectionType) InCollectionType);
  }

  internal static unsafe void FContentBrowser\u002EGoToSearch([In] FContentBrowser* obj0) => \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.GoToSearch();

  internal static unsafe void FContentBrowser\u002ESend(
    [In] FContentBrowser* obj0,
    ECallbackEventType Event)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L));
    if (mcontentBrowserControl == null)
      return;
    switch (Event)
    {
      case (ECallbackEventType) 24:
        if (*(int*) ((IntPtr) obj0 + 24L) == 0)
          break;
        mcontentBrowserControl.LoadSelectedObjectsIfNeeded();
        break;
      case (ECallbackEventType) 60:
        mcontentBrowserControl.OnPendingGarbageCollection();
        break;
      case (ECallbackEventType) 61:
        mcontentBrowserControl.RequestAssetListUpdate(AssetListRefreshMode.UIOnly, (UObject*) 0L, 1U);
        mcontentBrowserControl.RequestPackageListUpdate(false, (UObject*) 0L);
        if (*(int*) ((IntPtr) obj0 + 24L) == 0)
          break;
        mcontentBrowserControl.SyncSelectedObjectsWithGlobalSelectionSet();
        break;
      case (ECallbackEventType) 65:
        mcontentBrowserControl.EnableWindow(false);
        break;
      case (ECallbackEventType) 66:
        mcontentBrowserControl.EnableWindow(true);
        break;
    }
  }

  internal static unsafe void FContentBrowser\u002ESend(
    [In] FContentBrowser* obj0,
    ECallbackEventType InType,
    uint InFlags)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L));
    if (mcontentBrowserControl == null || InType != (ECallbackEventType) 2 || ((int) InFlags & 1) == 0)
      return;
    mcontentBrowserControl.RequestAssetListUpdate(AssetListRefreshMode.UIOnly, (UObject*) 0L, 1U);
    mcontentBrowserControl.RequestPackageListUpdate(false, (UObject*) 0L);
    mcontentBrowserControl.RequestSCCStateUpdate();
  }

  internal static unsafe void FContentBrowser\u002ESend(
    [In] FContentBrowser* obj0,
    ECallbackEventType Event,
    UObject* InObject)
  {
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L));
    if (mcontentBrowserControl == null || Event != (ECallbackEventType) 36)
      return;
    mcontentBrowserControl.OnObjectModification(InObject, 1U, (AssetStatusUpdateFlags) 1);
  }

  internal static unsafe void FContentBrowser\u002ESend(
    [In] FContentBrowser* obj0,
    FCallbackEventParameters* Parms)
  {
    uint num1 = 0;
    if (*(int*) ((IntPtr) Parms + 8L) != 23)
      return;
    ulong num2 = (ulong) *(long*) Parms;
    if (num2 != 0UL)
    {
      long num3 = (IntPtr) obj0 - 16L != 0L ? (long) (ValueType) (IntPtr) obj0 : 0L;
      if ((long) num2 != num3)
        return;
    }
    MContentBrowserControl mcontentBrowserControl = \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L));
    if (mcontentBrowserControl == null || \u003CModule\u003E.GIsPlayInEditorWorld != 0U)
      return;
    if ((*(int*) ((IntPtr) Parms + 12L) & 32768) != 0)
    {
      TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
      \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
      // ISSUE: fault handler
      try
      {
        mcontentBrowserControl.SyncToObjects(&fdefaultAllocator);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
      }
      \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
    }
    if ((*(int*) ((IntPtr) Parms + 12L) & 262144) != 0)
      mcontentBrowserControl.ClearFilter();
    uint num4 = (uint) *(int*) ((IntPtr) Parms + 12L);
    if (((int) num4 & 17) != 0)
    {
      byte num3 = (byte) (~(int) (num4 >> 4) & 1);
      mcontentBrowserControl.RequestPackageListUpdate((bool) num3, (UObject*) *(long*) ((IntPtr) Parms + 44L));
    }
    uint num5 = (uint) *(int*) ((IntPtr) Parms + 12L);
    if (((int) num5 & 34) != 0)
    {
      byte num3 = (byte) (~(int) (num5 >> 5) & 1);
      mcontentBrowserControl.RequestCollectionListUpdate((bool) num3);
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0)
    {
      uint RefreshFlags = (uint) *(int*) ((IntPtr) Parms + 12L);
      if (((int) RefreshFlags & 196) != 0)
      {
        long num3 = *(long*) ((IntPtr) Parms + 44L);
        AssetListRefreshMode RefreshMode = num3 != 0L || ((int) RefreshFlags & 64) == 0 ? \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ERefreshModeFromRefreshFlags(RefreshFlags) : AssetListRefreshMode.Repopulate;
        mcontentBrowserControl.RequestAssetListUpdate(RefreshMode, (UObject*) num3, 1U);
      }
    }
    if ((*(int*) ((IntPtr) Parms + 12L) & 65536) != 0)
    {
      UPackage* PackageToRemove = \u003CModule\u003E.Cast\u003Cclass\u0020UPackage\u003E((UObject*) *(long*) ((IntPtr) Parms + 44L));
      if ((IntPtr) PackageToRemove != IntPtr.Zero)
        mcontentBrowserControl.RemoveFromPackageList(PackageToRemove);
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0 && (*(int*) ((IntPtr) Parms + 12L) & 524288) != 0)
    {
      TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* allowedClassList = \u003CModule\u003E.FGameAssetDatabase\u002EGetAllowedClassList();
      bool bInIsArchetype;
      if (\u003CModule\u003E.UObject\u002EHasAllFlags((UObject*) *(long*) ((IntPtr) Parms + 44L), 1024UL) != 0U)
      {
        long num3 = *(long*) ((IntPtr) Parms + 44L);
        long num6 = num3;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        if (__calli((__FnPtr<uint (IntPtr, UObject**)>) *(long*) (*(long*) num3 + 376L))((UObject**) num6, IntPtr.Zero) == 0U)
        {
          bInIsArchetype = true;
          goto label_26;
        }
      }
      bInIsArchetype = false;
label_26:
      FName fname;
      \u003CModule\u003E.UObject\u002EGetFName((UObject*) \u003CModule\u003E.UObject\u002EGetClass((UObject*) *(long*) ((IntPtr) Parms + 44L)), &fname);
      FString fstring1;
      int num7;
      if (bInIsArchetype || \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(allowedClassList, fname) != 0U)
      {
        FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName((UObject*) *(long*) ((IntPtr) Parms + 44L), &fstring1, (UObject*) 0L);
        // ISSUE: fault handler
        try
        {
          num1 = 1U;
          if (\u003CModule\u003E.FGameAssetDatabase\u002EIsAssetKnown(\u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA, fullName) == 0U)
          {
            num7 = 1;
            goto label_39;
          }
        }
        __fault
        {
          if (((int) num1 & 1) != 0)
          {
            num1 &= 4294967294U;
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
          }
        }
      }
      // ISSUE: fault handler
      try
      {
        num7 = 0;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
      }
label_39:
      bool flag;
      // ISSUE: fault handler
      try
      {
        flag = num7 != 0;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num1 &= 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
      }
      if (((int) num1 & 1) != 0)
      {
        uint num3 = num1 & 4294967294U;
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      }
      if (flag)
      {
        FString fstring2;
        FString* name = \u003CModule\u003E.UObject\u002EGetName((UObject*) \u003CModule\u003E.UObject\u002EGetOutermost((UObject*) *(long*) ((IntPtr) Parms + 44L)), &fstring2);
        string InOutermostPackageName;
        // ISSUE: fault handler
        try
        {
          InOutermostPackageName = \u003CModule\u003E.CLRTools\u002EToString(name);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        FString fstring3;
        FString* InFString = \u003CModule\u003E.FName\u002EToString(&fname, &fstring3);
        string InObjectTypeName;
        // ISSUE: fault handler
        try
        {
          InObjectTypeName = \u003CModule\u003E.CLRTools\u002EToString(InFString);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName((UObject*) *(long*) ((IntPtr) Parms + 44L), &fstring4, (UObject*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring5;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring5, \u003CModule\u003E.FString\u002E\u002A(fullName));
          // ISSUE: fault handler
          try
          {
            string InAssetFullName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring5), 0, \u003CModule\u003E.FString\u002ELen(&fstring5));
            \u003CModule\u003E.FGameAssetDatabase\u002ESetDefaultTagsForAsset(\u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA, InAssetFullName, InObjectTypeName, InOutermostPackageName, bInIsArchetype, true);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
      }
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0 && (*(int*) ((IntPtr) Parms + 12L) & 7168) != 0)
    {
      mcontentBrowserControl.RequestPackageListUpdate(false, (UObject*) *(long*) ((IntPtr) Parms + 44L));
      mcontentBrowserControl.RequestAssetListUpdate(AssetListRefreshMode.QuickRepopulate, (UObject*) *(long*) ((IntPtr) Parms + 44L), 0U);
      long num3 = *(long*) ((IntPtr) Parms + 44L);
      if (num3 != 0L)
      {
        uint num6 = (uint) *(int*) ((IntPtr) Parms + 12L);
        if (((int) num6 & 5120) != 0)
        {
          if (((int) num6 & 131072) == 0)
            mcontentBrowserControl.RequestSyncAssetView((UObject*) num3);
          TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
          \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
          // ISSUE: fault handler
          try
          {
            if ((IntPtr) \u003CModule\u003E.Cast\u003Cclass\u0020UPackage\u003E((UObject*) *(long*) ((IntPtr) Parms + 44L)) == IntPtr.Zero)
            {
              TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* allowedClassList = \u003CModule\u003E.FGameAssetDatabase\u002EGetAllowedClassList();
              bool bInIsArchetype;
              if (\u003CModule\u003E.UObject\u002EHasAllFlags((UObject*) *(long*) ((IntPtr) Parms + 44L), 1024UL) != 0U)
              {
                long num7 = *(long*) ((IntPtr) Parms + 44L);
                long num8 = num7;
                // ISSUE: cast to a function pointer type
                // ISSUE: function pointer call
                if (__calli((__FnPtr<uint (IntPtr, UObject**)>) *(long*) (*(long*) num7 + 376L))((UObject**) num8, IntPtr.Zero) == 0U)
                {
                  bInIsArchetype = true;
                  goto label_71;
                }
              }
              bInIsArchetype = false;
label_71:
              FName fname;
              \u003CModule\u003E.UObject\u002EGetFName((UObject*) \u003CModule\u003E.UObject\u002EGetClass((UObject*) *(long*) ((IntPtr) Parms + 44L)), &fname);
              if (bInIsArchetype || \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(allowedClassList, fname) != 0U)
              {
                FString fstring1;
                FString* name = \u003CModule\u003E.UObject\u002EGetName((UObject*) \u003CModule\u003E.UObject\u002EGetOutermost((UObject*) *(long*) ((IntPtr) Parms + 44L)), &fstring1);
                string InOutermostPackageName;
                // ISSUE: fault handler
                try
                {
                  InOutermostPackageName = \u003CModule\u003E.CLRTools\u002EToString(name);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
                FString fstring2;
                FString* InFString = \u003CModule\u003E.FName\u002EToString(&fname, &fstring2);
                string InObjectTypeName;
                // ISSUE: fault handler
                try
                {
                  InObjectTypeName = \u003CModule\u003E.CLRTools\u002EToString(InFString);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                FString fstring3;
                FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName((UObject*) *(long*) ((IntPtr) Parms + 44L), &fstring3, (UObject*) 0L);
                // ISSUE: fault handler
                try
                {
                  FString fstring4;
                  \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, \u003CModule\u003E.FString\u002E\u002A(fullName));
                  // ISSUE: fault handler
                  try
                  {
                    string InAssetFullName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4));
                    \u003CModule\u003E.FGameAssetDatabase\u002ESetDefaultTagsForAsset(\u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA, InAssetFullName, InObjectTypeName, InOutermostPackageName, bInIsArchetype, true);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
              }
            }
            if ((*(int*) ((IntPtr) Parms + 12L) & 4096) != 0)
            {
              FName fname;
              \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A((FString*) *(long*) ((IntPtr) Parms + 20L)), (EFindName) 1, 1U);
              \u003CModule\u003E.FGameAssetDatabase\u002ERemoveAssetTagMappings(\u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA, &fname);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
          }
          \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
        }
        else if (((int) num6 & 2048) != 0 && (IntPtr) \u003CModule\u003E.Cast\u003Cclass\u0020UPackage\u003E((UObject*) num3) == IntPtr.Zero)
        {
          FString fstring;
          FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName((UObject*) *(long*) ((IntPtr) Parms + 44L), &fstring, (UObject*) 0L);
          FName fname;
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(fullName), (EFindName) 1, 1U);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
          \u003CModule\u003E.FGameAssetDatabase\u002ERemoveAssetTagMappings(\u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA, &fname);
        }
      }
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0 && (*(int*) ((IntPtr) Parms + 12L) & 16384) != 0)
    {
      TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
      \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(&fdefaultAllocator, (UObject**) ((IntPtr) Parms + 44L));
        mcontentBrowserControl.OpenObjectEditorFor(&fdefaultAllocator);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
      }
      \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0)
    {
      uint num3 = (uint) *(int*) ((IntPtr) Parms + 12L);
      if (((int) num3 & 512) != 0 && ((int) num3 & 131072) == 0)
        mcontentBrowserControl.RequestSyncAssetView((UObject*) *(long*) ((IntPtr) Parms + 44L));
    }
    if (*(int*) ((IntPtr) obj0 + 24L) != 0 && (*(int*) ((IntPtr) Parms + 12L) & 256) != 0)
      mcontentBrowserControl.RequestSCCStateUpdate();
    if (*(int*) ((IntPtr) obj0 + 24L) == 0 || (*(int*) ((IntPtr) Parms + 12L) & 8192) == 0)
      return;
    if ((IntPtr) mcontentBrowserControl.GetParentBrowserWindow() != IntPtr.Zero)
      \u003CModule\u003E.UBrowserManager\u002EShowWindow(\u003CModule\u003E.UUnrealEdEngine\u002EGetBrowserManager(\u003CModule\u003E.GUnrealEd), \u003CModule\u003E.WxBrowser\u002EGetDockID((WxBrowser*) mcontentBrowserControl.GetParentBrowserWindow()), 1U);
    mcontentBrowserControl.SetFocus();
  }

  internal static unsafe void FContentBrowser\u002ESourceControlCallback(
    [In] FContentBrowser* obj0,
    FSourceControlCommand* InCommand)
  {
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).SourceControlResultsProcess(InCommand);
  }

  internal static unsafe void FContentBrowser\u002EMakeActive([In] FContentBrowser* obj0)
  {
    int num = 0;
    if (0 < \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A))
    {
      do
      {
        FContentBrowser* fcontentBrowserPtr = (FContentBrowser*) *(long*) \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, num);
        if (fcontentBrowserPtr != obj0)
        {
          \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) fcontentBrowserPtr + 32L))?.OnYieldSelectionAuthority();
          *(int*) ((IntPtr) fcontentBrowserPtr + 40L) = 0;
        }
        ++num;
      }
      while (num < \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A));
    }
    \u003CModule\u003E.gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040((gcroot\u003CMContentBrowserControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 32L))?.OnBecameSelectionAuthority();
    *(int*) ((IntPtr) obj0 + 40L) = 1;
  }

  internal static unsafe void FContentBrowser\u002EMakeAppropriateContentBrowserActive(
    [In] FContentBrowser* obj0)
  {
    \u003CModule\u003E.FContentBrowser\u002EMakeActive((FContentBrowser*) *(long*) \u003CModule\u003E.TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&\u003CModule\u003E.\u003FContentBrowserInstances\u0040FContentBrowser\u0040\u00401V\u003F\u0024TArray\u0040PEAVFContentBrowser\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, 0));
  }

  internal static unsafe void WxFileDialog\u002E\u007Bdtor\u007D([In] WxFileDialog* obj0) => \u003CModule\u003E.wxFileDialog\u002E\u007Bdtor\u007D((wxFileDialog*) obj0);

  internal static unsafe string ValidateBranchName(string InBranchName)
  {
    int length = InBranchName.IndexOf("/");
    if (length == 0)
    {
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("Encountered entry with branch name {0}. I don't know how to fix it!", (object) InBranchName);
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr);
        return InBranchName;
      }
    }
    else
    {
      if (length <= 0)
        return InBranchName;
      string str = InBranchName.Substring(0, length);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("Encountered entry with branch name {0}. Fixed it; new name is {1}", (object) InBranchName, (object) str);
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr);
        return str;
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002EInit(
    FGameAssetDatabaseStartupConfig* InConfig,
    FString* OutInitErrorMessageText)
  {
    \u003CModule\u003E.FString\u002E\u003D(OutInitErrorMessageText, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D110);
    FGameAssetDatabase* fgameAssetDatabasePtr1 = (FGameAssetDatabase*) \u003CModule\u003E.@new(272UL);
    FGameAssetDatabase* fgameAssetDatabasePtr2;
    // ISSUE: fault handler
    try
    {
      fgameAssetDatabasePtr2 = (IntPtr) fgameAssetDatabasePtr1 == IntPtr.Zero ? (FGameAssetDatabase*) 0L : \u003CModule\u003E.FGameAssetDatabase\u002E\u007Bctor\u007D(fgameAssetDatabasePtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) fgameAssetDatabasePtr1);
    }
    \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA = fgameAssetDatabasePtr2;
    bool flag = \u003CModule\u003E.FGameAssetDatabase\u002EUpdateDatabase(fgameAssetDatabasePtr2, InConfig);
    \u003CModule\u003E.FString\u002E\u003D(OutInitErrorMessageText, (FString*) ((IntPtr) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA + 8L));
    if (flag)
      return;
    if ((IntPtr) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
    {
      FGameAssetDatabase* database0PeaV1Ea = \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA)((uint) database0PeaV1Ea, new IntPtr(1));
    }
    \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA = (FGameAssetDatabase*) 0L;
  }

  internal static unsafe void FGameAssetDatabase\u002EDestroy()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
      return;
    FGameAssetDatabase* database0PeaV1Ea = \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA)((uint) database0PeaV1Ea, new IntPtr(1));
    \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA = (FGameAssetDatabase*) 0L;
  }

  internal static unsafe void FGameAssetDatabase\u002ECheckJournalAlarm()
  {
    uint num1 = 1;
    uint num2 = 0;
    uint num3 = \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D138, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D137, &num2, (char*) &\u003CModule\u003E.GEditorUserSettingsIni) != 0U ? num2 : num1;
    if (\u003CModule\u003E.ParseParam(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D139, 0U) == 0U && num3 == 0U)
      return;
    uint num4 = 1;
    int num5 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D112, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D111, &num4, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    if (num4 != 0U)
    {
      int num6 = (int) \u003CModule\u003E.FGameAssetDatabase\u002EJournalUpdate();
      \u003CModule\u003E.FConfigCacheIni\u002ESetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D114, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D113, 0U, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    }
    else
    {
      uint num6 = 1;
      int num7 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D116, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D115, &num6, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      if (num6 == 0U || !(DateTime.Now > \u003CModule\u003E.FGameAssetDatabase\u002EGetJournalAlarmTime()))
        return;
      \u003CModule\u003E.FGameAssetDatabase\u002EShowJournalAlarmDialog();
    }
  }

  internal static unsafe FGameAssetDatabase* FGameAssetDatabase\u002E\u007Bctor\u007D(
    [In] FGameAssetDatabase* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FGameAssetDatabase\u0040\u00406B\u0040;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D((FString*) ((IntPtr) obj0 + 8L));
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bctor\u007D((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L));
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bctor\u007D((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L));
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L));
          // ISSUE: fault handler
          try
          {
            FGameAssetDatabase* fgameAssetDatabasePtr1 = (FGameAssetDatabase*) ((IntPtr) obj0 + 240L);
            *(long*) fgameAssetDatabasePtr1 = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
            // ISSUE: fault handler
            try
            {
              *(int*) ((IntPtr) obj0 + 248L) = 0;
              FGameAssetDatabase* fgameAssetDatabasePtr2 = (FGameAssetDatabase*) ((IntPtr) obj0 + 252L);
              *(long*) fgameAssetDatabasePtr2 = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
              // ISSUE: fault handler
              try
              {
                FGameAssetDatabase* fgameAssetDatabasePtr3 = (FGameAssetDatabase*) ((IntPtr) obj0 + 260L);
                *(int*) fgameAssetDatabasePtr3 = 0;
                FGameAssetDatabase* fgameAssetDatabasePtr4 = (FGameAssetDatabase*) ((IntPtr) obj0 + 264L);
                *(long*) fgameAssetDatabasePtr4 = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.FSourceControl\u002EInit();
                  MGameAssetJournalClient _new_ptr1 = new MGameAssetJournalClient();
                  \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) fgameAssetDatabasePtr2, _new_ptr1);
                  MGameAssetJournalFile _new_ptr2 = new MGameAssetJournalFile();
                  \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) fgameAssetDatabasePtr4, _new_ptr2);
                  uint num1 = 1;
                  uint num2 = 0;
                  uint num3 = \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D138, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D137, &num2, (char*) &\u003CModule\u003E.GEditorUserSettingsIni) != 0U ? num2 : num1;
                  uint num4 = \u003CModule\u003E.ParseParam(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D139, 0U) != 0U ? 1U : num3;
                  *(int*) fgameAssetDatabasePtr3 = (int) num4;
                  Dictionary<string, int> _new_ptr3 = new Dictionary<string, int>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
                  \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr1, _new_ptr3);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 264L));
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 252L));
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 240L));
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 168L));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 96L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
    }
    return obj0;
  }

  internal static unsafe void* FGameAssetDatabase\u002E__vecDelDtor(
    [In] FGameAssetDatabase* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FGameAssetDatabase* fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 272UL, *(int*) fgameAssetDatabasePtr, (__FnPtr<void (void*)>) __methodptr(FGameAssetDatabase\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fgameAssetDatabasePtr);
      return (void*) fgameAssetDatabasePtr;
    }
    \u003CModule\u003E.FGameAssetDatabase\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bdtor\u007D(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TMap\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TSortableMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSortableMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void FGameAssetDatabase\u002E\u007Bdtor\u007D([In] FGameAssetDatabase* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FGameAssetDatabase\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              // ISSUE: fault handler
              try
              {
                auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* assetJournalFilePtr = (auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L);
                // ISSUE: fault handler
                try
                {
                  if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) assetJournalFilePtr) != null ? 1 : 0) != 0)
                    \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) assetJournalFilePtr)?.Dispose();
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) assetJournalFilePtr);
                }
                \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) assetJournalFilePtr);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 252L));
              }
              auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* assetJournalClientPtr = (auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L);
              // ISSUE: fault handler
              try
              {
                if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) assetJournalClientPtr) != null ? 1 : 0) != 0)
                  \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) assetJournalClientPtr)?.Dispose();
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) assetJournalClientPtr);
              }
              \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) assetJournalClientPtr);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 240L));
            }
            \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D((auto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) ((IntPtr) obj0 + 240L));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 168L));
          }
          \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 96L));
        }
        \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 96L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
      }
      \u003CModule\u003E.TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 24L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 8L));
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EIsReadOnly([In] FGameAssetDatabase* obj0) => *(int*) ((IntPtr) obj0 + 248L) == 0 && *(int*) ((IntPtr) obj0 + 260L) == 0 && \u003CModule\u003E.GIsUnitTesting == 0U;

  internal static unsafe void FGameAssetDatabase\u002EQueryAllTags(
    [In] FGameAssetDatabase* obj0,
    out List<string> OutTags,
    ETagQueryOptions.Type InOptions)
  {
    OutTags = new List<string>();
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator;
    \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator, (TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), 0);
    if (!\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator))
      return;
    do
    {
      string Tag = \u003CModule\u003E.CLRTools\u002EFNameToString(\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
      if (InOptions != (ETagQueryOptions.Type) 4)
      {
        ESystemTagType systemTagType = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(Tag);
        bool flag = systemTagType != ESystemTagType.Invalid;
        switch (InOptions)
        {
          case (ETagQueryOptions.Type) 1:
            if (!flag)
              goto label_9;
            else
              break;
          case (ETagQueryOptions.Type) 2:
            if (!flag)
              break;
            goto label_9;
          case (ETagQueryOptions.Type) 3:
            if (systemTagType == ESystemTagType.PrivateCollection || systemTagType == ESystemTagType.SharedCollection || systemTagType == ESystemTagType.LocalCollection)
              break;
            goto label_9;
        }
      }
      OutTags.Add(Tag);
label_9:
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
    }
    while (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
  }

  internal static unsafe uint FGameAssetDatabase\u002EIsAssetKnown(
    [In] FGameAssetDatabase* obj0,
    FString* InAssetFullName)
  {
    FName fname;
    return \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(InAssetFullName), (EFindName) 1, 1U));
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EAddTagToAssets(
    [In] FGameAssetDatabase* obj0,
    ICollection<string> InAssetFullNames,
    string InTag)
  {
    uint num1 = 0;
    ESystemTagType systemTagType = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(InTag);
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) != 0)
    {
      string InCLRString = \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_CannotWriteToReadOnlyDatabase", (string) null, (string) null, (string) null);
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InCLRString);
      FGameAssetDatabase* fgameAssetDatabasePtr;
      // ISSUE: fault handler
      try
      {
        fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 8L);
        \u003CModule\u003E.FString\u002E\u003D((FString*) fgameAssetDatabasePtr, fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("FGameAssetDatabase::AddTagToAsset: {0}", (object) new string(\u003CModule\u003E.FString\u002E\u002A((FString*) fgameAssetDatabasePtr), 0, \u003CModule\u003E.FString\u002ELen((FString*) fgameAssetDatabasePtr)));
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
    }
    else
    {
      List<MGameAssetJournalEntry> JournalEntries = new List<MGameAssetJournalEntry>();
      foreach (string inAssetFullName in (IEnumerable<string>) InAssetFullNames)
      {
        if (\u003CModule\u003E.CLRTools\u002EIsAssetValidForTagging(inAssetFullName))
        {
          bool flag1 = systemTagType == ESystemTagType.Invalid || systemTagType == ESystemTagType.PrivateCollection || systemTagType == ESystemTagType.SharedCollection;
          FString fstring1;
          int num2;
          if (flag1)
          {
            FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, inAssetFullName);
            // ISSUE: fault handler
            try
            {
              num1 |= 1U;
              if (\u003CModule\u003E.FGameAssetDatabase\u002EIsAssetKnown(obj0, fstring2) == 0U)
              {
                num2 = 0;
                goto label_22;
              }
            }
            __fault
            {
              if (((int) num1 & 1) != 0)
              {
                num1 &= 4294967294U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num2 = 1;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
            }
          }
label_22:
          bool flag2;
          // ISSUE: fault handler
          try
          {
            flag2 = num2 != 0;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
            }
          }
          if (((int) num1 & 1) != 0)
          {
            num1 &= 4294967294U;
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          }
          if (flag2)
          {
            MGameAssetJournalEntry assetEntry = MGameAssetJournalEntry.MakeAddTagToAssetEntry(inAssetFullName, InTag);
            JournalEntries.Add(assetEntry);
          }
          else if (flag1)
            \u003CModule\u003E.CLRTools\u002ELogWarningMessage(string.Format("Asset '{0}' is not known to the Game Asset Database and will not be tagged with '{1}'", (object) inAssetFullName, (object) InTag));
        }
      }
      if (JournalEntries.Count > 0)
      {
        if ((*(int*) ((IntPtr) obj0 + 248L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).SendJournalEntries(JournalEntries)) && (*(int*) ((IntPtr) obj0 + 260L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L)).SendJournalEntries(JournalEntries)))
          return false;
        List<MGameAssetJournalEntry>.Enumerator enumerator = JournalEntries.GetEnumerator();
        if (enumerator.MoveNext())
        {
          do
          {
            MGameAssetJournalEntry current = enumerator.Current;
            \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, current.AssetFullName, InTag, false);
          }
          while (enumerator.MoveNext());
        }
      }
    }
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ERemoveTagFromAssets(
    [In] FGameAssetDatabase* obj0,
    ICollection<string> InAssetFullName,
    string InTag)
  {
    uint num1 = 0;
    ESystemTagType systemTagType = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(InTag);
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) != 0)
    {
      string InCLRString = \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_CannotWriteToReadOnlyDatabase", (string) null, (string) null, (string) null);
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InCLRString);
      FGameAssetDatabase* fgameAssetDatabasePtr;
      // ISSUE: fault handler
      try
      {
        fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 8L);
        \u003CModule\u003E.FString\u002E\u003D((FString*) fgameAssetDatabasePtr, fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("FGameAssetDatabase::AddTagToAsset: {0}", (object) new string(\u003CModule\u003E.FString\u002E\u002A((FString*) fgameAssetDatabasePtr), 0, \u003CModule\u003E.FString\u002ELen((FString*) fgameAssetDatabasePtr)));
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
        return false;
      }
    }
    else
    {
      List<MGameAssetJournalEntry> JournalEntries = new List<MGameAssetJournalEntry>();
      foreach (string str in (IEnumerable<string>) InAssetFullName)
      {
        if (\u003CModule\u003E.CLRTools\u002EIsAssetValidForTagging(str))
        {
          FString fstring1;
          int num2;
          if (systemTagType == ESystemTagType.Invalid || systemTagType == ESystemTagType.PrivateCollection || systemTagType == ESystemTagType.SharedCollection)
          {
            FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, str);
            // ISSUE: fault handler
            try
            {
              num1 |= 1U;
              if (\u003CModule\u003E.FGameAssetDatabase\u002EIsAssetKnown(obj0, fstring2) == 0U)
              {
                num2 = 0;
                goto label_22;
              }
            }
            __fault
            {
              if (((int) num1 & 1) != 0)
              {
                num1 &= 4294967294U;
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
              }
            }
          }
          // ISSUE: fault handler
          try
          {
            num2 = 1;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
            }
          }
label_22:
          bool flag;
          // ISSUE: fault handler
          try
          {
            flag = num2 != 0;
          }
          __fault
          {
            if (((int) num1 & 1) != 0)
            {
              num1 &= 4294967294U;
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
            }
          }
          if (((int) num1 & 1) != 0)
          {
            num1 &= 4294967294U;
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          }
          if (flag)
          {
            MGameAssetJournalEntry assetJournalEntry = MGameAssetJournalEntry.MakeRemoveTagFromAssetEntry(str, InTag);
            JournalEntries.Add(assetJournalEntry);
          }
        }
      }
      if (JournalEntries.Count > 0)
      {
        if ((*(int*) ((IntPtr) obj0 + 248L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).SendJournalEntries(JournalEntries)) && (*(int*) ((IntPtr) obj0 + 260L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L)).SendJournalEntries(JournalEntries)))
          return false;
        foreach (string InAssetFullName1 in (IEnumerable<string>) InAssetFullName)
          \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, InAssetFullName1, InTag);
      }
      return true;
    }
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FFoundTags\u0040\u003F1\u003F\u003FQueryTagsForAsset\u0040FGameAssetDatabase\u0040\u0040QEBAXVFName\u0040\u0040W4Type\u0040ETagQueryOptions\u0040\u0040AEAV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z\u0040YAXXZ() => \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FFoundTags\u0040\u003F1\u003F\u003FQueryTagsForAsset\u0040FGameAssetDatabase\u0040\u0040QEBAXVFName\u0040\u0040W4Type\u0040ETagQueryOptions\u0040\u0040AEAV\u003F\u0024TArray\u0040VFString\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040\u0040Z\u00404V\u003F\u0024TArray\u0040VFName\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A);

  internal static unsafe uint FGameAssetDatabase\u002ECreateTag(
    [In] FGameAssetDatabase* obj0,
    FString* InTag)
  {
    string InTag1 = new string(\u003CModule\u003E.FString\u002E\u002A(InTag), 0, \u003CModule\u003E.FString\u002ELen(InTag));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002ECreateTag(obj0, InTag1);
  }

  internal static unsafe uint FGameAssetDatabase\u002EDestroyTag(
    [In] FGameAssetDatabase* obj0,
    FString* InTag)
  {
    string InTag1 = new string(\u003CModule\u003E.FString\u002E\u002A(InTag), 0, \u003CModule\u003E.FString\u002ELen(InTag));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002EDestroyTag(obj0, InTag1);
  }

  internal static unsafe uint FGameAssetDatabase\u002ERemoveTagFromAssets(
    [In] FGameAssetDatabase* obj0,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InAssetFullNames,
    FString* InTag)
  {
    string InTag1 = new string(\u003CModule\u003E.FString\u002E\u002A(InTag), 0, \u003CModule\u003E.FString\u002ELen(InTag));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagFromAssets(obj0, (ICollection<string>) \u003CModule\u003E.CLRTools\u002EToStringArray(InAssetFullNames), InTag1);
  }

  internal static unsafe uint FGameAssetDatabase\u002EAddTagToAssets(
    [In] FGameAssetDatabase* obj0,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InAssetFullNames,
    FString* InTag)
  {
    string InTag1 = new string(\u003CModule\u003E.FString\u002E\u002A(InTag), 0, \u003CModule\u003E.FString\u002ELen(InTag));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, (ICollection<string>) \u003CModule\u003E.CLRTools\u002EToStringArray(InAssetFullNames), InTag1);
  }

  internal static unsafe void FGameAssetDatabase\u002EQueryTagsForAsset(
    [In] FGameAssetDatabase* obj0,
    string InAssetFullName,
    ETagQueryOptions.Type InOptions,
    out List<string> OutTags)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InAssetFullName;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      FName InAssetFullNameFName;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&InAssetFullNameFName, (char*) numPtr, (EFindName) 1, 1U);
      \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullNameFName, InOptions, out OutTags);
    }
  }

  internal static unsafe void FGameAssetDatabase\u002EQueryTagsForAsset(
    [In] FGameAssetDatabase* obj0,
    FName InAssetFullNameFName,
    ETagQueryOptions.Type InOptions,
    out List<string> OutTags)
  {
    OutTags = new List<string>();
    TArray\u003CFName\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), InAssetFullNameFName, &fdefaultAllocator);
      int num = 0;
      if (0 < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
      {
        do
        {
          FName* fnamePtr = \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
          FString fstring;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring);
          string Tag;
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FName\u002EToString(fnamePtr, &fstring);
            Tag = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring), 0, \u003CModule\u003E.FString\u002ELen(&fstring));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
          if (InOptions != (ETagQueryOptions.Type) 4)
          {
            ESystemTagType systemTagType = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(Tag);
            bool flag = systemTagType != ESystemTagType.Invalid;
            switch (InOptions)
            {
              case (ETagQueryOptions.Type) 1:
                if (!flag)
                  goto label_11;
                else
                  break;
              case (ETagQueryOptions.Type) 2:
                if (!flag)
                  break;
                goto label_11;
              case (ETagQueryOptions.Type) 3:
                if (systemTagType == ESystemTagType.PrivateCollection || systemTagType == ESystemTagType.SharedCollection)
                  break;
                goto label_11;
            }
          }
          OutTags.Add(Tag);
label_11:
          ++num;
        }
        while (num < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
  }

  internal static unsafe void FGameAssetDatabase\u002EQueryAssetsWithTag(
    [In] FGameAssetDatabase* obj0,
    string InTag,
    out List<string> OutAssetFullNames)
  {
    OutAssetFullNames = new List<string>();
    TArray\u003CFName\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InTag);
      // ISSUE: fault handler
      try
      {
        FName fname;
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L), *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(fstring2), (EFindName) 1, 1U), &fdefaultAllocator);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      int num = 0;
      if (0 < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
      {
        do
        {
          FString fstring3;
          FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num), &fstring3);
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
            OutAssetFullNames.Add(str);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
          ++num;
        }
        while (num < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ECreateTag(
    [In] FGameAssetDatabase* obj0,
    string InTag)
  {
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) != 0)
    {
      string InCLRString = \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_CannotWriteToReadOnlyDatabase", (string) null, (string) null, (string) null);
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InCLRString);
      FGameAssetDatabase* fgameAssetDatabasePtr;
      // ISSUE: fault handler
      try
      {
        fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 8L);
        \u003CModule\u003E.FString\u002E\u003D((FString*) fgameAssetDatabasePtr, fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("FGameAssetDatabase::CreateTag: {0}", (object) new string(\u003CModule\u003E.FString\u002E\u002A((FString*) fgameAssetDatabasePtr), 0, \u003CModule\u003E.FString\u002ELen((FString*) fgameAssetDatabasePtr)));
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
        return false;
      }
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) InTag;
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        FName fname;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
        if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), fname) == 0U)
        {
          MGameAssetJournalEntry JournalEntry = new MGameAssetJournalEntry();
          JournalEntry.Type = EJournalEntryType.CreateTag;
          JournalEntry.Tag = InTag;
          if ((*(int*) ((IntPtr) obj0 + 248L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).SendJournalEntry(JournalEntry)) && (*(int*) ((IntPtr) obj0 + 260L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L)).SendJournalEntry(JournalEntry)))
            return false;
          \u003CModule\u003E.FGameAssetDatabase\u002ELocalCreateTag(obj0, InTag);
        }
        return true;
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EDestroyTag(
    [In] FGameAssetDatabase* obj0,
    string InTag)
  {
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) != 0)
    {
      string InCLRString = \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_CannotWriteToReadOnlyDatabase", (string) null, (string) null, (string) null);
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InCLRString);
      FGameAssetDatabase* fgameAssetDatabasePtr;
      // ISSUE: fault handler
      try
      {
        fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 8L);
        \u003CModule\u003E.FString\u002E\u003D((FString*) fgameAssetDatabasePtr, fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) string.Format("FGameAssetDatabase::DestroyTag: {0}", (object) new string(\u003CModule\u003E.FString\u002E\u002A((FString*) fgameAssetDatabasePtr), 0, \u003CModule\u003E.FString\u002ELen((FString*) fgameAssetDatabasePtr)));
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
        return false;
      }
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) InTag;
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        FName fname;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
        if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), fname) != 0U)
        {
          MGameAssetJournalEntry JournalEntry = new MGameAssetJournalEntry();
          JournalEntry.Type = EJournalEntryType.DestroyTag;
          JournalEntry.Tag = InTag;
          if ((*(int*) ((IntPtr) obj0 + 248L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).SendJournalEntry(JournalEntry)) && (*(int*) ((IntPtr) obj0 + 260L) == 0 || !\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L)).SendJournalEntry(JournalEntry)))
            return false;
          \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, InTag);
        }
        return true;
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ECopyTag(
    [In] FGameAssetDatabase* obj0,
    string InCurrentTagName,
    string InNewTagName,
    [MarshalAs(UnmanagedType.U1)] bool bInMove)
  {
    List<string> OutAssetFullNames = (List<string>) null;
    if (InCurrentTagName.Equals(InNewTagName, StringComparison.OrdinalIgnoreCase))
      throw new SystemException("Incoming tag names must not be the same!");
    \u003CModule\u003E.FGameAssetDatabase\u002EQueryAssetsWithTag(obj0, InCurrentTagName, out OutAssetFullNames);
    return \u003CModule\u003E.FGameAssetDatabase\u002ECreateTag(obj0, InNewTagName) && (OutAssetFullNames.Count <= 0 || \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, (ICollection<string>) OutAssetFullNames, InNewTagName)) && (!bInMove || \u003CModule\u003E.FGameAssetDatabase\u002EDestroyTag(obj0, InCurrentTagName));
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ECreateCollection(
    [In] FGameAssetDatabase* obj0,
    string InCollectionName,
    EGADCollection.Type InType)
  {
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    bool flag;
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) == 0 && InSystemTagType != ESystemTagType.LocalCollection)
    {
      flag = \u003CModule\u003E.FGameAssetDatabase\u002ECreateTag(obj0, \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, InCollectionName));
    }
    else
    {
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) ('['.ToString() + GADDefs.SystemTagTypeNames[5] + (object) ']' + InCollectionName);
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        FName fname;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
        FSetElementId fsetElementId;
        \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), &fsetElementId, fname, (uint*) 0L);
        flag = true;
      }
    }
    return flag;
  }

  internal static unsafe uint FGameAssetDatabase\u002ECreateCollection(
    [In] FGameAssetDatabase* obj0,
    FString* InCollectionName,
    EGADCollection.Type InType)
  {
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002ECreateCollection(obj0, InCollectionName1, InType);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EDestroyCollection(
    [In] FGameAssetDatabase* obj0,
    string InCollectionName,
    EGADCollection.Type InType)
  {
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    bool flag;
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) == 0 && InSystemTagType != ESystemTagType.LocalCollection)
    {
      flag = \u003CModule\u003E.FGameAssetDatabase\u002EDestroyTag(obj0, \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, InCollectionName));
    }
    else
    {
      \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, '['.ToString() + GADDefs.SystemTagTypeNames[5] + (object) ']' + InCollectionName);
      flag = true;
    }
    return flag;
  }

  internal static unsafe uint FGameAssetDatabase\u002EDestroyCollection(
    [In] FGameAssetDatabase* obj0,
    FString* InCollectionName,
    EGADCollection.Type InType)
  {
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002EDestroyCollection(obj0, InCollectionName1, InType);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ECopyCollection(
    [In] FGameAssetDatabase* obj0,
    string InCurrentCollectionName,
    EGADCollection.Type InCurrentType,
    string InNewCollectionName,
    EGADCollection.Type InNewType,
    [MarshalAs(UnmanagedType.U1)] bool bInMove)
  {
    List<string> OutAssetFullNames = (List<string>) null;
    if (InCurrentType == InNewType && InCurrentCollectionName.Equals(InNewCollectionName, StringComparison.OrdinalIgnoreCase))
      throw new SystemException("Incoming collection names must not be the same!");
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InCurrentType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    string InTag = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, InCurrentCollectionName);
    \u003CModule\u003E.FGameAssetDatabase\u002EQueryAssetsWithTag(obj0, InTag, out OutAssetFullNames);
    return \u003CModule\u003E.FGameAssetDatabase\u002ECreateCollection(obj0, InNewCollectionName, InNewType) && (OutAssetFullNames.Count <= 0 || \u003CModule\u003E.FGameAssetDatabase\u002EAddAssetsToCollection(obj0, InNewCollectionName, InNewType, (ICollection<string>) OutAssetFullNames)) && (!bInMove || \u003CModule\u003E.FGameAssetDatabase\u002EDestroyCollection(obj0, InCurrentCollectionName, InCurrentType));
  }

  internal static unsafe void FGameAssetDatabase\u002ELocalCreateTag(
    [In] FGameAssetDatabase* obj0,
    string InTag)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InTag;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      FName fname;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
      FSetElementId fsetElementId;
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), &fsetElementId, fname, (uint*) 0L);
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ELocalDestroyTag(
    [In] FGameAssetDatabase* obj0,
    string InTag)
  {
    List<string> OutAssetFullNames = new List<string>();
    \u003CModule\u003E.FGameAssetDatabase\u002EQueryAssetsWithTag(obj0, InTag, out OutAssetFullNames);
    List<string>.Enumerator enumerator = OutAssetFullNames.GetEnumerator();
    if (enumerator.MoveNext())
    {
      do
      {
        string current = enumerator.Current;
        \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, current, InTag);
      }
      while (enumerator.MoveNext());
    }
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InTag;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      FName fname;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ERemoveKey((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), fname);
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ELocalDestroyAsset(
    [In] FGameAssetDatabase* obj0,
    string InAssetFullName)
  {
    List<string> OutTags = new List<string>();
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InAssetFullName;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      FName InAssetFullNameFName;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&InAssetFullNameFName, (char*) numPtr, (EFindName) 1, 1U);
      \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullNameFName, (ETagQueryOptions.Type) 4, out OutTags);
      List<string>.Enumerator enumerator = OutTags.GetEnumerator();
      if (!enumerator.MoveNext())
        return;
      do
      {
        string current = enumerator.Current;
        \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, InAssetFullName, current);
      }
      while (enumerator.MoveNext());
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EAddAssetsToCollection(
    [In] FGameAssetDatabase* obj0,
    string InCollectionName,
    EGADCollection.Type InType,
    ICollection<string> InAssetFullNames)
  {
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    bool flag = false;
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) == 0 && InSystemTagType != ESystemTagType.LocalCollection)
    {
      string InTag = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, InCollectionName);
      flag = \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, InAssetFullNames, InTag);
    }
    else
    {
      string InTag = '['.ToString() + GADDefs.SystemTagTypeNames[5] + (object) ']' + InCollectionName;
      foreach (string inAssetFullName in (IEnumerable<string>) InAssetFullNames)
      {
        \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, inAssetFullName, InTag, false);
        flag = true;
      }
    }
    return flag;
  }

  internal static unsafe uint FGameAssetDatabase\u002EAddAssetsToCollection(
    [In] FGameAssetDatabase* obj0,
    FString* InCollectionName,
    EGADCollection.Type InType,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InAssetFullNames)
  {
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002EAddAssetsToCollection(obj0, InCollectionName1, InType, (ICollection<string>) \u003CModule\u003E.CLRTools\u002EToStringArray(InAssetFullNames));
  }

  internal static unsafe uint FGameAssetDatabase\u002ERemoveAssetsFromCollection(
    [In] FGameAssetDatabase* obj0,
    FString* InCollectionName,
    EGADCollection.Type InType,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InAssetFullNames)
  {
    string InCollectionName1 = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    return (uint) \u003CModule\u003E.FGameAssetDatabase\u002ERemoveAssetsFromCollection(obj0, InCollectionName1, InType, (ICollection<string>) \u003CModule\u003E.CLRTools\u002EToStringArray(InAssetFullNames));
  }

  internal static unsafe void FGameAssetDatabase\u002EQueryAssetsInCollection(
    [In] FGameAssetDatabase* obj0,
    FString* InCollectionName,
    EGADCollection.Type InType,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* OutAssetFullNames)
  {
    List<string> OutAssetFullNames1 = new List<string>();
    string TagValue = new string(\u003CModule\u003E.FString\u002E\u002A(InCollectionName), 0, \u003CModule\u003E.FString\u002ELen(InCollectionName));
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    string InTag = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, TagValue);
    \u003CModule\u003E.FGameAssetDatabase\u002EQueryAssetsWithTag(obj0, InTag, out OutAssetFullNames1);
    \u003CModule\u003E.CLRTools\u002EToFStringArray((ICollection<string>) OutAssetFullNames1, OutAssetFullNames);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ERemoveAssetsFromCollection(
    [In] FGameAssetDatabase* obj0,
    string InCollectionName,
    EGADCollection.Type InType,
    ICollection<string> InAssetFullNames)
  {
    ESystemTagType InSystemTagType = ESystemTagType.SharedCollection;
    switch (InType)
    {
      case (EGADCollection.Type) 0:
        InSystemTagType = ESystemTagType.SharedCollection;
        break;
      case (EGADCollection.Type) 1:
        InSystemTagType = ESystemTagType.PrivateCollection;
        break;
      case (EGADCollection.Type) 2:
        InSystemTagType = ESystemTagType.LocalCollection;
        break;
    }
    bool flag;
    if ((*(int*) ((IntPtr) obj0 + 248L) != 0 || *(int*) ((IntPtr) obj0 + 260L) != 0 || \u003CModule\u003E.GIsUnitTesting != 0U ? 0 : 1) == 0 && InSystemTagType != ESystemTagType.LocalCollection)
    {
      string InTag = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(InSystemTagType, InCollectionName);
      flag = \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagFromAssets(obj0, InAssetFullNames, InTag);
    }
    else
    {
      string InTag = '['.ToString() + GADDefs.SystemTagTypeNames[5] + (object) ']' + InCollectionName;
      foreach (string inAssetFullName in (IEnumerable<string>) InAssetFullNames)
        \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, inAssetFullName, InTag);
      flag = true;
    }
    return flag;
  }

  internal static unsafe FString* FGameAssetDatabase\u002EMakeObjectTypeSystemTag(
    [In] FString* obj0,
    FString* ClassName)
  {
    uint num1 = 0;
    string str = new string(\u003CModule\u003E.FString\u002E\u002A(ClassName), 0, \u003CModule\u003E.FString\u002ELen(ClassName));
    string InCLRString = '['.ToString() + GADDefs.SystemTagTypeNames[1] + (object) ']' + str;
    \u003CModule\u003E.CLRTools\u002EToFString(obj0, InCLRString);
    // ISSUE: fault handler
    try
    {
      num1 = 1U;
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  internal static ESystemTagType FGameAssetDatabase\u002EGetSystemTagType(string Tag)
  {
    if (Tag.Length > 0 && Tag[0] == '[' && (Tag.Length > 0 && Tag[0] == '['))
    {
      int num1 = Tag.IndexOf(']');
      if (num1 != -1)
      {
        string str = Tag.Substring(1, num1 - 1);
        int num2 = Array.IndexOf<string>(GADDefs.SystemTagTypeNames, str);
        if (num2 != -1)
          return (ESystemTagType) num2;
      }
    }
    return ESystemTagType.Invalid;
  }

  internal static string FGameAssetDatabase\u002EGetSystemTagValue(string Tag)
  {
    if (Tag.Length > 0 && Tag[0] == '[' && (Tag.Length > 0 && Tag[0] == '['))
    {
      int num1 = Tag.IndexOf(']');
      if (num1 != -1)
      {
        string str = Tag.Substring(num1 + 1);
        if ((Tag.Length <= 0 || Tag[0] != '[' || \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(Tag) != ESystemTagType.PrivateCollection ? 0 : 1) != 0)
        {
          int num2 = str.IndexOf(GADDefs.PrivateCollectionUserDelimiter);
          if (num2 != -1)
            str = str.Substring(num2 + 1);
        }
        return str;
      }
    }
    return string.Empty;
  }

  internal static unsafe string FGameAssetDatabase\u002EMakeTagNameForPrivateCollection(
    string InCollectionName)
  {
    FString fstring;
    FString* localUserName = \u003CModule\u003E.FGameAssetDatabase\u002EGetLocalUserName(&fstring);
    string str;
    // ISSUE: fault handler
    try
    {
      str = new string(\u003CModule\u003E.FString\u002E\u002A(localUserName), 0, \u003CModule\u003E.FString\u002ELen(localUserName)) + (object) GADDefs.PrivateCollectionUserDelimiter + InCollectionName;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    return str;
  }

  internal static string FGameAssetDatabase\u002EMakeSystemTag(
    ESystemTagType InSystemTagType,
    string TagValue)
  {
    if (InSystemTagType == ESystemTagType.PrivateCollection)
      TagValue = \u003CModule\u003E.FGameAssetDatabase\u002EMakeTagNameForPrivateCollection(TagValue);
    return '['.ToString() + GADDefs.SystemTagTypeNames[(int) InSystemTagType] + (object) ']' + TagValue;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool FGameAssetDatabase\u002EIsCollectionTag(string Tag, EGADCollection.Type InType)
  {
    int num;
    if (Tag.Length > 0 && Tag[0] == '[')
    {
      ESystemTagType esystemTagType = ESystemTagType.SharedCollection;
      switch (InType)
      {
        case (EGADCollection.Type) 0:
          esystemTagType = ESystemTagType.SharedCollection;
          break;
        case (EGADCollection.Type) 1:
          esystemTagType = ESystemTagType.PrivateCollection;
          break;
        case (EGADCollection.Type) 2:
          esystemTagType = ESystemTagType.LocalCollection;
          break;
      }
      if (\u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(Tag) == esystemTagType)
      {
        num = 1;
        goto label_8;
      }
    }
    num = 0;
label_8:
    return num != 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EIsMyPrivateCollection(
    string PrivateCollectionTag)
  {
    if (PrivateCollectionTag.Length > 0 && PrivateCollectionTag[0] == '[')
    {
      int num = PrivateCollectionTag.IndexOf(']');
      if (num != -1)
      {
        string str = PrivateCollectionTag.Substring(num + 1);
        int length = str.IndexOf(GADDefs.PrivateCollectionUserDelimiter);
        if (length != -1)
        {
          string a = str.Substring(0, length);
          FString fstring;
          FString* localUserName = \u003CModule\u003E.FGameAssetDatabase\u002EGetLocalUserName(&fstring);
          bool flag;
          // ISSUE: fault handler
          try
          {
            string b = new string(\u003CModule\u003E.FString\u002E\u002A(localUserName), 0, \u003CModule\u003E.FString\u002ELen(localUserName));
            flag = string.Equals(a, b, StringComparison.OrdinalIgnoreCase);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
          if (flag)
            return true;
        }
      }
    }
    return false;
  }

  internal static unsafe int CompareGameAssetDatabaseFStringConstRef\u002ECompare(
    FString* A,
    FString* B)
  {
    return \u003CModule\u003E.appStricmp(\u003CModule\u003E.FString\u002E\u002A(A), \u003CModule\u003E.FString\u002E\u002A(B));
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002EUpdateDatabase(
    [In] FGameAssetDatabase* obj0,
    FGameAssetDatabaseStartupConfig* InConfig)
  {
    List<int> DatabaseIndices1 = (List<int>) null;
    List<int> DatabaseIndices2 = (List<int>) null;
    List<string> OutTags1 = (List<string>) null;
    List<string> OutTags2 = (List<string>) null;
    uint num = (uint) *(int*) InConfig;
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.appGameDir(&fstring1);
    string str;
    // ISSUE: fault handler
    try
    {
      str = string.Format("{0}Content\\GameAssetDatabase.checkpoint", (object) new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) str;
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local2 = (byte*) string.Format("Checkpoint file name: {0}", (object) str);
    if (local2 != null)
      local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local2)
    {
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr1);
      ValueType valueType = (ValueType) new DateTime();
      (DateTime) valueType = new DateTime(0L);
      ValueType OutCheckpointFileTimeStamp = valueType;
      if (*(int*) ((IntPtr) InConfig + 4L) != 0)
      {
        if (\u003CModule\u003E.FGameAssetDatabase\u002ELoadCheckpointFile(obj0, out OutCheckpointFileTimeStamp))
        {
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          byte* local3 = (byte*) string.Format("Existing checkpoint file contains timestamp: {0}.", (object) ((DateTime) OutCheckpointFileTimeStamp).ToString());
          if (local3 != null)
            local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
          // ISSUE: explicit reference operation
          fixed (byte* numPtr2 = &^local3)
          {
            \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
            // ISSUE: cast to a reference type
            // ISSUE: variable of a reference type
            byte* local4 = (byte*) string.Format("Loaded {0} assets, {1} tags/collections ({2} in use) from the checkpoint file.", (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L)), (object) \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L)), (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L)));
            if (local4 != null)
              local4 = (long) (uint) RuntimeHelpers.OffsetToStringData + local4;
            // ISSUE: explicit reference operation
            fixed (byte* numPtr3 = &^local4)
              \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
          }
        }
        else if (num != 0U)
          return false;
        if (*(int*) ((IntPtr) InConfig + 36L) != 0)
        {
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage("======================================");
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage(" Assets in checkpoint file");
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage("======================================");
          \u003CModule\u003E.FGameAssetDatabase\u002EDumpDatabase(obj0);
        }
      }
      TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
      ValueType DeleteServerEntriesOlderThan1;
      // ISSUE: fault handler
      try
      {
        if (num != 0U && *(int*) ((IntPtr) InConfig + 16L) != 0)
          \u003CModule\u003E.FGameAssetDatabase\u002ERebuildDefaultTags(obj0, &fdefaultSetAllocator);
        DeleteServerEntriesOlderThan1 = (ValueType) null;
        if (*(int*) ((IntPtr) InConfig + 16L) != 0 && *(int*) ((IntPtr) InConfig + 20L) != 0)
          DeleteServerEntriesOlderThan1 = (ValueType) DateTime.Now.AddDays((double) -GADDefs.DeleteJournalEntriesOlderThanDays);
        string RestrictUserName = (string) null;
        if (num == 0U && *(int*) ((IntPtr) InConfig + 12L) != 0)
        {
          FString fstring2;
          FString* localUserName = \u003CModule\u003E.FGameAssetDatabase\u002EGetLocalUserName(&fstring2);
          // ISSUE: fault handler
          try
          {
            RestrictUserName = new string(\u003CModule\u003E.FString\u002E\u002A(localUserName), 0, \u003CModule\u003E.FString\u002ELen(localUserName));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        DatabaseIndices1 = new List<int>();
        if (*(int*) ((IntPtr) InConfig + 8L) != 0)
        {
          bool bIsAuthoritative = num != 0U;
          if (!\u003CModule\u003E.FGameAssetDatabase\u002ELoadJournalData(obj0, RestrictUserName, OutCheckpointFileTimeStamp, DeleteServerEntriesOlderThan1, bIsAuthoritative, &DatabaseIndices1))
          {
            if (num == 0U)
              goto label_33;
          }
          else
            goto label_33;
        }
        else
          goto label_33;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return false;
label_33:
      FGameAssetDatabase* fgameAssetDatabasePtr1;
      FGameAssetDatabase* fgameAssetDatabasePtr2;
      FGameAssetDatabase* fgameAssetDatabasePtr3;
      // ISSUE: fault handler
      try
      {
        fgameAssetDatabasePtr1 = (FGameAssetDatabase*) ((IntPtr) obj0 + 168L);
        fgameAssetDatabasePtr2 = (FGameAssetDatabase*) ((IntPtr) obj0 + 24L);
        fgameAssetDatabasePtr3 = (FGameAssetDatabase*) ((IntPtr) obj0 + 96L);
        \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Game asset database loaded a total of {0} assets, {1} tags and {2} persistent tags.", (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr3), (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr2), (object) \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr1)));
        if (num != 0U)
        {
          if (*(int*) ((IntPtr) InConfig + 16L) != 0)
          {
            List<string> stringList = new List<string>();
            List<string> OutTags3 = stringList;
            \u003CModule\u003E.FGameAssetDatabase\u002EQueryAllTags(obj0, out OutTags3, (ETagQueryOptions.Type) 1);
            List<string>.Enumerator enumerator = stringList.GetEnumerator();
            if (enumerator.MoveNext())
            {
              do
              {
                string current = enumerator.Current;
                if (\u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current) == ESystemTagType.Unverified)
                  \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, current);
              }
              while (enumerator.MoveNext());
            }
            \u003CModule\u003E.FGameAssetDatabase\u002ECheckForGhostAssets(obj0, &fdefaultSetAllocator, InConfig);
          }
          if (*(int*) ((IntPtr) InConfig + 48L) == 0)
          {
            if (*(int*) ((IntPtr) InConfig + 52L) == 0)
              goto label_53;
          }
          if (*(int*) ((IntPtr) obj0 + 260L) == 0)
          {
            DatabaseIndices2 = new List<int>();
            ValueType DeleteServerEntriesOlderThan2 = (ValueType) DateTime.Now.AddDays((double) -GADDefs.PurgeJournalEntriesOlderThanDays);
            if (\u003CModule\u003E.FGameAssetDatabase\u002ELoadAllServerJournalData(obj0, DeleteServerEntriesOlderThan2, &DatabaseIndices2))
              goto label_47;
          }
          else
            goto label_53;
        }
        else
          goto label_88;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return false;
label_47:
      // ISSUE: fault handler
      try
      {
        if (*(int*) ((IntPtr) InConfig + 52L) != 0)
        {
          if (DatabaseIndices2.Count > 0)
          {
            \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Deleting {0} old journal entries from the SQL database.", (object) DatabaseIndices2.Count));
            if (*(int*) ((IntPtr) obj0 + 248L) != 0)
            {
              if (\u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002D\u003E((auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).DeleteJournalEntries(DatabaseIndices2))
                goto label_53;
            }
          }
          else
            goto label_53;
        }
        else
          goto label_53;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return false;
label_53:
      // ISSUE: fault handler
      try
      {
        if (*(int*) ((IntPtr) InConfig + 28L) != 0)
          \u003CModule\u003E.FGameAssetDatabase\u002EVerifyIntegrityOfDatabase(obj0, (uint) *(int*) ((IntPtr) InConfig + 32L));
        if (*(int*) ((IntPtr) InConfig + 36L) != 0)
        {
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage("======================================");
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage(" After Journal File Download");
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage("======================================");
          \u003CModule\u003E.FGameAssetDatabase\u002EDumpDatabase(obj0);
        }
        if (*(int*) ((IntPtr) InConfig + 40L) != 0 || *(int*) ((IntPtr) InConfig + 44L) != 0)
        {
          \u003CModule\u003E.FGameAssetDatabase\u002EQueryAllTags(obj0, out OutTags1, (ETagQueryOptions.Type) 3);
          List<string>.Enumerator enumerator = OutTags1.GetEnumerator();
          if (enumerator.MoveNext())
          {
            do
            {
              string current = enumerator.Current;
              if (*(int*) ((IntPtr) InConfig + 40L) != 0 && (current.Length <= 0 || current[0] != '[' || \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current) != ESystemTagType.PrivateCollection ? 0 : 1) != 0)
                \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, current);
              else if (*(int*) ((IntPtr) InConfig + 44L) != 0 && !\u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagValue(current).StartsWith("UDK"))
                \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, current);
            }
            while (enumerator.MoveNext());
          }
        }
        if (*(int*) ((IntPtr) InConfig + 44L) != 0)
        {
          \u003CModule\u003E.FGameAssetDatabase\u002EQueryAllTags(obj0, out OutTags2, (ETagQueryOptions.Type) 2);
          List<string>.Enumerator enumerator = OutTags2.GetEnumerator();
          if (enumerator.MoveNext())
          {
            do
            {
              string current = enumerator.Current;
              if (current.StartsWith("Audit."))
                \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyTag(obj0, current);
            }
            while (enumerator.MoveNext());
          }
        }
        if (*(int*) ((IntPtr) InConfig + 16L) != 0)
        {
          if (*(int*) ((IntPtr) InConfig + 36L) == 0)
          {
            \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Saving checkpoint file with {0} assets, {1} tags and {2} persistent tags.", (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr3), (object) \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr2), (object) \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr1)));
            if (\u003CModule\u003E.FGameAssetDatabase\u002ESaveCheckpointFile(obj0))
              goto label_75;
          }
          else
            goto label_88;
        }
        else
          goto label_88;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return false;
label_75:
      // ISSUE: fault handler
      try
      {
        if (*(int*) ((IntPtr) obj0 + 260L) == 0)
        {
          if (*(int*) ((IntPtr) InConfig + 20L) != 0)
          {
            \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Journal entries older than {0} will be deleted from the server.", (object) ((DateTime) DeleteServerEntriesOlderThan1).ToString()));
            if (DatabaseIndices1.Count > 0)
            {
              \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Deleting {0} expired journal entries from the SQL database.", (object) DatabaseIndices1.Count));
              if (*(int*) ((IntPtr) obj0 + 248L) != 0)
              {
                if (\u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002D\u003E((auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) ((IntPtr) obj0 + 252L)).DeleteJournalEntries(DatabaseIndices1))
                  goto label_88;
              }
            }
            else
              goto label_82;
          }
          else
            goto label_88;
        }
        else
          goto label_84;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return false;
label_82:
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("No expired journal entries to delete yet."));
        goto label_88;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
label_84:
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Purging local journal file (all entries were merged into checkpoint file.)"));
        if (\u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002D\u003E((auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) ((IntPtr) obj0 + 264L)).DeleteJournalFile())
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Journal file was deleted successfully"));
        else
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage(string.Format("GameAssetDatabase: Warning: Unable to delete the journal file from disk (possibly read-only?)"));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
label_88:
      \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      return true;
    }
  }

  internal static unsafe void FGameAssetDatabase\u002EDumpDatabase([In] FGameAssetDatabase* obj0)
  {
    TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator1;
    \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator1);
    // ISSUE: fault handler
    try
    {
      FGameAssetDatabase* fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 96L);
      \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr, &fdefaultSetAllocator1);
      TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator;
      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
      // ISSUE: fault handler
      try
      {
        TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator1;
        \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator1, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator1, 0);
        if (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1))
        {
          do
          {
            FString fstring;
            FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1), &fstring);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(&fdefaultAllocator, fstringPtr);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
            \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1);
          }
          while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1));
        }
        \u003CModule\u003E.Sort\u003Cclass\u0020FString\u002Cclass\u0020CompareGameAssetDatabaseFStringConstRef\u003E(\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EGetTypedData(&fdefaultAllocator), \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
        int num = 0;
        if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
        {
          do
          {
            FString* fstringPtr1 = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
            StringBuilder stringBuilder = new StringBuilder();
            TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator2;
            \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator2);
            // ISSUE: fault handler
            try
            {
              FName fname;
              \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr, *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(fstringPtr1), (EFindName) 1, 1U), &fdefaultSetAllocator2);
              TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator2;
              \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator2, &fdefaultSetAllocator2, 0);
              if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2))
              {
                do
                {
                  FString fstring;
                  FString* fstringPtr2 = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2), &fstring);
                  // ISSUE: fault handler
                  try
                  {
                    string str = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr2), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr2));
                    stringBuilder.AppendFormat("{0}; ", (object) str);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
                  \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2);
                }
                while (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2));
              }
              string str1 = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr1), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr1));
              // ISSUE: cast to a reference type
              // ISSUE: variable of a reference type
              byte* local = (byte*) string.Format("[{0}] {1} : {2}", (object) num, (object) str1, (object) stringBuilder.ToString());
              if (local != null)
                local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
              // ISSUE: explicit reference operation
              fixed (byte* numPtr = &^local)
                \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator2);
            }
            \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator2);
            ++num;
          }
          while (num < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
      }
      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator1);
    }
    \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator1);
  }

  internal static unsafe void FGameAssetDatabase\u002ESetErrorMessageText(
    [In] FGameAssetDatabase* obj0,
    string InErrorString)
  {
    FString fstring1;
    FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, InErrorString);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FString\u002E\u003D((FString*) ((IntPtr) obj0 + 8L), fstring2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
  }

  internal static unsafe string FGameAssetDatabase\u002EGetErrorMessageText([In] FGameAssetDatabase* obj0)
  {
    FString* fstringPtr = (FString*) ((IntPtr) obj0 + 8L);
    return new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
  }

  internal static unsafe void FGameAssetDatabase\u002EAddTagMapping(
    [In] FGameAssetDatabase* obj0,
    FName* InAssetFullNameFName,
    FName* InTagFName,
    [MarshalAs(UnmanagedType.U1)] bool bIsAuthoritative)
  {
    FString fstring;
    FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(InAssetFullNameFName, &fstring);
    string str1;
    // ISSUE: fault handler
    try
    {
      str1 = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    if ((!(str1 != (string) null) || str1.Length <= 0 ? 0 : 1) == 0)
      return;
    if (!bIsAuthoritative && \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), *InAssetFullNameFName) == 0U)
    {
      string str2 = "";
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local = (byte*) ('['.ToString() + GADDefs.SystemTagTypeNames[6] + (object) ']' + str2);
      if (local != null)
        local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local)
      {
        FName fname;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (char*) numPtr, (EFindName) 1, 1U);
        \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullNameFName, &fname, true);
      }
    }
    FSetElementId fsetElementId;
    \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), &fsetElementId, *InTagFName, (uint*) 0L);
    \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EAdd((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L), *InTagFName, *InAssetFullNameFName);
    FGameAssetDatabase* fgameAssetDatabasePtr1 = (FGameAssetDatabase*) ((IntPtr) obj0 + 96L);
    int num1 = \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr1, *InAssetFullNameFName) == 0U ? 1 : 0;
    \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EAdd((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr1, *InAssetFullNameFName, *InTagFName);
    if ((byte) num1 == (byte) 0)
      return;
    int num2 = str1.IndexOf(' ');
    string str3 = str1.Substring(num2 + 1);
    int length = str3.LastIndexOf('.');
    string key = str3.Substring(0, length);
    FGameAssetDatabase* fgameAssetDatabasePtr2 = (FGameAssetDatabase*) ((IntPtr) obj0 + 240L);
    if (\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2).ContainsKey(key))
      ++\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2)[key];
    else
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2).Add(key, 1);
  }

  internal static unsafe void FGameAssetDatabase\u002EAddTagMapping(
    [In] FGameAssetDatabase* obj0,
    string InAssetFullName,
    string InTag,
    [MarshalAs(UnmanagedType.U1)] bool bIsAuthoritative)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) InAssetFullName;
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      FName fname1;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname1, (char*) numPtr1, (EFindName) 1, 1U);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local2 = (byte*) InTag;
      if (local2 != null)
        local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr2 = &^local2)
      {
        FName fname2;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname2, (char*) numPtr2, (EFindName) 1, 1U);
        \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, &fname1, &fname2, bIsAuthoritative);
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ERemoveTagMapping(
    [In] FGameAssetDatabase* obj0,
    string InAssetFullName,
    string InTag)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) InAssetFullName;
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      FName fname1;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname1, (char*) numPtr1, (EFindName) 1, 1U);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local2 = (byte*) InTag;
      if (local2 != null)
        local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr2 = &^local2)
      {
        FName fname2;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname2, (char*) numPtr2, (EFindName) 1, 1U);
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ERemove((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L), fname2, fname1);
        FGameAssetDatabase* fgameAssetDatabasePtr1 = (FGameAssetDatabase*) ((IntPtr) obj0 + 96L);
        if (\u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr1, fname1) == 0U)
          return;
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002ERemove((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr1, fname1, fname2);
        if (\u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey((TSetMap\u003CFName\u002CFName\u003E*) fgameAssetDatabasePtr1, fname1) != 0U)
          return;
        int num = InAssetFullName.IndexOf(' ');
        string str = InAssetFullName.Substring(num + 1);
        int length = str.LastIndexOf('.');
        string key = str.Substring(0, length);
        FGameAssetDatabase* fgameAssetDatabasePtr2 = (FGameAssetDatabase*) ((IntPtr) obj0 + 240L);
        if (\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2)[key] == 1)
          \u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2).Remove(key);
        else
          --\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) fgameAssetDatabasePtr2)[key];
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ERemoveAssetTagMappings(
    [In] FGameAssetDatabase* obj0,
    FName* AssetFullNameFName)
  {
    TArray\u003CFName\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), *AssetFullNameFName, &fdefaultAllocator);
      int num = 0;
      if (0 < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
      {
        do
        {
          FName* fnamePtr = \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
          FName fname;
          // ISSUE: cpblk instruction
          __memcpy(ref fname, (IntPtr) fnamePtr, 8);
          FString fstring1;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1);
          string InTag;
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FName\u002EToString(&fname, &fstring1);
            InTag = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring1), 0, \u003CModule\u003E.FString\u002ELen(&fstring1));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2);
          string InAssetFullName;
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FName\u002EToString(AssetFullNameFName, &fstring2);
            InAssetFullName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, InAssetFullName, InTag);
          ++num;
        }
        while (num < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
  }

  internal static unsafe DateTime FGameAssetDatabase\u002EGetJournalAlarmTime()
  {
    DateTime dateTime1 = new DateTime();
    FString fstring;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring);
    DateTime dateTime2;
    // ISSUE: fault handler
    try
    {
      int num = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D118, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D117, &fstring, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      DateTime dateTime3;
      if (\u003CModule\u003E.FString\u002ELen(&fstring) == 0)
      {
        DateTime InAlarmTime = DateTime.Now.Add(new TimeSpan(7, 0, 0, 0));
        dateTime3 = InAlarmTime;
        \u003CModule\u003E.FGameAssetDatabase\u002ESetJournalAlarmTime(InAlarmTime);
      }
      else
        dateTime3 = Convert.ToDateTime(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring), 0, \u003CModule\u003E.FString\u002ELen(&fstring)), (IFormatProvider) new CultureInfo("en-US"));
      dateTime2 = dateTime3;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    return dateTime2;
  }

  internal static unsafe void FGameAssetDatabase\u002ESetJournalAlarmTime(DateTime InAlarmTime)
  {
    FString fstring;
    \u003CModule\u003E.CLRTools\u002EToFString(&fstring, InAlarmTime.ToString((IFormatProvider) new CultureInfo("en-US")));
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FConfigCacheIni\u002ESetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D120, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D119, \u003CModule\u003E.FString\u002E\u002A(&fstring), (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
  }

  internal static unsafe uint FGameAssetDatabase\u002EJournalUpdate()
  {
    uint num = 0;
    FGameAssetDatabaseStartupConfig databaseStartupConfig;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 4) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 8) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 12) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 20) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 24) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 32) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 36) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 40) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 44) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 48) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 52) = 0;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ref databaseStartupConfig = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 28) = 1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(int&) ((IntPtr) &databaseStartupConfig + 16) = 1;
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D122, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D121, (char*) 0L);
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (IntPtr, char*, uint, uint)>) *(long*) (*(long*) \u003CModule\u003E.GWarn + 40L))((uint) \u003CModule\u003E.GWarn, (uint) \u003CModule\u003E.FString\u002E\u002A(fstringPtr), (char*) 1, IntPtr.Zero);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring2;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FGameAssetDatabase\u002EInit(&databaseStartupConfig, &fstring2);
      if (\u003CModule\u003E.FString\u002ELen(&fstring2) > 0)
      {
        \u003CModule\u003E.FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u003E((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 789, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D123, \u003CModule\u003E.FString\u002E\u002A(&fstring2));
      }
      else
      {
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 760, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D124);
        num = 1U;
      }
      if ((IntPtr) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
      {
        FGameAssetDatabase* database0PeaV1Ea = \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA)((uint) database0PeaV1Ea, new IntPtr(1));
        \u003CModule\u003E.\u003FGameAssetDatabaseSingleton\u0040FGameAssetDatabase\u0040\u00400PEAV1\u0040EA = (FGameAssetDatabase*) 0L;
      }
      FFeedbackContext* gwarn = \u003CModule\u003E.GWarn;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      __calli((__FnPtr<void (IntPtr)>) *(long*) (*(long*) gwarn + 48L))((IntPtr) gwarn);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    return num;
  }

  internal static unsafe void FGameAssetDatabase\u002EShowJournalAlarmDialog()
  {
    WxChoiceDialogBase.Choice choice1;
    WxChoiceDialogBase.Choice* choicePtr1 = \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(&choice1);
    WxChoiceDialog wxChoiceDialog;
    // ISSUE: fault handler
    try
    {
      FString fstring1;
      FString* fstringPtr1 = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D126, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D125, (char*) 0L);
      // ISSUE: fault handler
      try
      {
        WxChoiceDialogBase.Choice choice2;
        WxChoiceDialogBase.Choice* choicePtr2 = \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(&choice2, 3, fstringPtr1, (WxChoiceDialogBase.EDialogChoiceType) 0);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          FString* fstringPtr2 = \u003CModule\u003E.LocalizeUnrealEd(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D128, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D127, (char*) 0L);
          // ISSUE: fault handler
          try
          {
            WxChoiceDialogBase.Choice choice3;
            WxChoiceDialogBase.Choice* choicePtr3 = \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(&choice3, 2, fstringPtr2, (WxChoiceDialogBase.EDialogChoiceType) 0);
            // ISSUE: fault handler
            try
            {
              FString fstring3;
              FString* fstringPtr3 = \u003CModule\u003E.LocalizeUnrealEd(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D130, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D129, (char*) 0L);
              // ISSUE: fault handler
              try
              {
                WxChoiceDialogBase.Choice choice4;
                WxChoiceDialogBase.Choice* choicePtr4 = \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(&choice4, 1, fstringPtr3, (WxChoiceDialogBase.EDialogChoiceType) 2);
                // ISSUE: fault handler
                try
                {
                  FString fstring4;
                  FString* fstringPtr4 = \u003CModule\u003E.LocalizeUnrealEd(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D132, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D131, (char*) 0L);
                  // ISSUE: fault handler
                  try
                  {
                    WxChoiceDialogBase.Choice choice5;
                    WxChoiceDialogBase.Choice* choicePtr5 = \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(&choice5, 0, fstringPtr4, (WxChoiceDialogBase.EDialogChoiceType) 1);
                    // ISSUE: fault handler
                    try
                    {
                      FString fstring5;
                      FString* fstringPtr5 = &fstring5;
                      FString* fstringPtr6 = \u003CModule\u003E.LocalizeUnrealEd(&fstring5, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D134, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D133, (char*) 0L);
                      FString* fstringPtr7;
                      // ISSUE: fault handler
                      try
                      {
                        FString fstring6;
                        FString* fstringPtr8 = &fstring6;
                        fstringPtr7 = \u003CModule\u003E.LocalizeUnrealEd(&fstring6, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D136, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D135, (char*) 0L);
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) fstringPtr5);
                      }
                      \u003CModule\u003E.WxChoiceDialog\u002E\u007Bctor\u007D(&wxChoiceDialog, fstringPtr7, fstringPtr6, choicePtr5, choicePtr4, choicePtr3, choicePtr2, choicePtr1);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D), (void*) &choice5);
                    }
                    // ISSUE: fault handler
                    try
                    {
                      \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(&choice5);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
                  }
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
                  }
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D), (void*) &choice4);
                }
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(&choice4);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
                }
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
              }
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D), (void*) &choice3);
            }
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(&choice3);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D), (void*) &choice2);
        }
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(&choice2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D), (void*) &choice1);
    }
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(&choice1);
      \u003CModule\u003E.wxWindowBase\u002ESetWindowStyle((wxWindowBase*) &wxChoiceDialog, \u003CModule\u003E.wxWindowBase\u002EGetWindowStyle((wxWindowBase*) &wxChoiceDialog) | 32768);
      \u003CModule\u003E.wxDialog\u002EShowModal((wxDialog*) &wxChoiceDialog);
      int days;
      switch (*(int*) \u003CModule\u003E.WxChoiceDialogBase\u002EGetChoice((WxChoiceDialogBase*) &wxChoiceDialog))
      {
        case 0:
          if (\u003CModule\u003E.FGameAssetDatabase\u002EJournalUpdate() != 0U)
          {
            days = 7;
            break;
          }
          goto label_45;
        case 2:
          days = 1;
          break;
        case 3:
          days = 7;
          break;
        default:
          goto label_45;
      }
      \u003CModule\u003E.FGameAssetDatabase\u002ESetJournalAlarmTime(DateTime.Now.Add(new TimeSpan(days, 0, 0, 0)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(WxChoiceDialog\u002E\u007Bdtor\u007D), (void*) &wxChoiceDialog);
    }
label_45:
    \u003CModule\u003E.WxChoiceDialog\u002E\u007Bdtor\u007D(&wxChoiceDialog);
  }

  internal static unsafe FString* FGameAssetDatabase\u002EGetLocalUserName([In] FString* obj0)
  {
    uint num1;
    // ISSUE: fault handler
    try
    {
      num1 = 0U;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(obj0, \u003CModule\u003E.appUserName());
      num1 = 1U;
      FString fstring;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring);
      // ISSUE: fault handler
      try
      {
        if (\u003CModule\u003E.FConfigCacheIni\u002EGetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D141, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D140, &fstring, (char*) &\u003CModule\u003E.GEditorUserSettingsIni) != 0U)
        {
          if (\u003CModule\u003E.FString\u002ELen(&fstring) > 0)
            \u003CModule\u003E.FString\u002E\u003D(obj0, &fstring);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
      return obj0;
    }
    __fault
    {
      if (((int) num1 & 1) != 0)
      {
        uint num2 = num1 & 4294967294U;
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ELoadCheckpointFile(
    [In] FGameAssetDatabase* obj0,
    out ValueType OutCheckpointFileTimeStamp)
  {
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.appGameDir(&fstring1);
    string path;
    // ISSUE: fault handler
    try
    {
      path = string.Format("{0}Content\\GameAssetDatabase.checkpoint", (object) new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    string StrParam0 = path;
    try
    {
      auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E systemIoFileStream1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E(File.OpenRead(path));
      auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E systemIoFileStream2;
      // ISSUE: fault handler
      try
      {
        systemIoFileStream2 = systemIoFileStream1;
        auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryReader\u003E systemIoBinaryReader1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryReader\u003E(new BinaryReader((Stream) systemIoFileStream2.get()));
        auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryReader\u003E systemIoBinaryReader2;
        // ISSUE: fault handler
        try
        {
          systemIoBinaryReader2 = systemIoBinaryReader1;
          byte[] numArray = systemIoBinaryReader2.op_MemberSelection().ReadBytes(GADDefs.CheckpointFileHeaderChars.Length);
          for (int index = 0; index < GADDefs.CheckpointFileHeaderChars.Length; ++index)
          {
            if ((int) numArray[index] != (int) GADDefs.CheckpointFileHeaderChars[index])
              throw new SystemException("Checkpoint file header doesn't match");
          }
          int num1 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
          if (num1 > GADDefs.CheckpointFileVersionNumber)
            throw new SystemException("The checkpoint file was created with a newer version of the application that is currently loaded.");
          ValueType valueType = (ValueType) new DateTime();
          (DateTime) valueType = new DateTime((long) systemIoBinaryReader2.op_MemberSelection().ReadUInt64());
          OutCheckpointFileTimeStamp = valueType;
          bool flag = false;
          TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
          \u003CModule\u003E.TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
          // ISSUE: fault handler
          try
          {
            int num2 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
            for (int index = 0; index < num2; ++index)
            {
              int num3 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
              string InCLRString = systemIoBinaryReader2.op_MemberSelection().ReadString();
              FName* InFName = \u003CModule\u003E.TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind((TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, num3);
              if ((IntPtr) InFName != IntPtr.Zero)
              {
                flag = true;
                \u003CModule\u003E.CLRTools\u002ELogWarningMessage(string.Format("Warning: Name collision '{0}' <-> '{1}'.", (object) InCLRString, (object) \u003CModule\u003E.CLRTools\u002EFNameToString(InFName)));
              }
              FString fstring2;
              FString* fstring3 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring2, InCLRString);
              // ISSUE: fault handler
              try
              {
                FName fname;
                \u003CModule\u003E.TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002ESet((TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, num3, *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(fstring3), (EFindName) 1, 1U));
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
            }
            if (flag)
              \u003CModule\u003E.CLRTools\u002ELogWarningMessage(string.Format("GameAssetDatabase::LoadCheckpointFile> Warning: the checkpoint file '{0}' needs to be resaved.", (object) StrParam0));
            if (num1 >= GADDefs.CheckpointFileVersionNumber_PersistentCollections)
            {
              int num3 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
              for (int index = 0; index < num3; ++index)
              {
                int num4 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
                FName fname;
                \u003CModule\u003E.TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFindRef((TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, &fname, num4);
                FSetElementId fsetElementId;
                \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), &fsetElementId, fname, (uint*) 0L);
              }
            }
            int num5 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
            for (int index1 = 0; index1 < num5; ++index1)
            {
              int num3 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
              FName fname1;
              \u003CModule\u003E.TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFindRef((TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, &fname1, num3);
              int numberAssetFullNames = GADDefs.CheckpointFileVersionNumber_AssetFullNames;
              int num4 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
              for (int index2 = 0; index2 < num4; ++index2)
              {
                int num6 = systemIoBinaryReader2.op_MemberSelection().ReadInt32();
                FName fname2;
                \u003CModule\u003E.TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFindRef((TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, &fname2, num6);
                \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, &fname1, &fname2, true);
              }
            }
            systemIoBinaryReader2.op_MemberSelection().Close();
            systemIoFileStream2.op_MemberSelection().Close();
            if (num1 < GADDefs.CheckpointFileVersionNumber_AssetFullNames)
              \u003CModule\u003E.FGameAssetDatabase\u002EFixBrokenAssetNames(obj0);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
          }
          \u003CModule\u003E.TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
        }
        __fault
        {
          systemIoBinaryReader2.Dispose();
        }
        systemIoBinaryReader2.Dispose();
      }
      __fault
      {
        systemIoFileStream2.Dispose();
      }
      systemIoFileStream2.Dispose();
    }
    catch (FileNotFoundException ex)
    {
      \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Warning: Checkpoint file [{0}] was not found.", (object) StrParam0));
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.FGameAssetDatabase\u002ESetErrorMessageText(obj0, \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_ErrorLoadingCheckpointFile_F", StrParam0, ex.ToString(), (string) null));
      \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("FGameAssetDatabase::LoadCheckpointFile: {0}", (object) \u003CModule\u003E.FGameAssetDatabase\u002EGetErrorMessageText(obj0)));
      return false;
    }
    return true;
  }

  internal static unsafe void TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool FGameAssetDatabase\u002ESaveCheckpointFile([In] FGameAssetDatabase* obj0)
  {
    FString fstring1;
    FString* fstringPtr1 = \u003CModule\u003E.appGameDir(&fstring1);
    string path;
    // ISSUE: fault handler
    try
    {
      path = string.Format("{0}Content\\GameAssetDatabase.checkpoint", (object) new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr1)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    string StrParam0 = path;
    try
    {
      if (File.Exists(path))
      {
        FileAttributes attributes = File.GetAttributes(path);
        if ((attributes & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
        {
          \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Warning: Checkpoint file [{0}] is marked readonly, overwriting.", (object) path));
          File.SetAttributes(path, attributes & ~FileAttributes.ReadOnly);
        }
      }
      auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E systemIoFileStream1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E(File.Create(path));
      auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AFileStream\u003E systemIoFileStream2;
      // ISSUE: fault handler
      try
      {
        systemIoFileStream2 = systemIoFileStream1;
        auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryWriter\u003E systemIoBinaryWriter1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryWriter\u003E(new BinaryWriter((Stream) systemIoFileStream2.get()));
        auto_handle\u003CSystem\u003A\u003AIO\u003A\u003ABinaryWriter\u003E systemIoBinaryWriter2;
        // ISSUE: fault handler
        try
        {
          systemIoBinaryWriter2 = systemIoBinaryWriter1;
          systemIoBinaryWriter2.op_MemberSelection().Write(GADDefs.CheckpointFileHeaderChars);
          systemIoBinaryWriter2.op_MemberSelection().Write(GADDefs.CheckpointFileVersionNumber);
          ulong ticks = (ulong) DateTime.Now.Ticks;
          systemIoBinaryWriter2.op_MemberSelection().Write(ticks);
          TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator1;
          \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator1);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), &fdefaultSetAllocator1);
            TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator2;
            \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator2);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 24L), &fdefaultSetAllocator2);
              TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator3;
              \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator3);
              // ISSUE: fault handler
              try
              {
                TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator1;
                \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator1, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator1, 0);
                while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1))
                {
                  \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EAddItem(&fdefaultSetAllocator3, *\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1), 0U);
                  \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1);
                }
                TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator2;
                \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator2, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator2, 0);
                while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2))
                {
                  \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EAddItem(&fdefaultSetAllocator3, *\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2), 0U);
                  \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator2);
                }
                TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator3;
                \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator3, (TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 168L), 0);
                while (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator3))
                {
                  \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EAddItem(&fdefaultSetAllocator3, *\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator3), 0U);
                  \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator3);
                }
                systemIoBinaryWriter2.op_MemberSelection().Write(\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ENum((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator3));
                int num = \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(\u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EGetUniqueElements(&fdefaultSetAllocator3));
                for (int index = 0; index < num; ++index)
                {
                  systemIoBinaryWriter2.op_MemberSelection().Write(index);
                  TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E.FLookupMapElementReference elementReference;
                  FString fstring2;
                  FString* fstringPtr2 = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EFLookupMapElementReference\u002E\u002EAEBVFName\u0040\u0040(\u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EGetItem(&fdefaultSetAllocator3, &elementReference, index)), &fstring2);
                  // ISSUE: fault handler
                  try
                  {
                    FString fstring3;
                    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, \u003CModule\u003E.FString\u002E\u002A(fstringPtr2));
                    // ISSUE: fault handler
                    try
                    {
                      systemIoBinaryWriter2.op_MemberSelection().Write(\u003CModule\u003E.CLRTools\u002EToString(&fstring3));
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                }
                FGameAssetDatabase* fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 168L);
                systemIoBinaryWriter2.op_MemberSelection().Write(\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr));
                TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator4;
                \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator4, (TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr, 0);
                while (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator4))
                {
                  int* numPtr = \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002EFind((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator3, *\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator4));
                  systemIoBinaryWriter2.op_MemberSelection().Write(*numPtr);
                  \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator4);
                }
                systemIoBinaryWriter2.op_MemberSelection().Write(\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ENum((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator1));
                TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator5;
                \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator5, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator1, 0);
                while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator5))
                {
                  FName* fnamePtr1 = \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator5);
                  TArray\u003CFName\u002CFDefaultAllocator\u003E fdefaultAllocator;
                  \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), *fnamePtr1, &fdefaultAllocator);
                    int* numPtr1 = \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002EFind((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator3, *fnamePtr1);
                    systemIoBinaryWriter2.op_MemberSelection().Write(*numPtr1);
                    systemIoBinaryWriter2.op_MemberSelection().Write(\u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
                    for (int index = 0; index < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator); ++index)
                    {
                      FName* fnamePtr2 = \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, index);
                      int* numPtr2 = \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002EFind((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator3, *fnamePtr2);
                      systemIoBinaryWriter2.op_MemberSelection().Write(*numPtr2);
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
                  }
                  \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
                  \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator5);
                }
                systemIoBinaryWriter2.op_MemberSelection().Close();
                systemIoFileStream2.op_MemberSelection().Close();
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator3);
              }
              \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator3);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator2);
            }
            \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator2);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator1);
          }
          \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator1);
        }
        __fault
        {
          systemIoBinaryWriter2.Dispose();
        }
        systemIoBinaryWriter2.Dispose();
      }
      __fault
      {
        systemIoFileStream2.Dispose();
      }
      systemIoFileStream2.Dispose();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.FGameAssetDatabase\u002ESetErrorMessageText(obj0, \u003CModule\u003E.CLRTools\u002ELocalizeString("GameAssetDatabase_ErrorWritingCheckpointFile_F", StrParam0, ex.ToString(), (string) null));
      \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("FGameAssetDatabase::SaveCheckpointFile: {0}", (object) \u003CModule\u003E.FGameAssetDatabase\u002EGetErrorMessageText(obj0)));
      return false;
    }
    return true;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool FGameAssetDatabase\u002ELoadJournalData(
    [In] FGameAssetDatabase* obj0,
    string RestrictUserName,
    ValueType IgnoreServerEntriesAsOldAs,
    ValueType DeleteServerEntriesOlderThan,
    [MarshalAs(UnmanagedType.U1)] bool bIsAuthoritative,
    List<int>* OutDatabaseIndicesToDelete)
  {
    // ISSUE: unable to decompile the method.
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool FGameAssetDatabase\u002ELoadAllServerJournalData(
    [In] FGameAssetDatabase* obj0,
    ValueType DeleteServerEntriesOlderThan,
    List<int>* OutDatabaseIndicesToDelete)
  {
    // ISSUE: unable to decompile the method.
  }

  internal static unsafe void FGameAssetDatabase\u002ESetDefaultTagsForAsset(
    [In] FGameAssetDatabase* obj0,
    string InAssetFullName,
    string InObjectTypeName,
    string InOutermostPackageName,
    [MarshalAs(UnmanagedType.U1)] bool bInIsArchetype,
    [MarshalAs(UnmanagedType.U1)] bool bSendToJournalIfNeeded)
  {
    List<string> OutTags = (List<string>) null;
    bool flag1 = false;
    bool flag2 = false;
    \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullName, (ETagQueryOptions.Type) 1, out OutTags);
    List<string>.Enumerator enumerator = OutTags.GetEnumerator();
    if (enumerator.MoveNext())
    {
      do
      {
        string current = enumerator.Current;
        ESystemTagType systemTagType = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current);
        if (systemTagType == ESystemTagType.ObjectType || systemTagType == ESystemTagType.OutermostPackage || systemTagType == ESystemTagType.Archetype)
        {
          flag1 = true;
          \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, InAssetFullName, current);
        }
        switch (systemTagType)
        {
          case ESystemTagType.Ghost:
            \u003CModule\u003E.FGameAssetDatabase\u002ERemoveTagMapping(obj0, InAssetFullName, current);
            break;
          case ESystemTagType.DateAdded:
            flag2 = true;
            break;
        }
      }
      while (enumerator.MoveNext());
    }
    string InTag1 = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(ESystemTagType.ObjectType, InObjectTypeName);
    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullName, InTag1, true);
    string InTag2 = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(ESystemTagType.OutermostPackage, InOutermostPackageName);
    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullName, InTag2, true);
    string InTag3 = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(ESystemTagType.Archetype, "");
    if (bInIsArchetype)
      \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullName, InTag3, true);
    if (!flag2)
    {
      string InTag4 = \u003CModule\u003E.FGameAssetDatabase\u002EMakeSystemTag(ESystemTagType.DateAdded, DateTime.Today.Ticks.ToString());
      \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullName, InTag4, true);
    }
    if (flag1 || !bSendToJournalIfNeeded)
      return;
    List<string> stringList = new List<string>();
    stringList.Add(InAssetFullName);
    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, (ICollection<string>) stringList, InTag1);
    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, (ICollection<string>) stringList, InTag2);
    if (!bInIsArchetype)
      return;
    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagToAssets(obj0, (ICollection<string>) stringList, InTag3);
  }

  internal static unsafe int FGameAssetDatabase\u002EGatherAssetsFromPackageLinker(
    [In] FGameAssetDatabase* obj0,
    ULinkerLoad* InLinker,
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* InAllowedClasses,
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* InOutCurrentlyExistingAssets)
  {
    int num1 = 0;
    int num2 = 0;
    ULinkerLoad* ulinkerLoadPtr1 = (ULinkerLoad*) ((IntPtr) InLinker + 320L);
    if (0 < \u003CModule\u003E.TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E\u002ENum((TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E*) ulinkerLoadPtr1))
    {
      do
      {
        FObjectExport* fobjectExportPtr = \u003CModule\u003E.TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E\u002E\u0028\u0029((TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E*) ulinkerLoadPtr1, num2);
        FName fname1;
        \u003CModule\u003E.ULinkerLoad\u002EGetExportClassName(InLinker, &fname1, num2);
        FName fname2;
        \u003CModule\u003E.ULinkerLoad\u002EGetExportClassPackage(InLinker, &fname2, num2);
        FString fstring1;
        FString* fstringPtr1 = \u003CModule\u003E.FName\u002EToString(&fname1, &fstring1);
        UClass* uclassPtr;
        // ISSUE: fault handler
        try
        {
          uclassPtr = \u003CModule\u003E.FindObject\u003Cclass\u0020UClass\u003E((UObject*) -1L, \u003CModule\u003E.FString\u002E\u002A(fstringPtr1), 1U);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        if ((IntPtr) uclassPtr == IntPtr.Zero)
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D142);
          // ISSUE: fault handler
          try
          {
            FString fstring3;
            FString* fstringPtr2 = \u003CModule\u003E.FName\u002EToString(&fname1, &fstring3);
            // ISSUE: fault handler
            try
            {
              FString fstring4;
              FString* fstringPtr3 = \u003CModule\u003E.FName\u002EToString(&fname2, &fstring4);
              // ISSUE: fault handler
              try
              {
                FString fstring5;
                FString* fstringPtr4 = \u003CModule\u003E.FString\u002E\u002B(fstringPtr3, &fstring5, &fstring2);
                // ISSUE: fault handler
                try
                {
                  FString fstring6;
                  FString* fstringPtr5 = \u003CModule\u003E.FString\u002E\u002B(fstringPtr4, &fstring6, fstringPtr2);
                  // ISSUE: fault handler
                  try
                  {
                    uclassPtr = \u003CModule\u003E.LoadObject\u003Cclass\u0020UClass\u003E((UObject*) 0L, \u003CModule\u003E.FString\u002E\u002A(fstringPtr5), (char*) 0L, 0U, (UPackageMap*) 0L);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring6);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring6);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          if ((IntPtr) uclassPtr == IntPtr.Zero)
            goto label_47;
        }
        bool bInIsArchetype = (*(long*) ((IntPtr) fobjectExportPtr + 24L) & 1024L) == 1024L;
        bool flag1 = \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(InAllowedClasses, fname1) != 0U || bInIsArchetype;
        bool flag2 = (*(int*) ((IntPtr) InLinker + 116L) & 131072) != 131072;
        if (flag1)
        {
          if (!flag2)
          {
            ulong num3 = (ulong) *(long*) ((IntPtr) fobjectExportPtr + 24L);
            if (((long) num3 & 2251799813685248L) != 2251799813685248L || ((long) num3 & 17179869184L) != 17179869184L)
              goto label_47;
          }
          if ((*(long*) ((IntPtr) fobjectExportPtr + 24L) & 512L) == 0L && *(int*) ((IntPtr) fobjectExportPtr + 16L) == 0)
          {
            FString fstring2;
            FString* exportPathName = \u003CModule\u003E.ULinker\u002EGetExportPathName((ULinker*) InLinker, &fstring2, num2, (char*) 0L, 0U);
            string str1;
            // ISSUE: fault handler
            try
            {
              str1 = new string(\u003CModule\u003E.FString\u002E\u002A(exportPathName), 0, \u003CModule\u003E.FString\u002ELen(exportPathName));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
            FString fstring3;
            FString* fstringPtr2 = \u003CModule\u003E.FName\u002EToString(&fname1, &fstring3);
            string InObjectTypeName;
            // ISSUE: fault handler
            try
            {
              FString fstring4;
              \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, \u003CModule\u003E.FString\u002E\u002A(fstringPtr2));
              // ISSUE: fault handler
              try
              {
                InObjectTypeName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4));
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
            string str2 = Utils.MakeFullName(InObjectTypeName, str1);
            if (\u003CModule\u003E.UStruct\u002EIsChildOf((UStruct*) uclassPtr, (UStruct*) \u003CModule\u003E.UMaterial\u002EStaticClass()) != 0U)
              str2.Contains("_Fallback");
            if (str1.IndexOf(':') == -1)
            {
              FName fname3;
              \u003CModule\u003E.CLRTools\u002EToFName(&fname3, str2);
              FSetElementId fsetElementId;
              \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(InOutCurrentlyExistingAssets, &fsetElementId, fname3, (uint*) 0L);
              ULinkerLoad* ulinkerLoadPtr2 = (ULinkerLoad*) ((IntPtr) InLinker + 456L);
              ULinkerLoad* ulinkerLoadPtr3 = ulinkerLoadPtr2;
              FString fstring4;
              ref FString local = ref fstring4;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              long num3 = (long) __calli((__FnPtr<FString* (IntPtr, FString*)>) *(long*) (*(long*) ulinkerLoadPtr2 + 64L))((FString*) ulinkerLoadPtr3, (IntPtr) ref local);
              // ISSUE: fault handler
              try
              {
                FFilename ffilename;
                FFilename* ffilenamePtr = \u003CModule\u003E.FFilename\u002E\u007Bctor\u007D(&ffilename, (FString*) num3);
                // ISSUE: fault handler
                try
                {
                  FString fstring5;
                  FString* baseFilename = \u003CModule\u003E.FFilename\u002EGetBaseFilename(ffilenamePtr, &fstring5, 1U);
                  // ISSUE: fault handler
                  try
                  {
                    \u003CModule\u003E.FGameAssetDatabase\u002ESetDefaultTagsForAsset(obj0, str2, InObjectTypeName, \u003CModule\u003E.CLRTools\u002EToString(baseFilename), bInIsArchetype, false);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FFilename\u002E\u007Bdtor\u007D), (void*) &ffilename);
                }
                \u003CModule\u003E.FFilename\u002E\u007Bdtor\u007D(&ffilename);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
              ++num1;
            }
          }
        }
label_47:
        ++num2;
      }
      while (num2 < \u003CModule\u003E.TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E\u002ENum((TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E*) ulinkerLoadPtr1));
    }
    return num1;
  }

  internal static unsafe TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* FGameAssetDatabase\u002EGetAllowedClassList()
  {
    if (((int) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA & 1) == 0)
    {
      \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA |= 1U;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A);
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u0040YMXXZ));
      }
      __fault
      {
        \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA &= 4294967294U;
      }
    }
    if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A) == 0)
      \u003CModule\u003E.FGameAssetDatabase\u002EGenerateAllowedClassList(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A);
    return &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A;
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u0040YMXXZ() => \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A);

  internal static unsafe void FGameAssetDatabase\u002EGenerateAllowedClassList(
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* AllowedClassesNames)
  {
    TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
    \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
    // ISSUE: fault handler
    try
    {
      TObjectIterator\u003CUClass\u003E tobjectIteratorUclass1;
      \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u007Bctor\u007D(&tobjectIteratorUclass1, 0U);
      if (\u003CModule\u003E.FObjectIterator\u002E\u002E_N((FObjectIterator*) &tobjectIteratorUclass1))
      {
        do
        {
          int num1 = \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002A(&tobjectIteratorUclass1) == \u003CModule\u003E.UGenericBrowserType_All\u002EStaticClass() ? 1 : 0;
          uint num2 = (uint) (\u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002A(&tobjectIteratorUclass1) == \u003CModule\u003E.UGenericBrowserType_Custom\u002EStaticClass());
          if (num1 == 0 && num2 == 0U && (\u003CModule\u003E.UStruct\u002EIsChildOf((UStruct*) \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002D\u003E(&tobjectIteratorUclass1), (UStruct*) \u003CModule\u003E.UGenericBrowserType\u002EStaticClass()) != 0U && (*(int*) ((IntPtr) \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002D\u003E(&tobjectIteratorUclass1) + 292L) & 1) == 0))
          {
            FName fname;
            UGenericBrowserType* ugenericBrowserTypePtr1 = \u003CModule\u003E.ConstructObject\u003Cclass\u0020UGenericBrowserType\u003E(\u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002A(&tobjectIteratorUclass1), (UObject*) -1L, *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, (EName) 0), 0UL, (UObject*) 0L, (UObject*) 0L, (FObjectInstancingGraph*) 0L);
            if ((IntPtr) ugenericBrowserTypePtr1 != IntPtr.Zero)
            {
              UGenericBrowserType* ugenericBrowserTypePtr2 = ugenericBrowserTypePtr1;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr)>) *(long*) (*(long*) ugenericBrowserTypePtr2 + 616L))((IntPtr) ugenericBrowserTypePtr2);
              int num3 = 0;
              UGenericBrowserType* ugenericBrowserTypePtr3 = (UGenericBrowserType*) ((IntPtr) ugenericBrowserTypePtr1 + 112L);
              if (0 < \u003CModule\u003E.TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E\u002ENum((TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E*) ugenericBrowserTypePtr3))
              {
                do
                {
                  UClass* uclassPtr = (UClass*) *(long*) \u003CModule\u003E.TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029((TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E*) ugenericBrowserTypePtr3, num3);
                  if (\u003CModule\u003E.FName\u002E\u0021\u003D(\u003CModule\u003E.UObject\u002EGetPureName((UObject*) \u003CModule\u003E.UObject\u002EStaticClass()), \u003CModule\u003E.UObject\u002EGetPureName((UObject*) uclassPtr)) != 0U)
                  {
                    FSetElementId fsetElementId;
                    \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(&fdefaultSetAllocator, &fsetElementId, uclassPtr, (uint*) 0L);
                  }
                  ++num3;
                }
                while (num3 < \u003CModule\u003E.TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E\u002ENum((TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E*) ugenericBrowserTypePtr3));
              }
            }
          }
          \u003CModule\u003E.FObjectIterator\u002E\u002B\u002B((FObjectIterator*) &tobjectIteratorUclass1);
        }
        while (\u003CModule\u003E.FObjectIterator\u002E\u002E_N((FObjectIterator*) &tobjectIteratorUclass1));
      }
      TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
      \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
      // ISSUE: fault handler
      try
      {
        TObjectIterator\u003CUClass\u003E tobjectIteratorUclass2;
        \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u007Bctor\u007D(&tobjectIteratorUclass2, 0U);
        if (\u003CModule\u003E.FObjectIterator\u002E\u002E_N((FObjectIterator*) &tobjectIteratorUclass2))
        {
          do
          {
            UClass* uclassPtr1 = \u003CModule\u003E.TObjectIterator\u003CUClass\u003E\u002E\u002A(&tobjectIteratorUclass2);
            TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator;
            \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator, &fdefaultSetAllocator, 0);
            if (\u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator))
            {
              do
              {
                UClass* uclassPtr2 = (UClass*) *(long*) \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
                if (\u003CModule\u003E.UStruct\u002EIsChildOf((UStruct*) uclassPtr1, (UStruct*) uclassPtr2) != 0U)
                  \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(&fdefaultAllocator, &uclassPtr1);
                \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
              }
              while (\u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
            }
            \u003CModule\u003E.FObjectIterator\u002E\u002B\u002B((FObjectIterator*) &tobjectIteratorUclass2);
          }
          while (\u003CModule\u003E.FObjectIterator\u002E\u002E_N((FObjectIterator*) &tobjectIteratorUclass2));
        }
        int num = 0;
        if (0 < \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
        {
          do
          {
            UClass** uclassPtr = \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
            FSetElementId fsetElementId;
            \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(&fdefaultSetAllocator, &fsetElementId, (UClass*) *(long*) uclassPtr, (uint*) 0L);
            ++num;
          }
          while (num < \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
      }
      \u003CModule\u003E.TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
      TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator1;
      \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator1, &fdefaultSetAllocator, 0);
      if (\u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1))
      {
        do
        {
          FString fstring;
          FString* name = \u003CModule\u003E.UObject\u002EGetName((UObject*) *(long*) \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1), &fstring);
          // ISSUE: fault handler
          try
          {
            FSetElementId fsetElementId;
            FName fname;
            \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(AllowedClassesNames, &fsetElementId, *\u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname, \u003CModule\u003E.FString\u002E\u002A(name), (EFindName) 1, 1U), (uint*) 0L);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
          \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1);
        }
        while (\u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator1));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
    }
    \u003CModule\u003E.TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
  }

  internal static unsafe void FGameAssetDatabase\u002ERenameAssetInAllTagMappings(
    [In] FGameAssetDatabase* obj0,
    string OldAssetName,
    string NewAssetName)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) OldAssetName;
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      FName fname1;
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname1, (char*) numPtr1, (EFindName) 1, 1U);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local2 = (byte*) NewAssetName;
      if (local2 != null)
        local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr2 = &^local2)
      {
        FName fname2;
        \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&fname2, (char*) numPtr2, (EFindName) 1, 1U);
        TArray\u003CFName\u002CFDefaultAllocator\u003E fdefaultAllocator;
        \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), fname1, &fdefaultAllocator);
          int num = 0;
          if (0 < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
          {
            do
            {
              \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, &fname2, \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num), true);
              ++num;
            }
            while (num < \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
          }
          \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyAsset(obj0, OldAssetName);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
        }
        \u003CModule\u003E.TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002EFixBrokenAssetNames([In] FGameAssetDatabase* obj0)
  {
    List<string> OutTags = (List<string>) null;
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) string.Format("Fixing up any broken asset names...");
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr1);
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), &fdefaultSetAllocator);
        TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator;
        \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, 0);
        if (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator))
        {
          do
          {
            FString fstring;
            FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator), &fstring);
            string str1;
            // ISSUE: fault handler
            try
            {
              str1 = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
            if (str1.IndexOf(" ") == -1)
            {
              ++num1;
              string OldAssetName = str1;
              string str2 = "";
              // ISSUE: cast to a reference type
              // ISSUE: variable of a reference type
              byte* local2 = (byte*) str1;
              if (local2 != null)
                local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
              // ISSUE: explicit reference operation
              fixed (byte* numPtr2 = &^local2)
              {
                FName InAssetFullNameFName;
                \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&InAssetFullNameFName, (char*) numPtr2, (EFindName) 1, 1U);
                \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullNameFName, (ETagQueryOptions.Type) 1, out OutTags);
                List<string>.Enumerator enumerator = OutTags.GetEnumerator();
                if (enumerator.MoveNext())
                {
                  string current;
                  do
                  {
                    current = enumerator.Current;
                    if (current.Length > 0 && current[0] == '[' && \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current) == ESystemTagType.ObjectType)
                      goto label_13;
                  }
                  while (enumerator.MoveNext());
                  goto label_14;
label_13:
                  str2 = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagValue(current);
                }
label_14:
                if (str2.Length > 0)
                {
                  str1 = str2 + " " + str1;
                  \u003CModule\u003E.FGameAssetDatabase\u002ERenameAssetInAllTagMappings(obj0, OldAssetName, str1);
                  ++num2;
                }
                else
                {
                  \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyAsset(obj0, str1);
                  ++num3;
                }
              }
            }
            \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
          }
          while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      if (num1 <= 0)
        return;
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local3 = (byte*) string.Format("Found {0} broken asset names (fixed {1}, deleted {2})", (object) num1, (object) num2, (object) num3);
      if (local3 != null)
        local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr2 = &^local3)
        \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr2);
    }
  }

  internal static unsafe void FGameAssetDatabase\u002EVerifyIntegrityOfDatabase(
    [In] FGameAssetDatabase* obj0,
    uint bShouldTryToRepair)
  {
    List<string> OutTags = (List<string>) null;
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) string.Format("Checking integrity of game asset database...");
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr1);
      int num1 = 0;
      int num2 = 0;
      List<string> stringList = new List<string>();
      TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), &fdefaultSetAllocator);
        TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator;
        \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, 0);
        if (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator))
        {
          do
          {
            FString fstring;
            FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator), &fstring);
            string str;
            // ISSUE: fault handler
            try
            {
              str = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
            // ISSUE: cast to a reference type
            // ISSUE: variable of a reference type
            byte* local2 = (byte*) str;
            if (local2 != null)
              local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
            // ISSUE: explicit reference operation
            fixed (byte* numPtr2 = &^local2)
            {
              FName InAssetFullNameFName;
              \u003CModule\u003E.FName\u002E\u007Bctor\u007D(&InAssetFullNameFName, (char*) numPtr2, (EFindName) 1, 1U);
              \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullNameFName, (ETagQueryOptions.Type) 4, out OutTags);
              bool flag1 = false;
              bool flag2 = false;
              List<string>.Enumerator enumerator = OutTags.GetEnumerator();
              if (enumerator.MoveNext())
              {
                do
                {
                  string current = enumerator.Current;
                  if ((current.Length <= 0 || current[0] != '[' || \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current) != ESystemTagType.PrivateCollection ? 0 : 1) != 0 || \u003CModule\u003E.FGameAssetDatabase\u002EIsCollectionTag(current, (EGADCollection.Type) 0) || (current.Length <= 0 || current[0] != '['))
                  {
                    FName fname;
                    \u003CModule\u003E.CLRTools\u002EToFName(&fname, current);
                    FGameAssetDatabase* fgameAssetDatabasePtr = (FGameAssetDatabase*) ((IntPtr) obj0 + 168L);
                    if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr, fname) == 0U)
                    {
                      \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("Warning: Tag {0} on asset {1} was missing from the KnownTags set", (object) current, (object) str));
                      ++num1;
                      if (bShouldTryToRepair != 0U)
                      {
                        FSetElementId fsetElementId;
                        \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) fgameAssetDatabasePtr, &fsetElementId, fname, (uint*) 0L);
                        ++num2;
                        \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("       -> Repaired (updated the KnownTags set)"));
                      }
                    }
                  }
                  if (current.Length > 0 && current[0] == '[')
                  {
                    switch (\u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current))
                    {
                      case ESystemTagType.ObjectType:
                        flag1 = true;
                        break;
                      case ESystemTagType.OutermostPackage:
                        flag2 = true;
                        break;
                    }
                  }
                }
                while (enumerator.MoveNext());
                if (flag1)
                  goto label_24;
              }
              \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("    Warning: Asset {0} is missing a default system tag (ObjectType)", (object) str));
              ++num1;
              if (bShouldTryToRepair != 0U)
              {
                ++num2;
                if (!stringList.Contains(str))
                  stringList.Add(str);
                \u003CModule\u003E.CLRTools\u002ELogWarningMessage((EName) 1132, string.Format("       -> Repaired (removed the asset)"));
              }
label_24:
              if (!flag2)
              {
                // ISSUE: cast to a reference type
                // ISSUE: variable of a reference type
                byte* local3 = (byte*) string.Format("    Warning: Asset {0} is missing a default system tag (OutermostPackage)", (object) str);
                if (local3 != null)
                  local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
                // ISSUE: explicit reference operation
                fixed (byte* numPtr3 = &^local3)
                {
                  \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
                  ++num1;
                  if (bShouldTryToRepair != 0U)
                  {
                    ++num2;
                    if (!stringList.Contains(str))
                      stringList.Add(str);
                    // ISSUE: cast to a reference type
                    // ISSUE: variable of a reference type
                    byte* local4 = (byte*) string.Format("       -> Repaired (removed the asset)");
                    if (local4 != null)
                      local4 = (long) (uint) RuntimeHelpers.OffsetToStringData + local4;
                    // ISSUE: explicit reference operation
                    fixed (byte* numPtr4 = &^local4)
                      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr4);
                  }
                }
              }
              \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
            }
          }
          while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
        }
        List<string>.Enumerator enumerator1 = stringList.GetEnumerator();
        if (enumerator1.MoveNext())
        {
          do
          {
            string current = enumerator1.Current;
            \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyAsset(obj0, current);
          }
          while (enumerator1.MoveNext());
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
      if (num1 > 0)
      {
        if (num2 == num1)
        {
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          byte* local2 = (byte*) string.Format("Integrity check complete.  Found and repaired all {0} problems.", (object) num1);
          if (local2 != null)
            local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
          // ISSUE: explicit reference operation
          fixed (byte* numPtr2 = &^local2)
            \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          byte* local2 = (byte*) string.Format("Integrity check complete.  Found {0} problems and repaired {1} of them.", (object) num1, (object) num2);
          if (local2 != null)
            local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
          // ISSUE: explicit reference operation
          fixed (byte* numPtr2 = &^local2)
          {
            \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
            if (bShouldTryToRepair != 0U)
              return;
            // ISSUE: cast to a reference type
            // ISSUE: variable of a reference type
            byte* local3 = (byte*) string.Format("    Use the '-Repair' option to automatically fix these problems.");
            if (local3 != null)
              local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
            // ISSUE: explicit reference operation
            fixed (byte* numPtr3 = &^local3)
              \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
          }
        }
      }
      else
      {
        // ISSUE: cast to a reference type
        // ISSUE: variable of a reference type
        byte* local2 = (byte*) string.Format("Integrity check completed with no warnings.");
        if (local2 != null)
          local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
        // ISSUE: explicit reference operation
        fixed (byte* numPtr2 = &^local2)
          \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ERebuildDefaultTags(
    [In] FGameAssetDatabase* obj0,
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* OutCurrentlyExistingAssets)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) string.Format("Updating database from content packages...");
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr1);
      if (((int) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA & 1) == 0)
      {
        \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA |= 1U;
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A);
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u0040YMXXZ));
        }
        __fault
        {
          \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003F\u0024S74\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404IA &= 4294967294U;
        }
      }
      if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A) == 0)
        \u003CModule\u003E.FGameAssetDatabase\u002EGenerateAllowedClassList(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A);
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local2 = (byte*) string.Format("    {0} object class types will be processed.", (object) \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A));
      if (local2 != null)
        local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr2 = &^local2)
      {
        \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
        FPackageFileCache* gpackageFileCache = \u003CModule\u003E.GPackageFileCache;
        TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator1;
        ref TArray\u003CFString\u002CFDefaultAllocator\u003E local3 = ref fdefaultAllocator1;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        long num1 = (long) __calli((__FnPtr<TArray\u003CFString\u002CFDefaultAllocator\u003E* (IntPtr, TArray\u003CFString\u002CFDefaultAllocator\u003E*)>) *(long*) (*(long*) \u003CModule\u003E.GPackageFileCache + 40L))((TArray\u003CFString\u002CFDefaultAllocator\u003E*) gpackageFileCache, (IntPtr) ref local3);
        TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator2;
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator2, (TArray\u003CFString\u002CFDefaultAllocator\u003E*) num1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator1);
        }
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator1);
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          byte* local4 = (byte*) string.Format("    Found {0} packages.", (object) \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2));
          if (local4 != null)
            local4 = (long) (uint) RuntimeHelpers.OffsetToStringData + local4;
          // ISSUE: explicit reference operation
          fixed (byte* numPtr3 = &^local4)
          {
            \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
            TArray\u003CFString\u002CFDefaultAllocator\u003E* languageExtensions = \u003CModule\u003E.appGetKnownLanguageExtensions();
            int num2 = 0;
            int num3 = 0;
            if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2))
            {
              do
              {
                FFilename ffilename;
                \u003CModule\u003E.FFilename\u002E\u007Bctor\u007D(&ffilename, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator2, num3));
                FString fstring1;
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.FFilename\u002EGetBaseFilename(&ffilename, &fstring1, 1U);
                  // ISSUE: fault handler
                  try
                  {
                    if (!Utils.IsPackageValidForTree(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring1), 0, \u003CModule\u003E.FString\u002ELen(&fstring1))))
                    {
                      int num4 = num3;
                      num3 += -1;
                      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ERemove(&fdefaultAllocator2, num4, 1);
                    }
                    else
                      goto label_24;
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FFilename\u002E\u007Bdtor\u007D), (void*) &ffilename);
                }
                \u003CModule\u003E.FFilename\u002E\u007Bdtor\u007D(&ffilename);
                goto label_36;
label_24:
                // ISSUE: fault handler
                try
                {
                  // ISSUE: fault handler
                  try
                  {
                    int num4 = 0;
                    if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(languageExtensions))
                    {
                      do
                      {
                        if (\u003CModule\u003E.appStricmp((char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D143, \u003CModule\u003E.FString\u002E\u002A(\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(languageExtensions, num4))) != 0)
                        {
                          FString fstring2;
                          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D144);
                          // ISSUE: fault handler
                          try
                          {
                            \u003CModule\u003E.FString\u002E\u002B\u003D(&fstring2, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(languageExtensions, num4));
                            if (\u003CModule\u003E.FString\u002EEndsWith(&fstring1, &fstring2) != 0U)
                            {
                              \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ERemoveSwap(&fdefaultAllocator2, num3, 1);
                              ++num2;
                            }
                          }
                          __fault
                          {
                            // ISSUE: method pointer
                            // ISSUE: cast to a function pointer type
                            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                          }
                          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                        }
                        ++num4;
                      }
                      while (num4 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(languageExtensions));
                    }
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FFilename\u002E\u007Bdtor\u007D), (void*) &ffilename);
                }
                \u003CModule\u003E.FFilename\u002E\u007Bdtor\u007D(&ffilename);
label_36:
                ++num3;
              }
              while (num3 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2));
              if (num2 > 0)
              {
                // ISSUE: cast to a reference type
                // ISSUE: variable of a reference type
                byte* local5 = (byte*) string.Format("    Ignoring {0} packages with localization-related file names.", (object) num2);
                if (local5 != null)
                  local5 = (long) (uint) RuntimeHelpers.OffsetToStringData + local5;
                // ISSUE: explicit reference operation
                fixed (byte* numPtr4 = &^local5)
                  \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr4);
              }
            }
            int num5 = 0;
            int num6 = 0;
            \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EEmpty(OutCurrentlyExistingAssets, 0);
            int num7 = 0;
            if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2))
            {
              do
              {
                FString* fstringPtr1 = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator2, num7);
                FString fstring1;
                FString* fstringPtr2 = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D146, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D145, (char*) 0L);
                // ISSUE: fault handler
                try
                {
                  FString fstring2;
                  FString* fstringPtr3 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(&fstring2, \u003CModule\u003E.FormatLocalizedString\u003Cwchar_t\u0020const\u0020\u002A\u003E(\u003CModule\u003E.TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(\u003CModule\u003E.FString\u002EGetCharArray(fstringPtr2)), \u003CModule\u003E.FString\u002E\u002A(fstringPtr1)), \u003CModule\u003E.FString\u002E\u002A(fstringPtr1));
                  // ISSUE: fault handler
                  try
                  {
                    int num4 = (int) \u003CModule\u003E.FFeedbackContext\u002EStatusUpdatef(\u003CModule\u003E.GWarn, num7, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2), \u003CModule\u003E.FString\u002E\u002A(fstringPtr3));
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
                \u003CModule\u003E.UObject\u002EBeginLoad();
                ULinkerLoad* packageLinker = \u003CModule\u003E.UObject\u002EGetPackageLinker((UPackage*) 0L, \u003CModule\u003E.FString\u002E\u002A(fstringPtr1), 8322U, (UPackageMap*) 0L, (FGuid*) 0L);
                \u003CModule\u003E.UObject\u002EEndLoad((char*) 0L);
                if ((IntPtr) packageLinker != IntPtr.Zero)
                {
                  int num4 = \u003CModule\u003E.FGameAssetDatabase\u002EGatherAssetsFromPackageLinker(obj0, packageLinker, &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FAllowedClassNames\u0040\u003F1\u003F\u003FGetAllowedClassList\u0040FGameAssetDatabase\u0040\u0040SAAEBV\u003F\u0024TSet\u0040VFName\u0040\u0040U\u003F\u0024DefaultKeyFuncs\u0040VFName\u0040\u0040\u00240A\u0040\u0040\u0040VFDefaultSetAllocator\u0040\u0040\u0040\u0040XZ\u00404V3\u0040A, OutCurrentlyExistingAssets);
                  if (num4 > 0)
                  {
                    ++num6;
                    num5 += num4;
                  }
                }
                if (num7 % 16 == 0)
                  \u003CModule\u003E.UObject\u002ECollectGarbage(288230376151711744UL, 1U);
                ++num7;
              }
              while (num7 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2));
            }
            // ISSUE: cast to a reference type
            // ISSUE: variable of a reference type
            byte* local6 = (byte*) string.Format("    Found a total of {0} assets in {1} packages.", (object) num5, (object) num6);
            if (local6 != null)
              local6 = (long) (uint) RuntimeHelpers.OffsetToStringData + local6;
            // ISSUE: explicit reference operation
            fixed (byte* numPtr4 = &^local6)
              \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr4);
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator2);
        }
        \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator2);
      }
    }
  }

  internal static unsafe void FGameAssetDatabase\u002ECheckForGhostAssets(
    [In] FGameAssetDatabase* obj0,
    TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* CurrentlyExistingAssets,
    FGameAssetDatabaseStartupConfig* InConfig)
  {
    List<string> OutTags = (List<string>) null;
    string str = (string) null;
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local1 = (byte*) string.Format("Checking for assets in the database that don't actually exist on disk...");
    if (local1 != null)
      local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr1 = &^local1)
    {
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr1);
      uint num = 0;
      TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E fdefaultSetAllocator;
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultSetAllocator);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys((TSetMap\u003CFName\u002CFName\u003E*) ((IntPtr) obj0 + 96L), &fdefaultSetAllocator);
        TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator tconstIterator;
        \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(&tconstIterator, (TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator, 0);
        if (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator))
        {
          do
          {
            FName* fnamePtr = \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
            if (\u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(CurrentlyExistingAssets, *fnamePtr) == 0U)
            {
              FString fstring;
              FString* fstringPtr = \u003CModule\u003E.FName\u002EToString(fnamePtr, &fstring);
              string InAssetFullName;
              // ISSUE: fault handler
              try
              {
                InAssetFullName = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
              bool flag = false;
              StringBuilder stringBuilder = new StringBuilder();
              \u003CModule\u003E.FGameAssetDatabase\u002EQueryTagsForAsset(obj0, InAssetFullName, (ETagQueryOptions.Type) 4, out OutTags);
              List<string>.Enumerator enumerator = OutTags.GetEnumerator();
              if (enumerator.MoveNext())
              {
                do
                {
                  string current = enumerator.Current;
                  if (current.Length > 0 && current[0] == '[' && \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagType(current) == ESystemTagType.Ghost)
                  {
                    flag = true;
                    str = \u003CModule\u003E.FGameAssetDatabase\u002EGetSystemTagValue(current);
                  }
                  if (stringBuilder.Length > 0)
                    stringBuilder.Append(", ");
                  stringBuilder.Append(current);
                }
                while (enumerator.MoveNext());
              }
              if (*(int*) ((IntPtr) InConfig + 24L) != 0)
              {
                // ISSUE: cast to a reference type
                // ISSUE: variable of a reference type
                byte* local2 = (byte*) string.Format("    Purging non-existent asset: {0} (Tags: {1})", (object) InAssetFullName, (object) stringBuilder.ToString());
                if (local2 != null)
                  local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
                // ISSUE: explicit reference operation
                fixed (byte* numPtr2 = &^local2)
                {
                  \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
                  \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyAsset(obj0, InAssetFullName);
                }
              }
              else
              {
                ValueType now = (ValueType) DateTime.Now;
                if (flag)
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: variable of a reference type
                  byte* local2 = (byte*) string.Format("    Warning: Non-existent 'Ghost' asset found: {0} (Tags: {1})", (object) InAssetFullName, (object) stringBuilder.ToString());
                  if (local2 != null)
                    local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
                  // ISSUE: explicit reference operation
                  fixed (byte* numPtr2 = &^local2)
                  {
                    \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
                    ulong uint64 = Convert.ToUInt64(str);
                    ValueType valueType1 = (ValueType) new DateTime();
                    (DateTime) valueType1 = new DateTime((long) uint64);
                    ValueType valueType2 = (ValueType) ((DateTime) valueType1).AddDays((double) GADDefs.DeleteGhostAssetsOlderThanDays);
                    if (((DateTime) now).Ticks > ((DateTime) valueType2).Ticks)
                    {
                      \u003CModule\u003E.FGameAssetDatabase\u002ELocalDestroyAsset(obj0, InAssetFullName);
                      // ISSUE: cast to a reference type
                      // ISSUE: variable of a reference type
                      byte* local3 = (byte*) string.Format("       -> Deleted this expired 'Ghost' asset");
                      if (local3 != null)
                        local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
                      // ISSUE: explicit reference operation
                      fixed (byte* numPtr3 = &^local3)
                        \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
                    }
                    else
                    {
                      // ISSUE: cast to a reference type
                      // ISSUE: variable of a reference type
                      byte* local3 = (byte*) string.Format("       -> 'Ghost' asset will expire in {0} days", (object) (new TimeSpan(((DateTime) valueType2).Ticks - ((DateTime) now).Ticks).Days + 1));
                      if (local3 != null)
                        local3 = (long) (uint) RuntimeHelpers.OffsetToStringData + local3;
                      // ISSUE: explicit reference operation
                      fixed (byte* numPtr3 = &^local3)
                        \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr3);
                    }
                  }
                }
                else
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: variable of a reference type
                  byte* local2 = (byte*) string.Format("    Warning: Non-existent asset found and tagged as 'Ghost': {0} (Tags: {1})", (object) InAssetFullName, (object) stringBuilder.ToString());
                  if (local2 != null)
                    local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
                  // ISSUE: explicit reference operation
                  fixed (byte* numPtr2 = &^local2)
                  {
                    \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
                    str = ((DateTime) now).Ticks.ToString();
                    \u003CModule\u003E.FGameAssetDatabase\u002EAddTagMapping(obj0, InAssetFullName, '['.ToString() + GADDefs.SystemTagTypeNames[7] + (object) ']' + str, true);
                  }
                }
              }
              ++num;
            }
            \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator);
          }
          while (\u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E*) &tconstIterator));
          if (num > 0U)
          {
            // ISSUE: cast to a reference type
            // ISSUE: variable of a reference type
            byte* local2 = (byte*) string.Format("Warning: {0} assets found in database do not exist on disk!", (object) num);
            if (local2 != null)
              local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
            // ISSUE: explicit reference operation
            fixed (byte* numPtr2 = &^local2)
            {
              \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
              goto label_41;
            }
          }
        }
        // ISSUE: cast to a reference type
        // ISSUE: variable of a reference type
        byte* local4 = (byte*) string.Format("All {0} assets were found on disk.", (object) \u003CModule\u003E.TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ENum((TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E*) &fdefaultSetAllocator));
        if (local4 != null)
          local4 = (long) (uint) RuntimeHelpers.OffsetToStringData + local4;
        // ISSUE: explicit reference operation
        fixed (byte* numPtr2 = &^local4)
          \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 1132, (char*) numPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultSetAllocator);
      }
label_41:
      \u003CModule\u003E.TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultSetAllocator);
    }
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGColorPickerFrame\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.GColorPickerFrame);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGColorPickerFrame\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGColorPickerFrame\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.GColorPickerFrame);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGColorPickerPanel\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.GColorPickerPanel);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGColorPickerPanel\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGColorPickerPanel\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.GColorPickerPanel);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGPickColorStruct\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D(&\u003CModule\u003E.GPickColorStruct);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGPickColorStruct\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGPickColorStruct\u0040\u0040YMXXZ() => \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D(&\u003CModule\u003E.GPickColorStruct);

  internal static unsafe ColorPickerResults PickColorWPF(
    FPickColorStruct* ColorStruct)
  {
    ColorPickerResults colorPickerResults = (ColorPickerResults) 1;
    if (\u003CModule\u003E.GIsEditor != 0U)
    {
      WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
      if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame) == null)
      {
        FString fstring1;
        FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D153, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D152, (char*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            InSettings.WindowTitle = str;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        FString fstring3;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D154);
        // ISSUE: fault handler
        try
        {
          string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring3), 0, \u003CModule\u003E.FString\u002ELen(&fstring3));
          InSettings.WindowHelpURL = str;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D155);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.GColorPickerFrame, new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring4));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
        FString fstring5;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring5, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D156);
        // ISSUE: fault handler
        try
        {
          string InXamlName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring5), 0, \u003CModule\u003E.FString\u002ELen(&fstring5));
          \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.GColorPickerPanel, new MColorPickerPanel(&\u003CModule\u003E.GPickColorStruct, InXamlName, 0U));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
      }
      else
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerFrame).SaveLayout();
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerFrame).Raise();
      \u003CModule\u003E.FPickColorStruct\u002E\u003D(&\u003CModule\u003E.GPickColorStruct, ColorStruct);
      \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).BindData();
      \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).SetEnabled(1U);
      if (*(int*) ((IntPtr) ColorStruct + 100L) != 0)
      {
        colorPickerResults = (ColorPickerResults) \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerFrame).SetContentAndShowModal((MWPFPanel) \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel), 1);
        \u003CModule\u003E.CloseColorPickers();
      }
      else
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerFrame).SetContentAndShow((MWPFPanel) \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel));
      if (InSettings is IDisposable disposable2)
        disposable2.Dispose();
    }
    return colorPickerResults;
  }

  internal static unsafe FPickColorStruct* FPickColorStruct\u002E\u003D(
    [In] FPickColorStruct* obj0,
    FPickColorStruct* _param1)
  {
    *(long*) obj0 = *(long*) _param1;
    *(long*) ((IntPtr) obj0 + 8L) = *(long*) ((IntPtr) _param1 + 8L);
    \u003CModule\u003E.TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D((TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 16L), (TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) _param1 + 16L));
    \u003CModule\u003E.TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D((TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 32L), (TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) _param1 + 32L));
    \u003CModule\u003E.TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D((TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 48L), (TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) _param1 + 48L));
    \u003CModule\u003E.TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u003D((TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 64L), (TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E*) ((IntPtr) _param1 + 64L));
    \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D((TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 80L), (TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) _param1 + 80L));
    *(int*) ((IntPtr) obj0 + 96L) = *(int*) ((IntPtr) _param1 + 96L);
    *(int*) ((IntPtr) obj0 + 100L) = *(int*) ((IntPtr) _param1 + 100L);
    *(int*) ((IntPtr) obj0 + 104L) = *(int*) ((IntPtr) _param1 + 104L);
    return obj0;
  }

  internal static unsafe void TickColorPickerWPF()
  {
    uint InIndex = 0;
    if (0U >= MColorPickerPanel.GetNumColorPickerPanels())
      return;
    do
    {
      MColorPickerPanel staticColorPicker = MColorPickerPanel.GetStaticColorPicker(InIndex);
      MWPFFrame parentFrame = staticColorPicker.GetParentFrame();
      if (staticColorPicker != null && parentFrame != null && \u003CModule\u003E.IsWindowVisible(parentFrame.GetWindowHandle()) != 0)
        staticColorPicker.Tick();
      ++InIndex;
    }
    while (InIndex < MColorPickerPanel.GetNumColorPickerPanels());
  }

  internal static unsafe void UnBindColorPickers(wxWindow* InWindowToUnbindFrom)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame) == null || \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel) == null || ^(long&) ref \u003CModule\u003E.GPickColorStruct != (IntPtr) InWindowToUnbindFrom && \u003CModule\u003E.TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002EContainsItem((TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) &\u003CModule\u003E.GPickColorStruct + 16), &InWindowToUnbindFrom) == 0U)
      return;
    FPickColorStruct fpickColorStruct;
    FPickColorStruct* fpickColorStructPtr = \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D(&fpickColorStruct);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FPickColorStruct\u002E\u003D(&\u003CModule\u003E.GPickColorStruct, fpickColorStructPtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) &fpickColorStruct);
    }
    \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D(&fpickColorStruct);
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).BindData();
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).SetEnabled(0U);
    \u003CModule\u003E.CloseColorPickers();
  }

  internal static unsafe void UnBindColorPickers(FPropertyNode* InPropertyNodeToUnbindFrom)
  {
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame) == null || \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel) == null || ^(long&) ((IntPtr) &\u003CModule\u003E.GPickColorStruct + 8) != (IntPtr) InPropertyNodeToUnbindFrom)
      return;
    FPickColorStruct fpickColorStruct;
    FPickColorStruct* fpickColorStructPtr = \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D(&fpickColorStruct);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FPickColorStruct\u002E\u003D(&\u003CModule\u003E.GPickColorStruct, fpickColorStructPtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) &fpickColorStruct);
    }
    \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D(&fpickColorStruct);
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).BindData();
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).SetEnabled(0U);
    \u003CModule\u003E.CloseColorPickers();
  }

  internal static unsafe void UnBindColorPickers(UObject* InObject)
  {
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame) == null || \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel) == null || \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EContainsItem((TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) &\u003CModule\u003E.GPickColorStruct + 80), &InObject) == 0U)
      return;
    FPickColorStruct fpickColorStruct;
    FPickColorStruct* fpickColorStructPtr = \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D(&fpickColorStruct);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FPickColorStruct\u002E\u003D(&\u003CModule\u003E.GPickColorStruct, fpickColorStructPtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) &fpickColorStruct);
    }
    \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D(&fpickColorStruct);
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).BindData();
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GColorPickerPanel).SetEnabled(0U);
    \u003CModule\u003E.CloseColorPickers();
  }

  internal static unsafe void CloseColorPickers()
  {
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame) == null || \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&\u003CModule\u003E.GColorPickerPanel)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.GColorPickerFrame)?.Dispose();
    IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
    gcroot\u003CMColorPickerPanel\u0020\u005E\u003E mcolorPickerPanel1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref mcolorPickerPanel1 = (long) num1.ToPointer();
    // ISSUE: fault handler
    try
    {
      MColorPickerPanel mcolorPickerPanel2 = \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(&mcolorPickerPanel1);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ((GCHandle) new IntPtr((void*) ^(long&) ref \u003CModule\u003E.GColorPickerPanel)).Target = (object) mcolorPickerPanel2;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &mcolorPickerPanel1);
    }
    \u003CModule\u003E.gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&mcolorPickerPanel1);
    IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
    gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref gcrootMwpfFrame = (long) num2.ToPointer();
    // ISSUE: fault handler
    try
    {
      MWPFFrame mwpfFrame = \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ((GCHandle) new IntPtr((void*) ^(long&) ref \u003CModule\u003E.GColorPickerFrame)).Target = (object) mwpfFrame;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
    }
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
  }

  internal static unsafe void FImportColorsScreen\u002EDisplayImportColorsScreen()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FImportColorsScreen* fimportColorsScreenPtr1 = (FImportColorsScreen*) \u003CModule\u003E.@new(24UL);
      FImportColorsScreen* fimportColorsScreenPtr2;
      // ISSUE: fault handler
      try
      {
        fimportColorsScreenPtr2 = (IntPtr) fimportColorsScreenPtr1 == IntPtr.Zero ? (FImportColorsScreen*) 0L : \u003CModule\u003E.FImportColorsScreen\u002E\u007Bctor\u007D(fimportColorsScreenPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fimportColorsScreenPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA = fimportColorsScreenPtr2;
    }
    FImportColorsScreen* colorsScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA;
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) colorsScreen0PeaV1Ea + 8L)).SetContentAndShow((MWPFPanel) \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMImportColorsScreenPanel\u0040\u0040((gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E*) ((IntPtr) colorsScreen0PeaV1Ea + 16L)));
  }

  internal static unsafe void FImportColorsScreen\u002EShutdown()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
    {
      FImportColorsScreen* colorsScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA)((uint) colorsScreen0PeaV1Ea, new IntPtr(1));
    }
    \u003CModule\u003E.\u003FInstance\u0040FImportColorsScreen\u0040\u00400PEAV1\u0040EA = (FImportColorsScreen*) 0L;
  }

  internal static unsafe FImportColorsScreen* FImportColorsScreen\u002E\u007Bctor\u007D(
    [In] FImportColorsScreen* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FImportColorsScreen\u0040\u00406B\u0040;
      FImportColorsScreen* fimportColorsScreenPtr1 = (FImportColorsScreen*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fimportColorsScreenPtr1);
      // ISSUE: fault handler
      try
      {
        FImportColorsScreen* fimportColorsScreenPtr2 = (FImportColorsScreen*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E*) fimportColorsScreenPtr2);
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
          FImportColorsScreen* fimportColorsScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) fimportColorsScreenPtr3);
          FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
          FImportColorsScreen* fimportColorsScreenPtr4 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) fimportColorsScreenPtr4);
          WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
          InSettings.WindowTitle = \u003CModule\u003E.CLRTools\u002ELocalizeString("ImportColorsWindow_WindowTitle", (string) null, (string) null, (string) null);
          InSettings.bCenterWindow = 1U;
          InSettings.bUseSaveLayout = 0U;
          FString fstring1;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D158);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fimportColorsScreenPtr1, new MWPFFrame((wxWindow*) 0L, InSettings, &fstring1));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D159);
          // ISSUE: fault handler
          try
          {
            string InXaml = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E*) fimportColorsScreenPtr2, new MImportColorsScreenPanel(InXaml));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          if (InSettings is IDisposable disposable6)
            disposable6.Dispose();
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FImportColorsScreen\u002E__vecDelDtor(
    [In] FImportColorsScreen* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FImportColorsScreen* fimportColorsScreenPtr = (FImportColorsScreen*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24UL, *(int*) fimportColorsScreenPtr, (__FnPtr<void (void*)>) __methodptr(FImportColorsScreen\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fimportColorsScreenPtr);
      return (void*) fimportColorsScreenPtr;
    }
    \u003CModule\u003E.FImportColorsScreen\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FImportColorsScreen\u002E\u007Bdtor\u007D([In] FImportColorsScreen* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FImportColorsScreen\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FImportColorsScreen* fimportColorsScreenPtr1;
      // ISSUE: fault handler
      try
      {
        FImportColorsScreen* fimportColorsScreenPtr2;
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
          FImportColorsScreen* fimportColorsScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) fimportColorsScreenPtr3);
          fimportColorsScreenPtr2 = (FImportColorsScreen*) ((IntPtr) obj0 + 16L);
          if (\u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMImportColorsScreenPanel\u0040\u0040((gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E*) fimportColorsScreenPtr2) is IDisposable disposable6)
            disposable6.Dispose();
          fimportColorsScreenPtr1 = (FImportColorsScreen*) ((IntPtr) obj0 + 8L);
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fimportColorsScreenPtr1)?.Dispose();
          IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E colorsScreenPanel;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref colorsScreenPanel = (long) num1.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) fimportColorsScreenPtr2)).Target = (object) \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMImportColorsScreenPanel\u0040\u0040(&colorsScreenPanel);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &colorsScreenPanel);
          }
          \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&colorsScreenPanel);
          IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref gcrootMwpfFrame = (long) num2.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) fimportColorsScreenPtr1)).Target = (object) \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
          }
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        \u003CModule\u003E.gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E*) fimportColorsScreenPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fimportColorsScreenPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FImportColorsScreen\u002ESend(
    [In] FImportColorsScreen* obj0,
    ECallbackEventType Event)
  {
    if (Event != (ECallbackEventType) 65)
    {
      if (Event != (ECallbackEventType) 66)
        return;
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 1);
    }
    else
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 0);
  }

  internal static unsafe FMeshPaintWindow* FMeshPaintWindow\u002ECreateMeshPaintWindow(
    FEdModeMeshPaint* InMeshPaintSystem)
  {
    FMeshPaintWindow* fmeshPaintWindowPtr1 = (FMeshPaintWindow*) \u003CModule\u003E.@new(240UL);
    FMeshPaintWindow* fmeshPaintWindowPtr2;
    // ISSUE: fault handler
    try
    {
      fmeshPaintWindowPtr2 = (IntPtr) fmeshPaintWindowPtr1 == IntPtr.Zero ? (FMeshPaintWindow*) 0L : \u003CModule\u003E.FMeshPaintWindow\u002E\u007Bctor\u007D(fmeshPaintWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) fmeshPaintWindowPtr1);
    }
    if (\u003CModule\u003E.FMeshPaintWindow\u002EInitMeshPaintWindow(fmeshPaintWindowPtr2, InMeshPaintSystem) != 0U)
      return fmeshPaintWindowPtr2;
    if ((IntPtr) fmeshPaintWindowPtr2 != IntPtr.Zero)
    {
      FMeshPaintWindow* fmeshPaintWindowPtr3 = fmeshPaintWindowPtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) fmeshPaintWindowPtr2)((uint) fmeshPaintWindowPtr3, new IntPtr(1));
    }
    return (FMeshPaintWindow*) 0L;
  }

  internal static unsafe FMeshPaintWindow* FMeshPaintWindow\u002E\u007Bctor\u007D(
    [In] FMeshPaintWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FMeshPaintWindow\u0040\u00406B\u0040;
      *(long*) ((IntPtr) obj0 + 8L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
      // ISSUE: fault handler
      try
      {
        *(long*) ((IntPtr) obj0 + 16L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 24L));
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FPickColorStruct\u002E\u007Bctor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 132L));
            // ISSUE: fault handler
            try
            {
              FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr1 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) fmeshPaintWindowPtr1);
              FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr2 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) fmeshPaintWindowPtr2);
              FCallbackEventObserver* gcallbackEvent3 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr3 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent3, (ECallbackEventType) 36, (IntPtr) fmeshPaintWindowPtr3);
              FCallbackEventObserver* gcallbackEvent4 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr4 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent4, (ECallbackEventType) 58, (IntPtr) fmeshPaintWindowPtr4);
              FCallbackEventObserver* gcallbackEvent5 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr5 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent5, (ECallbackEventType) 51, (IntPtr) fmeshPaintWindowPtr5);
              FCallbackEventObserver* gcallbackEvent6 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr6 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent6, (ECallbackEventType) 50, (IntPtr) fmeshPaintWindowPtr6);
              FCallbackEventObserver* gcallbackEvent7 = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr7 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent7, (ECallbackEventType) 32, (IntPtr) fmeshPaintWindowPtr7);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 132L));
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FMeshPaintWindow\u002E__vecDelDtor(
    [In] FMeshPaintWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FMeshPaintWindow* fmeshPaintWindowPtr = (FMeshPaintWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 240UL, *(int*) fmeshPaintWindowPtr, (__FnPtr<void (void*)>) __methodptr(FMeshPaintWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fmeshPaintWindowPtr);
      return (void*) fmeshPaintWindowPtr;
    }
    \u003CModule\u003E.FMeshPaintWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FMeshPaintWindow\u002E\u007Bdtor\u007D([In] FMeshPaintWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FMeshPaintWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FMeshPaintWindow* fmeshPaintWindowPtr1;
      // ISSUE: fault handler
      try
      {
        FMeshPaintWindow* fmeshPaintWindowPtr2;
        // ISSUE: fault handler
        try
        {
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
              FMeshPaintWindow* fmeshPaintWindowPtr3 = obj0;
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) fmeshPaintWindowPtr3);
              fmeshPaintWindowPtr1 = (FMeshPaintWindow*) ((IntPtr) obj0 + 8L);
              auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* gcrootMmeshPaintFramePtr = (auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1;
              if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr) != null)
              {
                if ((\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr) != null ? 1 : 0) != 0)
                  \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr)?.Dispose();
                \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr, (MMeshPaintFrame) null);
              }
              fmeshPaintWindowPtr2 = (FMeshPaintWindow*) ((IntPtr) obj0 + 16L);
              auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* mmeshPaintWindowPtr = (auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2;
              if (\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr) != null)
              {
                if ((\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr) != null ? 1 : 0) != 0)
                  \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr)?.Dispose();
                \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr, (MMeshPaintWindow) null);
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 132L));
            }
            \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 132L));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FPickColorStruct\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
          }
          \u003CModule\u003E.FPickColorStruct\u002E\u007Bdtor\u007D((FPickColorStruct*) ((IntPtr) obj0 + 24L));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* mmeshPaintWindowPtr1 = (auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2;
        // ISSUE: fault handler
        try
        {
          if ((\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr1) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr1)?.Dispose();
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) mmeshPaintWindowPtr1);
        }
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) mmeshPaintWindowPtr1);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* gcrootMmeshPaintFramePtr1 = (auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1;
      // ISSUE: fault handler
      try
      {
        if ((\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr1) != null ? 1 : 0) != 0)
          \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr1)?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) gcrootMmeshPaintFramePtr1);
      }
      \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) gcrootMmeshPaintFramePtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe uint FMeshPaintWindow\u002EInitMeshPaintWindow(
    [In] FMeshPaintWindow* obj0,
    FEdModeMeshPaint* InMeshPaintSystem)
  {
    WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
    InSettings.WindowTitle = \u003CModule\u003E.CLRTools\u002ELocalizeString("MeshPaintWindow_WindowTitle", (string) null, (string) null, (string) null);
    InSettings.bShowCloseButton = 1U;
    FString fstring1;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D160);
    FMeshPaintWindow* fmeshPaintWindowPtr1;
    // ISSUE: fault handler
    try
    {
      MMeshPaintFrame _new_ptr = new MMeshPaintFrame(InMeshPaintSystem, (wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring1);
      fmeshPaintWindowPtr1 = (FMeshPaintWindow*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1, _new_ptr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FLinearColor* flinearColorPtr1 = (FLinearColor*) ((IntPtr) \u003CModule\u003E.FMeshPaintSettings\u002EGet() + 32L);
    \u003CModule\u003E.TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem((TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 72L), &flinearColorPtr1);
    FLinearColor* flinearColorPtr2 = (FLinearColor*) ((IntPtr) \u003CModule\u003E.FMeshPaintSettings\u002EGet() + 48L);
    \u003CModule\u003E.TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem((TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 180L), &flinearColorPtr2);
    FString fstring2;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D161);
    FMeshPaintWindow* fmeshPaintWindowPtr2;
    // ISSUE: fault handler
    try
    {
      string XamlFileName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
      MMeshPaintWindow _new_ptr = new MMeshPaintWindow((MWPFFrame) \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1), InMeshPaintSystem, XamlFileName, (FPickColorStruct*) ((IntPtr) obj0 + 24L), (FPickColorStruct*) ((IntPtr) obj0 + 132L));
      fmeshPaintWindowPtr2 = (FMeshPaintWindow*) ((IntPtr) obj0 + 16L);
      \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2, _new_ptr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    MMeshPaintWindow mmeshPaintWindow = \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2);
    \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1).SetContentAndShow((MWPFPanel) mmeshPaintWindow);
    return 1;
  }

  internal static unsafe void FMeshPaintWindow\u002ERefreshAllProperties([In] FMeshPaintWindow* obj0)
  {
    FMeshPaintWindow* fmeshPaintWindowPtr = (FMeshPaintWindow*) ((IntPtr) obj0 + 16L);
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).RefreshTextureTargetsList();
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).UpdateUVChannels();
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).RefreshAllProperties();
  }

  internal static unsafe uint FMeshPaintWindow\u002EIsMouseOverWindow([In] FMeshPaintWindow* obj0) => \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)) != null && ((UIElement) \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetRootVisual()).IsMouseOver ? 1U : 0U;

  internal static unsafe void FMeshPaintWindow\u002ESend(
    [In] FMeshPaintWindow* obj0,
    ECallbackEventType Event)
  {
    FMeshPaintWindow* fmeshPaintWindowPtr1 = (FMeshPaintWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1) == null)
      return;
    FrameworkElement rootVisual = (FrameworkElement) \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) fmeshPaintWindowPtr1).GetRootVisual();
    switch (Event)
    {
      case (ECallbackEventType) 32:
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).SaveSettingsForSelectedActors();
        break;
      case (ECallbackEventType) 36:
        FMeshPaintWindow* fmeshPaintWindowPtr2 = (FMeshPaintWindow*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2).RefreshTextureTargetsList();
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2).UpdateUVChannels();
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr2).RefreshAllProperties();
        break;
      case (ECallbackEventType) 65:
        rootVisual.IsEnabled = false;
        break;
      case (ECallbackEventType) 66:
        rootVisual.IsEnabled = true;
        break;
    }
  }

  internal static unsafe void FMeshPaintWindow\u002ESend(
    [In] FMeshPaintWindow* obj0,
    ECallbackEventType Event,
    UObject* EventObject)
  {
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)) == null || Event != (ECallbackEventType) 58)
      return;
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).CommitPaintChanges(false);
  }

  internal static unsafe void FMeshPaintWindow\u002ESend(
    [In] FMeshPaintWindow* obj0,
    ECallbackEventType Event,
    FViewport* EventViewport,
    uint InMessage)
  {
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)) == null || Event != (ECallbackEventType) 50)
      return;
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).RestoreRenderTargets();
  }

  internal static unsafe void FMeshPaintWindow\u002ESend(
    [In] FMeshPaintWindow* obj0,
    ECallbackEventType InType,
    FString* InString,
    UObject* InObject)
  {
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)) == null || InType != (ECallbackEventType) 51)
      return;
    FMeshPaintWindow* fmeshPaintWindowPtr = (FMeshPaintWindow*) ((IntPtr) obj0 + 16L);
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).RefreshTextureTargetsList();
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).UpdateUVChannels();
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) fmeshPaintWindowPtr).RefreshAllProperties();
  }

  internal static unsafe void FMeshPaintWindow\u002ERefreshTextureTargetListProperties(
    [In] FMeshPaintWindow* obj0)
  {
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).RefreshTextureTargetListProperties();
  }

  internal static unsafe void FMeshPaintWindow\u002ETransactionBufferSizeBreech(
    [In] FMeshPaintWindow* obj0,
    [MarshalAs(UnmanagedType.U1)] bool bIsBreeched)
  {
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).IsBreechingUndoBuffer = bIsBreeched;
  }

  internal static unsafe void FPerforceSourceControlProvider\u002EInit(
    [In] FPerforceSourceControlProvider* obj0)
  {
    \u003CModule\u003E.FPerforceSourceControlProvider\u002ELoadSettings(obj0);
    if ((*(int*) ((IntPtr) obj0 + 8L) & 4) != 0)
      return;
    FPerforceNET fperforceNet1 = new FPerforceNET(obj0);
    FPerforceNET fperforceNet2;
    // ISSUE: fault handler
    try
    {
      fperforceNet2 = fperforceNet1;
      FString fstring;
      fperforceNet2.UpdateBranchName(&fstring);
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    }
    __fault
    {
      fperforceNet2.Dispose();
    }
    fperforceNet2.Dispose();
  }

  internal static unsafe uint FPerforceSourceControlProvider\u002EExecuteCommand(
    [In] FPerforceSourceControlProvider* obj0,
    FSourceControlCommand* InCommand)
  {
    if ((*(int*) ((IntPtr) obj0 + 8L) & 4) != 0)
      return 0;
    FPerforceNET fperforceNet1 = new FPerforceNET(obj0);
    FPerforceNET fperforceNet2;
    uint num1;
    // ISSUE: fault handler
    try
    {
      fperforceNet2 = fperforceNet1;
      uint num2 = fperforceNet2.ExecuteCommand(InCommand);
      *(int*) ((IntPtr) InCommand + 16L) = (int) num2;
      num1 = num2;
    }
    __fault
    {
      fperforceNet2.Dispose();
    }
    fperforceNet2.Dispose();
    return num1;
  }

  internal static unsafe void FPerforceSourceControlProvider\u002ERespondToCommandErrorType(
    [In] FPerforceSourceControlProvider* obj0,
    FSourceControlCommand* InCommand)
  {
    switch (*(int*) ((IntPtr) InCommand + 20L))
    {
      case 0:
        *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) | 1;
        break;
      case 1:
        *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) & -2;
        break;
    }
  }

  internal static unsafe void FPerforceSourceControlProvider\u002ELoadSettings(
    [In] FPerforceSourceControlProvider* obj0)
  {
    FPerforceSourceControlProvider* sourceControlProviderPtr1 = (FPerforceSourceControlProvider*) ((IntPtr) obj0 + 12L);
    uint num1 = \u003CModule\u003E.Parse(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D243, (FString*) sourceControlProviderPtr1, 1U);
    FPerforceSourceControlProvider* sourceControlProviderPtr2 = (FPerforceSourceControlProvider*) ((IntPtr) obj0 + 28L);
    uint num2 = num1 | \u003CModule\u003E.Parse(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D244, (FString*) sourceControlProviderPtr2, 1U);
    FPerforceSourceControlProvider* sourceControlProviderPtr3 = (FPerforceSourceControlProvider*) ((IntPtr) obj0 + 44L);
    uint num3 = num2 | \u003CModule\u003E.Parse(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D245, (FString*) sourceControlProviderPtr3, 1U);
    FPerforceSourceControlProvider* sourceControlProviderPtr4 = (FPerforceSourceControlProvider*) ((IntPtr) obj0 + 60L);
    uint num4 = (uint) (((int) \u003CModule\u003E.Parse(\u003CModule\u003E.appCmdLine(), (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D246, (FString*) sourceControlProviderPtr4, 1U) | (int) num3) == 0);
    *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) & -5;
    *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) | ((int) num4 & 1) << 2;
    if ((*(int*) ((IntPtr) obj0 + 8L) & 4) != 0)
    {
      uint num5;
      int num6 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D248, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D247, &num5, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      uint num7 = num5 == 0U || \u003CModule\u003E.GIsUnattended != 0U ? 0U : 1U;
      *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) & -5;
      *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) | ((int) num7 & 1) << 2;
      int num8 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D250, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D249, (FString*) sourceControlProviderPtr1, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      int num9 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D252, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D251, (FString*) sourceControlProviderPtr2, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      int num10 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetString(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D254, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D253, (FString*) sourceControlProviderPtr3, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    }
    uint num11 = (uint) *(int*) ((IntPtr) obj0 + 8L);
    if (((int) num11 & 4) == 0)
    {
      uint num5 = num11 >> 3 & 1U;
      int num6 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D256, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D255, &num5, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
      *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) ^ ((int) num5 << 3 ^ *(int*) ((IntPtr) obj0 + 8L)) & 8;
      if (FPerforceNET.EnsureValidConnection((FString*) sourceControlProviderPtr1, (FString*) sourceControlProviderPtr2, (FString*) sourceControlProviderPtr3, (FString*) sourceControlProviderPtr4) == 0U)
        *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) | 4;
      else
        *(int*) ((IntPtr) obj0 + 8L) = *(int*) ((IntPtr) obj0 + 8L) | 1;
    }
    if ((*(int*) ((IntPtr) obj0 + 8L) & 4) != 0 && \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FbAlreadyWarned\u0040\u003FBA\u0040\u003F\u003FLoadSettings\u0040FPerforceSourceControlProvider\u0040\u0040AEAAXXZ\u00404IA == 0U)
    {
      \u003CModule\u003E.FOutputDevice\u002ELogf\u003Cwchar_t\u0020\u002A\u003E((FOutputDevice*) \u003CModule\u003E.GWarn, (EName) 795, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D257, (char*) &\u003CModule\u003E.GGameName);
      \u003CModule\u003E.\u003FA0x3a4a4fc4\u002E\u003FbAlreadyWarned\u0040\u003FBA\u0040\u003F\u003FLoadSettings\u0040FPerforceSourceControlProvider\u0040\u0040AEAAXXZ\u00404IA = 1U;
    }
    \u003CModule\u003E.FPerforceSourceControlProvider\u002ESaveSettings(obj0);
  }

  internal static unsafe void FindFilesForCheckIn(
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InPackagesNames,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* OutAddFiles,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* OutOpenFiles)
  {
    int num = 0;
    if (0 >= \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(InPackagesNames))
      return;
    do
    {
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      switch (__calli((__FnPtr<int (IntPtr, char*)>) *(long*) (*(long*) \u003CModule\u003E.GPackageFileCache + 32L))((char*) \u003CModule\u003E.GPackageFileCache, (IntPtr) \u003CModule\u003E.FString\u002E\u002A(\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(InPackagesNames, num))))
      {
        case 1:
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(OutOpenFiles, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(InPackagesNames, num));
          break;
        case 4:
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(OutAddFiles, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(InPackagesNames, num));
          break;
      }
      ++num;
    }
    while (num < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(InPackagesNames));
  }

  internal static unsafe uint SourceControlWindows\u002EPromptForCheckin(
    FSourceControlEventListener* InEventListener,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InPackageNames)
  {
    uint num1 = 0;
    TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator1;
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator1);
    // ISSUE: fault handler
    try
    {
      TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator2;
      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator2);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FindFilesForCheckIn(InPackageNames, &fdefaultAllocator1, &fdefaultAllocator2);
        if (\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator1) == 0)
        {
          if (\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator2) == 0)
            goto label_43;
        }
        WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
        FString fstring1;
        FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D267, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D266, (char*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            InSettings.WindowTitle = str;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        FString fstring3;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D268);
        MWPFFrame mwpfFrame;
        // ISSUE: fault handler
        try
        {
          mwpfFrame = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D269);
        MSourceControlSubmitPanel controlSubmitPanel;
        // ISSUE: fault handler
        try
        {
          controlSubmitPanel = new MSourceControlSubmitPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4)), &fdefaultAllocator1, &fdefaultAllocator2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
        if (mwpfFrame.SetContentAndShowModal((MWPFPanel) controlSubmitPanel, 1) == 0)
        {
          FChangeListDescription fchangeListDescription;
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) &fchangeListDescription);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16));
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.FString\u002E\u007Bctor\u007D((FString*) ((IntPtr) &fchangeListDescription + 32));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) (ref fchangeListDescription + 16L));
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fchangeListDescription);
          }
          // ISSUE: fault handler
          try
          {
            controlSubmitPanel.FillChangeListDescription(&fchangeListDescription, &fdefaultAllocator1, &fdefaultAllocator2);
            \u003CModule\u003E.FSourceControl\u002EConvertPackageNamesToSourceControlPaths((TArray\u003CFString\u002CFDefaultAllocator\u003E*) &fchangeListDescription);
            \u003CModule\u003E.FSourceControl\u002EConvertPackageNamesToSourceControlPaths((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16));
            int num2 = (int) \u003CModule\u003E.FSourceControl\u002ERevertUnchanged(InEventListener, (TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16));
            int num3 = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16)) - 1;
            if (num3 >= 0)
            {
              do
              {
                FFilename ffilename;
                \u003CModule\u003E.FFilename\u002E\u007Bctor\u007D(&ffilename, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16), num3));
                // ISSUE: fault handler
                try
                {
                  FString fstring2;
                  \u003CModule\u003E.FFilename\u002EGetBaseFilename(&ffilename, &fstring2, 1U);
                  // ISSUE: fault handler
                  try
                  {
                    // ISSUE: cast to a function pointer type
                    // ISSUE: function pointer call
                    if (__calli((__FnPtr<int (IntPtr, char*)>) *(long*) (*(long*) \u003CModule\u003E.GPackageFileCache + 32L))((char*) \u003CModule\u003E.GPackageFileCache, (IntPtr) \u003CModule\u003E.FString\u002E\u002A(&fstring2)) != 1)
                      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ERemove((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16), num3, 1);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FFilename\u002E\u007Bdtor\u007D), (void*) &ffilename);
                }
                \u003CModule\u003E.FFilename\u002E\u007Bdtor\u007D(&ffilename);
                num3 += -1;
              }
              while (num3 >= 0);
            }
            num1 = \u003CModule\u003E.FSourceControl\u002ECheckIn(InEventListener, (TArray\u003CFString\u002CFDefaultAllocator\u003E*) &fchangeListDescription, (TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16), (FString*) ((IntPtr) &fchangeListDescription + 32));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FChangeListDescription\u002E\u007Bdtor\u007D), (void*) &fchangeListDescription);
          }
          // ISSUE: fault handler
          try
          {
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) &fchangeListDescription + 32));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) (ref fchangeListDescription + 16L));
            }
            \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) &fchangeListDescription + 16));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fchangeListDescription);
          }
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) &fchangeListDescription);
        }
        if (InSettings is IDisposable disposable4)
          disposable4.Dispose();
        mwpfFrame?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator2);
      }
label_43:
      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator1);
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator1);
    return num1;
  }

  internal static unsafe void FChangeListDescription\u002E\u007Bdtor\u007D(
    [In] FChangeListDescription* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 32L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
      }
      \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 16L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) obj0);
  }

  internal static unsafe void SourceControlWindows\u002EDisplayRevisionHistory(
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InPackagesNames)
  {
    TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator1;
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator1, InPackagesNames);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FSourceControl\u002EConvertPackageNamesToSourceControlPaths(&fdefaultAllocator1);
      TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E fdefaultAllocator2;
      \u003CModule\u003E.TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator2);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FSourceControl\u002EGetFileHistory(&fdefaultAllocator1, &fdefaultAllocator2);
        WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
        FString fstring1;
        FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D271, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D270, (char*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            InSettings.WindowTitle = str;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        FString fstring3;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D272);
        MWPFFrame mwpfFrame;
        // ISSUE: fault handler
        try
        {
          mwpfFrame = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D273);
        MSourceControlHistoryPanel controlHistoryPanel;
        // ISSUE: fault handler
        try
        {
          controlHistoryPanel = new MSourceControlHistoryPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4)), &fdefaultAllocator2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
        mwpfFrame.SetContentAndShow((MWPFPanel) controlHistoryPanel);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator2);
      }
      \u003CModule\u003E.TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator1);
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator1);
  }

  internal static unsafe uint SourceControlWindows\u002EPromptForRevert(
    FSourceControlEventListener* InEventListener,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InPackageNames)
  {
    uint num1 = 0;
    TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator1;
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator1);
    // ISSUE: fault handler
    try
    {
      TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E fdefaultAllocatorInt;
      \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(&fdefaultAllocatorInt, InPackageNames);
      if (\u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(&fdefaultAllocatorInt))
      {
        do
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          if (__calli((__FnPtr<int (IntPtr, char*)>) *(long*) (*(long*) \u003CModule\u003E.GPackageFileCache + 32L))((char*) \u003CModule\u003E.GPackageFileCache, (IntPtr) \u003CModule\u003E.FString\u002E\u002A(\u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(&fdefaultAllocatorInt))) == 1)
            \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(&fdefaultAllocator1, \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(&fdefaultAllocatorInt));
          \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(&fdefaultAllocatorInt);
        }
        while (\u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(&fdefaultAllocatorInt));
      }
      if (\u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator1) > 0)
      {
        WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
        FString fstring1;
        FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D275, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D274, (char*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            InSettings.WindowTitle = str;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        FString fstring3;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D276);
        MWPFFrame mwpfFrame;
        // ISSUE: fault handler
        try
        {
          mwpfFrame = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D277);
        MSourceControlRevertPanel controlRevertPanel;
        // ISSUE: fault handler
        try
        {
          controlRevertPanel = new MSourceControlRevertPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4)), &fdefaultAllocator1);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
        if (mwpfFrame.SetContentAndShowModal((MWPFPanel) controlRevertPanel, 1) == 0)
        {
          TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator2;
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator2);
          // ISSUE: fault handler
          try
          {
            controlRevertPanel.GetPackagesToRevert(&fdefaultAllocator2);
            \u003CModule\u003E.FSourceControl\u002EConvertPackageNamesToSourceControlPaths(&fdefaultAllocator2);
            int num2 = (int) \u003CModule\u003E.FSourceControl\u002ERevert(InEventListener, &fdefaultAllocator2);
            num1 = 1U;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator2);
          }
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator2);
        }
        if (InSettings is IDisposable disposable4)
          disposable4.Dispose();
        mwpfFrame?.Dispose();
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator1);
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator1);
    return num1;
  }

  internal static Assembly InteropTools\u002ECurrentDomain_AssemblyResolve(
    object __unnamed000,
    ResolveEventArgs AssemblyDetails)
  {
    char[] chArray = new char[1]{ ',' };
    string[] strArray = AssemblyDetails.Name.Split(chArray);
    if (AssemblyDetails.RequestingAssembly == (Assembly) null)
    {
      string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, "..\\" + strArray[0] + ".dll"));
      if (File.Exists(fullPath))
        return Assembly.LoadFile(fullPath);
    }
    else
    {
      string directoryName = Path.GetDirectoryName(AssemblyDetails.RequestingAssembly.Location);
      string path = !Environment.Is64BitProcess ? Path.GetFullPath(Path.Combine(directoryName, "Win32\\" + strArray[0] + ".dll")) : Path.GetFullPath(Path.Combine(directoryName, "Win64\\" + strArray[0] + ".dll"));
      if (File.Exists(path))
        return Assembly.LoadFile(path);
    }
    return (Assembly) null;
  }

  internal static void InteropTools\u002EAddResolveHandler() => AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(\u003CModule\u003E.InteropTools\u002ECurrentDomain_AssemblyResolve);

  internal static void InteropTools\u002EInitUnrealEdCSharpBackend() => Backend.InitBackend((IEditorBackendInterface) new MEditorBackend());

  internal static unsafe void InteropTools\u002ELoadResourceDictionaries()
  {
    if (System.Windows.Application.Current == null)
    {
      System.Windows.Application application = new System.Windows.Application();
    }
    \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
    int moduleFileNameW = (int) \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0L, (char*) &arrayTypeBy0BaeW, 259U);
    FString fstring1;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (char*) &arrayTypeBy0BaeW);
    // ISSUE: fault handler
    try
    {
      ParserContext parserContext = new ParserContext();
      parserContext.BaseUri = PackUriHelper.Create(new Uri(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring1), 0, \u003CModule\u003E.FString\u002ELen(&fstring1))));
      FString fstring2;
      FString* editorResourcesDir = \u003CModule\u003E.GetEditorResourcesDir(&fstring2);
      FString fstring3;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D278, \u003CModule\u003E.FString\u002E\u002A(editorResourcesDir));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
      }
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        char* chPtr = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D279;
        FString fstring4;
        \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D280, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D279);
        // ISSUE: fault handler
        try
        {
          TArray\u003CFString\u002CFDefaultAllocator\u003E fdefaultAllocator;
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
          // ISSUE: fault handler
          try
          {
            FString fstring5;
            FString* fstringPtr1 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(&fstring5, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D281, \u003CModule\u003E.FString\u002E\u002A(&fstring3), \u003CModule\u003E.FString\u002E\u002A(&fstring4));
            // ISSUE: fault handler
            try
            {
              // ISSUE: cast to a function pointer type
              // ISSUE: function pointer call
              __calli((__FnPtr<void (IntPtr, TArray\u003CFString\u002CFDefaultAllocator\u003E*, char*, uint, uint)>) *(long*) (*(long*) \u003CModule\u003E.GFileManager + 104L))((uint) \u003CModule\u003E.GFileManager, (uint) &fdefaultAllocator, \u003CModule\u003E.FString\u002E\u002A(fstringPtr1), (TArray\u003CFString\u002CFDefaultAllocator\u003E*) 1, IntPtr.Zero);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
            for (int index = 0; index < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator); ++index)
            {
              FString fstring6;
              \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring6, \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, index));
              // ISSUE: fault handler
              try
              {
                FString fstring7;
                \u003CModule\u003E.FString\u002E\u002A(&fstring3, &fstring7, &fstring6);
                // ISSUE: fault handler
                try
                {
                  try
                  {
                    auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E(new StreamReader(\u003CModule\u003E.CLRTools\u002EToString(&fstring7)));
                    auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader2;
                    // ISSUE: fault handler
                    try
                    {
                      systemIoStreamReader2 = systemIoStreamReader1;
                      System.Windows.Application.Current.Resources.MergedDictionaries.Add((ResourceDictionary) XamlReader.Load(systemIoStreamReader2.op_MemberSelection().BaseStream, parserContext));
                    }
                    __fault
                    {
                      systemIoStreamReader2.Dispose();
                    }
                    systemIoStreamReader2.Dispose();
                  }
                  catch (Exception ex)
                  {
                    FString fstring8;
                    FString* fstring9 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring8, ex.Message);
                    // ISSUE: fault handler
                    try
                    {
                      FString fstring10;
                      FString* fstringPtr2 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(&fstring10, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D282, \u003CModule\u003E.FString\u002E\u002A(&fstring7), \u003CModule\u003E.FString\u002E\u002A(fstring9));
                      // ISSUE: fault handler
                      try
                      {
                        int num = (int) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EappMsgf((EAppMsgType) 0, \u003CModule\u003E.FString\u002E\u002A(fstringPtr2));
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring10);
                      }
                      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring10);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring8);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring8);
                  }
                  char* language = \u003CModule\u003E.UObject\u002EGetLanguage();
                  if (\u003CModule\u003E.appStricmp(language, chPtr) != 0)
                  {
                    FString fstring8;
                    \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(&fstring8, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D283, language);
                    // ISSUE: fault handler
                    try
                    {
                      FString fstring9;
                      \u003CModule\u003E.FString\u002ELeft(&fstring6, &fstring9, \u003CModule\u003E.FString\u002ELen(&fstring6) - \u003CModule\u003E.FString\u002ELen(&fstring4));
                      // ISSUE: fault handler
                      try
                      {
                        FString fstring10;
                        \u003CModule\u003E.FString\u002E\u002B(&fstring9, &fstring10, &fstring8);
                        // ISSUE: fault handler
                        try
                        {
                          FString fstring11;
                          \u003CModule\u003E.FString\u002E\u002A(&fstring3, &fstring11, &fstring10);
                          // ISSUE: fault handler
                          try
                          {
                            // ISSUE: cast to a function pointer type
                            // ISSUE: function pointer call
                            if (__calli((__FnPtr<int (IntPtr, char*)>) *(long*) (*(long*) \u003CModule\u003E.GFileManager + 192L))((char*) \u003CModule\u003E.GFileManager, (IntPtr) \u003CModule\u003E.FString\u002E\u002A(&fstring11)) >= 0)
                            {
                              try
                              {
                                auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E(new StreamReader(\u003CModule\u003E.CLRTools\u002EToString(&fstring11)));
                                auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader2;
                                // ISSUE: fault handler
                                try
                                {
                                  systemIoStreamReader2 = systemIoStreamReader1;
                                  System.Windows.Application.Current.Resources.MergedDictionaries.Add((ResourceDictionary) XamlReader.Load(systemIoStreamReader2.op_MemberSelection().BaseStream, parserContext));
                                }
                                __fault
                                {
                                  systemIoStreamReader2.Dispose();
                                }
                                systemIoStreamReader2.Dispose();
                              }
                              catch (Exception ex)
                              {
                                FString fstring12;
                                FString* fstring13 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring12, ex.Message);
                                // ISSUE: fault handler
                                try
                                {
                                  FString fstring14;
                                  FString* fstringPtr2 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(&fstring14, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D284, \u003CModule\u003E.FString\u002E\u002A(&fstring11), \u003CModule\u003E.FString\u002E\u002A(fstring13));
                                  // ISSUE: fault handler
                                  try
                                  {
                                    int num = (int) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EappMsgf((EAppMsgType) 0, \u003CModule\u003E.FString\u002E\u002A(fstringPtr2));
                                  }
                                  __fault
                                  {
                                    // ISSUE: method pointer
                                    // ISSUE: cast to a function pointer type
                                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring14);
                                  }
                                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring14);
                                }
                                __fault
                                {
                                  // ISSUE: method pointer
                                  // ISSUE: cast to a function pointer type
                                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring12);
                                }
                                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring12);
                              }
                            }
                            else
                              \u003CModule\u003E.FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D285, \u003CModule\u003E.FString\u002E\u002A(&fstring7), \u003CModule\u003E.FString\u002E\u002A(&fstring11));
                          }
                          __fault
                          {
                            // ISSUE: method pointer
                            // ISSUE: cast to a function pointer type
                            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring11);
                          }
                          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring11);
                        }
                        __fault
                        {
                          // ISSUE: method pointer
                          // ISSUE: cast to a function pointer type
                          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring10);
                        }
                        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring10);
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring9);
                      }
                      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring9);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring8);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring8);
                  }
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring7);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring7);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring6);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring6);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
          }
          \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
  }

  internal static unsafe FName* CLRTools\u002EToFName([In] FName* obj0, string InCLRString)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InCLRString;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      \u003CModule\u003E.FName\u002E\u007Bctor\u007D(obj0, (char*) numPtr, (EFindName) 1, 1U);
      return obj0;
    }
  }

  internal static unsafe FString* CLRTools\u002EToFString([In] FString* obj0, string InCLRString)
  {
    uint num1 = 0;
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) InCLRString;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
    {
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(obj0, InCLRString.Length, (char*) numPtr);
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
        return obj0;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          uint num2 = num1 & 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
        }
      }
    }
  }

  internal static unsafe string CLRTools\u002EToString(FString* InFString) => new string(\u003CModule\u003E.FString\u002E\u002A(InFString), 0, \u003CModule\u003E.FString\u002ELen(InFString));

  internal static unsafe string CLRTools\u002EFNameToString(FName* InFName)
  {
    FString fstring;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring);
    string str;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FName\u002EToString(InFName, &fstring);
      str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring), 0, \u003CModule\u003E.FString\u002ELen(&fstring));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    return str;
  }

  internal static unsafe List<string> CLRTools\u002EToStringArray(
    TArray\u003CFString\u002CFDefaultAllocator\u003E* InFStrings)
  {
    List<string> stringList = new List<string>();
    stringList.Capacity = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(InFStrings);
    int num = 0;
    if (0 < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(InFStrings))
    {
      do
      {
        FString* fstringPtr = \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(InFStrings, num);
        string str = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
        stringList.Add(str);
        ++num;
      }
      while (num < \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(InFStrings));
    }
    return stringList;
  }

  internal static unsafe void CLRTools\u002EToFStringArray(
    ICollection<string> InStrings,
    TArray\u003CFString\u002CFDefaultAllocator\u003E* OutFStrings)
  {
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EReset(OutFStrings, 0);
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EReserve(OutFStrings, InStrings.Count);
    foreach (string inString in (IEnumerable<string>) InStrings)
    {
      FString fstring1;
      FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, inString);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(OutFStrings, fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    }
  }

  internal static unsafe HwndSource CLRTools\u002ECreateWPFWindowFromVisual(
    HWND__* ParentWindow,
    Visual InWPFVisual,
    string WindowTitle,
    int X,
    int Y,
    int Width,
    int Height,
    int WindowStyle,
    int ExtendedWindowStyle,
    int WindowClassStyle,
    [MarshalAs(UnmanagedType.U1)] bool bUsesPerPixelOpacity,
    [MarshalAs(UnmanagedType.U1)] bool bSizeToContent)
  {
    HwndSourceParameters parameters = new HwndSourceParameters(WindowTitle);
    parameters.PositionX = X;
    parameters.PositionY = Y;
    parameters.Width = Width;
    parameters.Height = Height;
    parameters.AdjustSizingForNonClientArea = false;
    IntPtr num = new IntPtr((void*) ParentWindow);
    parameters.ParentWindow = num;
    parameters.WindowStyle = WindowStyle;
    parameters.ExtendedWindowStyle = ExtendedWindowStyle;
    parameters.WindowClassStyle = WindowClassStyle;
    parameters.UsesPerPixelOpacity = bUsesPerPixelOpacity;
    parameters.HwndSourceHook = (HwndSourceHook) null;
    HwndSource hwndSource = new HwndSource(parameters);
    hwndSource.RootVisual = InWPFVisual;
    SizeToContent sizeToContent = bSizeToContent ? SizeToContent.WidthAndHeight : SizeToContent.Manual;
    hwndSource.SizeToContent = sizeToContent;
    \u003CModule\u003E.WxUnrealEdApp\u002EInstallHooksWPF();
    return hwndSource;
  }

  internal static unsafe Visual CLRTools\u002ECreateVisualFromXaml(string XamlFileName)
  {
    auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader1 = new auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E(new StreamReader(XamlFileName));
    auto_handle\u003CSystem\u003A\u003AIO\u003A\u003AStreamReader\u003E systemIoStreamReader2;
    Visual visual;
    // ISSUE: fault handler
    try
    {
      systemIoStreamReader2 = systemIoStreamReader1;
      ParserContext parserContext = new ParserContext();
      \u0024ArrayType\u0024\u0024\u0024BY0BAE\u0040_W arrayTypeBy0BaeW;
      int moduleFileNameW = (int) \u003CModule\u003E.GetModuleFileNameW((HINSTANCE__*) 0L, (char*) &arrayTypeBy0BaeW, 259U);
      FString fstring;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring, (char*) &arrayTypeBy0BaeW);
      // ISSUE: fault handler
      try
      {
        Uri uri = PackUriHelper.Create(new Uri(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring), 0, \u003CModule\u003E.FString\u002ELen(&fstring))));
        parserContext.BaseUri = uri;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
      visual = (Visual) XamlReader.Load(systemIoStreamReader2.op_MemberSelection().BaseStream, parserContext);
    }
    __fault
    {
      systemIoStreamReader2.Dispose();
    }
    systemIoStreamReader2.Dispose();
    return visual;
  }

  internal static unsafe HwndSource CLRTools\u002ECreateWPFWindowFromXaml(
    HWND__* ParentWindow,
    string XamlFileName,
    string WindowTitle,
    int X,
    int Y,
    int Width,
    int Height,
    int WindowStyle,
    int ExtendedWindowStyle,
    int WindowClassStyle,
    [MarshalAs(UnmanagedType.U1)] bool bUsesPerPixelOpacity,
    [MarshalAs(UnmanagedType.U1)] bool bSizeToContent)
  {
    Visual visualFromXaml = \u003CModule\u003E.CLRTools\u002ECreateVisualFromXaml(XamlFileName);
    return \u003CModule\u003E.CLRTools\u002ECreateWPFWindowFromVisual(ParentWindow, visualFromXaml, WindowTitle, X, Y, Width, Height, WindowStyle, ExtendedWindowStyle, WindowClassStyle, bUsesPerPixelOpacity, bSizeToContent);
  }

  internal static unsafe string CLRTools\u002ELocalizeString(
    string UnlocalizedString,
    string StrParam0,
    string StrParam1,
    string StrParam2)
  {
    FString fstring1;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1);
    string str;
    // ISSUE: fault handler
    try
    {
      // ISSUE: cast to a reference type
      // ISSUE: variable of a reference type
      byte* local1 = (byte*) UnlocalizedString;
      if (local1 != null)
        local1 = (long) (uint) RuntimeHelpers.OffsetToStringData + local1;
      // ISSUE: explicit reference operation
      fixed (byte* numPtr = &^local1)
      {
        if (StrParam0 == (string) null)
        {
          FString fstring2;
          FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring2, (char*) numPtr, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D286, (char*) 0L);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FString\u002E\u003D(&fstring1, fstringPtr);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        else
        {
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          byte* local2 = (byte*) StrParam0;
          if (local2 != null)
            local2 = (long) (uint) RuntimeHelpers.OffsetToStringData + local2;
          // ISSUE: cast to a reference type
          // ISSUE: variable of a reference type
          char* local3 = (char*) local2;
          // ISSUE: fault handler
          try
          {
            if (StrParam1 == (string) null)
            {
              FString fstring2;
              FString* fstringPtr1 = \u003CModule\u003E.LocalizeUnrealEd(&fstring2, (char*) numPtr, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D287, (char*) 0L);
              // ISSUE: fault handler
              try
              {
                FString fstring3;
                FString* fstringPtr2 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u003E(&fstring3, \u003CModule\u003E.FormatLocalizedString\u003Cwchar_t\u0020\u002A\u003E(\u003CModule\u003E.TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(\u003CModule\u003E.FString\u002EGetCharArray(fstringPtr1)), (char*) local3), (char*) local3);
                // ISSUE: fault handler
                try
                {
                  \u003CModule\u003E.FString\u002E\u003D(&fstring1, fstringPtr2);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
            }
            else
            {
              // ISSUE: cast to a reference type
              // ISSUE: variable of a reference type
              byte* local4 = (byte*) StrParam1;
              if (local4 != null)
                local4 = (long) (uint) RuntimeHelpers.OffsetToStringData + local4;
              // ISSUE: cast to a reference type
              // ISSUE: variable of a reference type
              char* local5 = (char*) local4;
              // ISSUE: fault handler
              try
              {
                if (StrParam2 == (string) null)
                {
                  FString fstring2;
                  FString* fstringPtr1 = \u003CModule\u003E.LocalizeUnrealEd(&fstring2, (char*) numPtr, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D288, (char*) 0L);
                  // ISSUE: fault handler
                  try
                  {
                    FString fstring3;
                    FString* fstringPtr2 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(&fstring3, \u003CModule\u003E.FormatLocalizedString\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(\u003CModule\u003E.TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(\u003CModule\u003E.FString\u002EGetCharArray(fstringPtr1)), (char*) local3, (char*) local5), (char*) local3, (char*) local5);
                    // ISSUE: fault handler
                    try
                    {
                      \u003CModule\u003E.FString\u002E\u003D(&fstring1, fstringPtr2);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
                  }
                  __fault
                  {
                    // ISSUE: method pointer
                    // ISSUE: cast to a function pointer type
                    \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                  }
                  \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                }
                else
                {
                  // ISSUE: cast to a reference type
                  // ISSUE: variable of a reference type
                  byte* local6 = (byte*) StrParam2;
                  if (local6 != null)
                    local6 = (long) (uint) RuntimeHelpers.OffsetToStringData + local6;
                  // ISSUE: cast to a reference type
                  // ISSUE: variable of a reference type
                  char* local7 = (char*) local6;
                  // ISSUE: fault handler
                  try
                  {
                    FString fstring2;
                    FString* fstringPtr1 = \u003CModule\u003E.LocalizeUnrealEd(&fstring2, (char*) numPtr, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D289, (char*) 0L);
                    // ISSUE: fault handler
                    try
                    {
                      FString fstring3;
                      FString* fstringPtr2 = \u003CModule\u003E.FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(&fstring3, \u003CModule\u003E.FormatLocalizedString\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(\u003CModule\u003E.TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(\u003CModule\u003E.FString\u002EGetCharArray(fstringPtr1)), (char*) local3, (char*) local5, (char*) local7), (char*) local3, (char*) local5, (char*) local7);
                      // ISSUE: fault handler
                      try
                      {
                        \u003CModule\u003E.FString\u002E\u003D(&fstring1, fstringPtr2);
                      }
                      __fault
                      {
                        // ISSUE: method pointer
                        // ISSUE: cast to a function pointer type
                        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                      }
                      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
                    }
                    __fault
                    {
                      // ISSUE: method pointer
                      // ISSUE: cast to a function pointer type
                      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
                    }
                    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
                  }
                  __fault
                  {
                    // ISSUE: cast to a reference type
                    local7 = (char*) 0L;
                  }
                  // ISSUE: cast to a reference type
                  local7 = (char*) null;
                }
              }
              __fault
              {
                // ISSUE: cast to a reference type
                local5 = (char*) 0L;
              }
              // ISSUE: cast to a reference type
              local5 = (char*) null;
            }
          }
          __fault
          {
            // ISSUE: cast to a reference type
            local3 = (char*) 0L;
          }
          // ISSUE: cast to a reference type
          local3 = (char*) null;
        }
        str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring1));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    return str;
  }

  internal static unsafe void CLRTools\u002ELogWarningMessage(string Message)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) Message;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
      \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GWarn, (char*) numPtr);
  }

  internal static unsafe void CLRTools\u002ELogWarningMessage(EName CategoryName, string Message)
  {
    // ISSUE: cast to a reference type
    // ISSUE: variable of a reference type
    byte* local = (byte*) Message;
    if (local != null)
      local = (long) (uint) RuntimeHelpers.OffsetToStringData + local;
    // ISSUE: explicit reference operation
    fixed (byte* numPtr = &^local)
      \u003CModule\u003E.FOutputDevice\u002ELog((FOutputDevice*) \u003CModule\u003E.GWarn, CategoryName, (char*) numPtr);
  }

  internal static unsafe uint CLRTools\u002EIsPackageValidForTree(UPackage* Pkg)
  {
    uint num = 1;
    return \u003CModule\u003E.UObject\u002EHasAnyFlags((UObject*) Pkg, 70368744177664UL) == 0U ? (Pkg != \u003CModule\u003E.UObject\u002EGetTransientPackage() ? ((*(int*) ((IntPtr) Pkg + 280L) & 3407872) != 0 ? 0U : num) : 0U) : 0U;
  }

  internal static unsafe FString* CLRTools\u002EExtractPackageName(
    [In] FString* obj0,
    FString* AssetPathName)
  {
    uint num1 = 0;
    int num2 = \u003CModule\u003E.FString\u002EInStr(AssetPathName, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D290, 1U, 0U, -1);
    uint num3;
    if (num2 != -1)
    {
      \u003CModule\u003E.FString\u002ELeft(AssetPathName, obj0, num2);
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
        return obj0;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num3 = num1 & 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
        }
      }
    }
    else
    {
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(obj0, AssetPathName);
      // ISSUE: fault handler
      try
      {
        num1 = 1U;
        return obj0;
      }
      __fault
      {
        if (((int) num1 & 1) != 0)
        {
          num3 = num1 & 4294967294U;
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
        }
      }
    }
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool CLRTools\u002EIsMapPackageAsset(FString* AssetPathName)
  {
    bool flag;
    // ISSUE: fault handler
    try
    {
      flag = false;
      FString fstring1;
      FString* packageName = \u003CModule\u003E.CLRTools\u002EExtractPackageName(&fstring1, AssetPathName);
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002E\u003D(AssetPathName, packageName);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      if (\u003CModule\u003E.FString\u002ELen(AssetPathName) > 0)
      {
        if ((IntPtr) \u003CModule\u003E.GPackageFileCache != IntPtr.Zero)
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2);
          // ISSUE: fault handler
          try
          {
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            if (__calli((__FnPtr<uint (IntPtr, char*, FGuid*, FString*, char*)>) *(long*) (*(long*) \u003CModule\u003E.GPackageFileCache + 16L))((char*) \u003CModule\u003E.GPackageFileCache, (FString*) \u003CModule\u003E.FString\u002E\u002A(AssetPathName), (FGuid*) 0L, (char*) &fstring2, IntPtr.Zero) != 0U)
            {
              FFilename ffilename;
              \u003CModule\u003E.FFilename\u002E\u007Bctor\u007D(&ffilename, &fstring2);
              // ISSUE: fault handler
              try
              {
                FString fstring3;
                FString* extension = \u003CModule\u003E.FFilename\u002EGetExtension(&ffilename, &fstring3, 0U);
                uint num;
                // ISSUE: fault handler
                try
                {
                  num = \u003CModule\u003E.FString\u002E\u003D\u003D(extension, &\u003CModule\u003E.\u003FDefaultMapExt\u0040FURL\u0040\u00402VFString\u0040\u0040A);
                }
                __fault
                {
                  // ISSUE: method pointer
                  // ISSUE: cast to a function pointer type
                  \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
                }
                \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
                flag = num != 0U || flag;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FFilename\u002E\u007Bdtor\u007D), (void*) &ffilename);
              }
              \u003CModule\u003E.FFilename\u002E\u007Bdtor\u007D(&ffilename);
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) AssetPathName);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(AssetPathName);
    return flag;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool CLRTools\u002EIsAssetValidForLoading(string AssetPathName)
  {
    int num;
    if (AssetPathName != (string) null)
    {
      FString fstring;
      FString* fstringPtr = &fstring;
      if (!\u003CModule\u003E.CLRTools\u002EIsMapPackageAsset(\u003CModule\u003E.CLRTools\u002EToFString(&fstring, AssetPathName)))
      {
        num = 1;
        goto label_4;
      }
    }
    num = 0;
label_4:
    return num != 0;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool CLRTools\u002EIsAssetValidForPlacing(string AssetPathName)
  {
    FString fstring1;
    FString* fstringPtr = &fstring1;
    bool flag = !\u003CModule\u003E.CLRTools\u002EIsMapPackageAsset(\u003CModule\u003E.CLRTools\u002EToFString(&fstring1, AssetPathName));
    if (!flag && AssetPathName != (string) null)
    {
      FString fstring2;
      FString* fstring3 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring2, AssetPathName);
      FString fstring4;
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.CLRTools\u002EExtractPackageName(&fstring4, fstring3);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
      }
      // ISSUE: fault handler
      try
      {
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        if (\u003CModule\u003E.FString\u002ELen(&fstring4) > 0)
        {
          UPackage* objectClassUpackage = \u003CModule\u003E.FindObject\u003Cclass\u0020UPackage\u003E((UObject*) 0L, \u003CModule\u003E.FString\u002E\u002A(&fstring4), 1U);
          if ((IntPtr) objectClassUpackage != IntPtr.Zero)
          {
            TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
            \u003CModule\u003E.TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.FLevelUtils\u002EGetWorlds(&fdefaultAllocator, 1U, 0U);
              int num = 0;
              if (0 < \u003CModule\u003E.TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator))
              {
                do
                {
                  UWorld* uworldPtr = (UWorld*) *(long*) \u003CModule\u003E.TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(&fdefaultAllocator, num);
                  if ((IntPtr) uworldPtr == IntPtr.Zero || \u003CModule\u003E.UObject\u002EGetOutermost((UObject*) uworldPtr) != objectClassUpackage)
                    ++num;
                  else
                    goto label_10;
                }
                while (num < \u003CModule\u003E.TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(&fdefaultAllocator));
                goto label_12;
label_10:
                flag = true;
              }
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
            }
label_12:
            \u003CModule\u003E.TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
          }
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
    }
    return flag;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool CLRTools\u002EIsAssetValidForTagging(string AssetFullName) => AssetFullName != (string) null && AssetFullName.Length > 0;

  internal static unsafe int ManagedGuardedMain(
    char* CmdLine,
    HINSTANCE__* hInInstance,
    HINSTANCE__* hPrevInstance,
    int nCmdShow)
  {
    try
    {
      return \u003CModule\u003E.GuardedMainWrapper(CmdLine, hInInstance, hPrevInstance, nCmdShow);
    }
    catch (Exception ex)
    {
      if (!ex.StackTrace.Substring(6, 11).Equals("GuardedMain"))
      {
        FString fstring1;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1);
        // ISSUE: fault handler
        try
        {
          object[] objArray1 = new object[4]
          {
            (object) ex.GetType().FullName,
            (object) ex.Source,
            (object) ex.Message,
            (object) ex.StackTrace
          };
          FString fstring2;
          FString* fstring3 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring2, string.Format("{0} error in {1}:\r\n\r\n{2}\r\n\r\n{3}", objArray1));
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.FString\u002E\u002B\u003D(&fstring1, fstring3);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          Exception innerException = ex.InnerException;
          if (innerException != null)
          {
            do
            {
              object[] objArray2 = new object[4]
              {
                (object) innerException.GetType().FullName,
                (object) innerException.Source,
                (object) innerException.Message,
                (object) innerException.StackTrace
              };
              FString fstring4;
              FString* fstring5 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring4, string.Format("\nInner exception {0} in {1}:\r\n\r\n{2}\r\n\r\n{3}", objArray2));
              // ISSUE: fault handler
              try
              {
                \u003CModule\u003E.FString\u002E\u002B\u003D(&fstring1, fstring5);
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
              innerException = innerException.InnerException;
            }
            while (innerException != null);
          }
          \u003CModule\u003E.appStrcat\u003C16384\u003E(&\u003CModule\u003E.GErrorHist, \u003CModule\u003E.FString\u002E\u002A(&fstring1));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      }
      throw;
    }
  }

  internal static unsafe BitmapSource ThumbnailToolsCLR\u002ECreateBitmapSourceForThumbnail(
    FObjectThumbnail* InThumbnail)
  {
    TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* uncompressedImageData = \u003CModule\u003E.FObjectThumbnail\u002EGetUncompressedImageData(InThumbnail);
    PixelFormat bgr32 = PixelFormats.Bgr32;
    uint num1 = (uint) ((ulong) \u003CModule\u003E.FObjectThumbnail\u002EGetImageWidth(InThumbnail) * 4UL);
    if (\u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002ENum(uncompressedImageData) <= 0)
      return (BitmapSource) null;
    uint num2 = (uint) \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002ENum(uncompressedImageData);
    IntPtr buffer = new IntPtr((long) \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(uncompressedImageData, 0));
    return BitmapSource.Create(\u003CModule\u003E.FObjectThumbnail\u002EGetImageWidth(InThumbnail), \u003CModule\u003E.FObjectThumbnail\u002EGetImageHeight(InThumbnail), 96.0, 96.0, bgr32, (BitmapPalette) null, buffer, (int) num2, (int) num1);
  }

  internal static unsafe void ThumbnailToolsCLR\u002ECopyThumbnailToWriteableBitmap(
    FObjectThumbnail* InThumbnail,
    WriteableBitmap WriteableBitmap)
  {
    TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* uncompressedImageData = \u003CModule\u003E.FObjectThumbnail\u002EGetUncompressedImageData(InThumbnail);
    FColor* fcolorPtr1 = (FColor*) \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(uncompressedImageData, 0);
    WriteableBitmap.Lock();
    FColor* backBuffer = (FColor*) (long) WriteableBitmap.BackBuffer;
    int num1 = (int) ((ulong) WriteableBitmap.BackBufferStride >> 2);
    int imageWidth = \u003CModule\u003E.FObjectThumbnail\u002EGetImageWidth(InThumbnail);
    int imageHeight = \u003CModule\u003E.FObjectThumbnail\u002EGetImageHeight(InThumbnail);
    if (num1 == imageWidth)
    {
      // ISSUE: cpblk instruction
      __memcpy((IntPtr) backBuffer, (IntPtr) fcolorPtr1, (long) \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002ENum(uncompressedImageData));
    }
    else
    {
      long num2 = 0;
      long num3 = (long) imageWidth;
      long num4 = (long) num1;
      long num5 = (long) imageHeight;
      if (0L < num5)
      {
        long num6 = num4 * 4L;
        FColor* fcolorPtr2 = backBuffer;
        do
        {
          if (0L < num3)
          {
            FColor* fcolorPtr3 = fcolorPtr2;
            FColor* fcolorPtr4 = (FColor*) ((num3 - num4) * num2 * 4L - (IntPtr) backBuffer + (IntPtr) fcolorPtr1);
            ulong num7 = (ulong) num3;
            do
            {
              // ISSUE: cpblk instruction
              __memcpy((IntPtr) fcolorPtr3, (IntPtr) fcolorPtr4 + (IntPtr) fcolorPtr3, 4);
              fcolorPtr3 += 4L;
              --num7;
            }
            while (num7 > 0UL);
          }
          ++num2;
          fcolorPtr2 = (FColor*) (num6 + (IntPtr) fcolorPtr2);
        }
        while (num2 < num5);
      }
    }
    Int32Rect dirtyRect = new Int32Rect(0, 0, imageWidth, imageHeight);
    WriteableBitmap.AddDirtyRect(dirtyRect);
    WriteableBitmap.Unlock();
  }

  internal static unsafe BitmapSource ThumbnailToolsCLR\u002EGetBitmapSourceForObject(
    UObject* InObject)
  {
    BitmapSource bitmapSource = (BitmapSource) null;
    FString fstring1;
    FString* fullName = \u003CModule\u003E.UObject\u002EGetFullName(InObject, &fstring1, (UObject*) 0L);
    FObjectThumbnail* InThumbnail;
    // ISSUE: fault handler
    try
    {
      FString fstring2;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fullName));
      // ISSUE: fault handler
      try
      {
        InThumbnail = \u003CModule\u003E.ThumbnailTools\u002EFindCachedThumbnail(&fstring2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    if ((IntPtr) InThumbnail == IntPtr.Zero || \u003CModule\u003E.FObjectThumbnail\u002EIsEmpty(InThumbnail) != 0U || \u003CModule\u003E.FObjectThumbnail\u002EIsDirty(InThumbnail) != 0U)
      InThumbnail = \u003CModule\u003E.ThumbnailTools\u002EGenerateThumbnailForObject(InObject);
    if ((IntPtr) InThumbnail != IntPtr.Zero)
      bitmapSource = \u003CModule\u003E.ThumbnailToolsCLR\u002ECreateBitmapSourceForThumbnail(InThumbnail);
    return bitmapSource;
  }

  internal static unsafe Guid FromGUID(_GUID* SrcGuid) => new Guid((uint) *(int*) SrcGuid, *(ushort*) ((IntPtr) SrcGuid + 4L), *(ushort*) ((IntPtr) SrcGuid + 6L), *(byte*) ((IntPtr) SrcGuid + 8L), *(byte*) ((IntPtr) SrcGuid + 9L), *(byte*) ((IntPtr) SrcGuid + 10L), *(byte*) ((IntPtr) SrcGuid + 11L), *(byte*) ((IntPtr) SrcGuid + 12L), *(byte*) ((IntPtr) SrcGuid + 13L), *(byte*) ((IntPtr) SrcGuid + 14L), *(byte*) ((IntPtr) SrcGuid + 15L));

  internal static unsafe Guid \u003FA0x3a4a4fc4\u002EGetUDKGeneratedID()
  {
    string subkey = "Software\\Epic Games\\UDK";
    string name1 = "ID";
    string name2 = "IDCK";
    Guid guid = new Guid();
    bool flag1 = false;
    try
    {
      RegistryKey subKey = Registry.CurrentUser.CreateSubKey(subkey);
      object obj1 = subKey.GetValue(name1);
      if (obj1 != null)
      {
        try
        {
          guid = new Guid(obj1.ToString());
          flag1 = true;
        }
        catch (FormatException ex)
        {
        }
      }
      uint num1 = 8;
      long num2;
      // ISSUE: initblk instruction
      __memset(ref num2, 0, 8);
      int macAddress = (int) \u003CModule\u003E.appGetMacAddress((byte*) &num2, &num1);
      if (flag1)
      {
        object obj2 = subKey.GetValue(name2);
        if (obj2 != null)
        {
          bool flag2;
          try
          {
            long num3 = (long) obj2;
            flag2 = num2 == num3 && flag1;
          }
          catch (Exception ex)
          {
            flag2 = false;
          }
          if (flag2)
            goto label_11;
        }
      }
      guid = Guid.NewGuid();
      subKey.SetValue(name1, (object) guid.ToString());
      subKey.SetValue(name2, (object) num2, RegistryValueKind.QWord);
label_11:
      return guid;
    }
    catch (Exception ex)
    {
      return Guid.Empty;
    }
  }

  internal static unsafe string \u003FA0x3a4a4fc4\u002EGetCPUFeatures()
  {
    // ISSUE: untyped stack allocation
    long num1 = (long) __untypedstackalloc(\u003CModule\u003E.__CxxQueryExceptionSize());
    string empty = string.Empty;
    try
    {
      \u0024ArrayType\u0024\u0024\u0024BY03H arrayTypeBy03H;
      \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ECallCPUID((int*) &arrayTypeBy03H, 0);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num2 = ^(int&) ref arrayTypeBy03H;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      if (^(int&) ref arrayTypeBy03H > 0)
      {
        \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ECallCPUID((int*) &arrayTypeBy03H, 1);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        object[] objArray = new object[4]
        {
          (object) ^(int&) ref arrayTypeBy03H,
          (object) ^(int&) ((IntPtr) &arrayTypeBy03H + 4),
          (object) ^(int&) ((IntPtr) &arrayTypeBy03H + 8),
          (object) ^(int&) ((IntPtr) &arrayTypeBy03H + 12)
        };
        empty += string.Format("{0:X8},{1:X8},{2:X8},{3:X8},", objArray);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str1 = (^(int&) ((IntPtr) &arrayTypeBy03H + 12) & 33554432) == 0 ? "" : "SSE,";
        empty += str1;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str2 = (^(int&) ((IntPtr) &arrayTypeBy03H + 12) & 67108864) == 0 ? "" : "SSE2,";
        empty += str2;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str3 = (^(int&) ((IntPtr) &arrayTypeBy03H + 8) & 1) == 0 ? "" : "SSE3,";
        empty += str3;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str4 = (^(int&) ((IntPtr) &arrayTypeBy03H + 8) & 524288) == 0 ? "" : "SSE4.1,";
        empty += str4;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str5 = (^(int&) ((IntPtr) &arrayTypeBy03H + 8) & 1048576) == 0 ? "" : "SSE4.2,";
        empty += str5;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str6 = (^(int&) ((IntPtr) &arrayTypeBy03H + 12) & 8388608) == 0 ? "" : "MMX,";
        empty += str6;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        string str7 = (^(int&) ((IntPtr) &arrayTypeBy03H + 12) & 268435456) == 0 ? "" : "HTT,";
        empty += str7;
      }
    }
    catch (Exception ex1) when (
    {
      // ISSUE: unable to correctly present filter
      uint exceptionCode = (uint) Marshal.GetExceptionCode();
      if (\u003CModule\u003E.__CxxExceptionFilter((void*) Marshal.GetExceptionPointers(), (void*) 0L, 0, (void*) 0L) != 0)
      {
        SuccessfulFiltering;
      }
      else
        throw;
    }
    )
    {
      uint num2 = 0;
      \u003CModule\u003E.__CxxRegisterExceptionObject((void*) Marshal.GetExceptionPointers(), (void*) num1);
      try
      {
        try
        {
        }
        catch (Exception ex2) when (
        {
          // ISSUE: unable to correctly present filter
          num2 = (uint) \u003CModule\u003E.__CxxDetectRethrow((void*) Marshal.GetExceptionPointers());
          if (num2 != 0U)
          {
            SuccessfulFiltering;
          }
          else
            throw;
        }
        )
        {
        }
        goto label_11;
        if (num2 != 0U)
          throw;
      }
      finally
      {
        \u003CModule\u003E.__CxxUnregisterExceptionObject((void*) num1, (int) num2);
      }
    }
label_11:
    return empty;
  }

  internal static unsafe string \u003FA0x3a4a4fc4\u002EGetDeviceIDOfDesktopMonitor()
  {
    string deviceName = Screen.PrimaryScreen.DeviceName;
    FString fstring;
    \u003CModule\u003E.CLRTools\u002EToFString(&fstring, deviceName);
    string str;
    // ISSUE: fault handler
    try
    {
      _DISPLAY_DEVICEW displayDevicew;
      // ISSUE: initblk instruction
      __memset(ref displayDevicew, 0, 840);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref displayDevicew = 840;
      str = \u003CModule\u003E.EnumDisplayDevicesW(\u003CModule\u003E.FString\u002E\u002A(&fstring), 0U, &displayDevicew, 0U) != 0 ? new string((char*) ((IntPtr) &displayDevicew + 328)) : throw new ApplicationException(string.Format("EnumDisplayDevices failed for DeviceName {0}.", (object) deviceName));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    return str;
  }

  internal static void \u003FA0x3a4a4fc4\u002ERecordPhysicalDimensionsOfDesktopMonitor(
    UDKSurvey SurveyData)
  {
    string str1 = string.Empty;
    string ofDesktopMonitor = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetDeviceIDOfDesktopMonitor();
    char[] separator = new char[1]{ '\\' };
    string[] strArray1 = ofDesktopMonitor.Split(separator, 3);
    if (strArray1.Length != 3)
      throw new ApplicationException(string.Format("DesktopMonitorDeviceID {0} does not have 3 parts", (object) ofDesktopMonitor));
    RegistryKey registryKey1 = Registry.LocalMachine.OpenSubKey("SYSTEM\\CurrentControlSet\\Enum\\Display");
    string[] strArray2 = registryKey1 != null ? registryKey1.GetSubKeyNames() : throw new ApplicationException("Failed to open RegKey HKLM\\SYSTEM\\CurrentControlSet\\Enum\\Display");
    int index1 = 0;
    if (0 < strArray2.Length)
    {
      byte[] numArray;
      do
      {
        string name1 = strArray2[index1];
        if (!name1.Equals("Default_Monitor", StringComparison.InvariantCultureIgnoreCase))
        {
          RegistryKey registryKey2 = registryKey1.OpenSubKey(name1);
          string[] subKeyNames = registryKey2.GetSubKeyNames();
          int index2 = 0;
          if (0 < subKeyNames.Length)
          {
            do
            {
              string name2 = subKeyNames[index2];
              RegistryKey registryKey3 = registryKey2.OpenSubKey(name2);
              string str2 = (string) registryKey3.GetValue("Driver");
              if (str2 == (string) null)
                str1 += string.Format("Driver value not found in SubKey {0}.\n\n", (object) registryKey3.Name);
              else if (strArray1[2].Equals(str2, StringComparison.InvariantCultureIgnoreCase))
              {
                RegistryKey registryKey4 = registryKey3.OpenSubKey("Device Parameters");
                if (registryKey4 == null)
                {
                  str1 += string.Format("Device Parameters SubKey not found in {0}.\n\n", (object) registryKey3.Name);
                }
                else
                {
                  numArray = (byte[]) registryKey4.GetValue("EDID");
                  if (numArray == null)
                    str1 += string.Format("EDID value not found in {0}.\n\n", (object) registryKey4.Name);
                  else
                    goto label_16;
                }
              }
              ++index2;
            }
            while (index2 < subKeyNames.Length);
          }
        }
        ++index1;
      }
      while (index1 < strArray2.Length);
      goto label_17;
label_16:
      byte num = numArray[22];
      SurveyData.Hardware.PrimaryMonitor.MaxHorizontalImageSizeCm = numArray[21];
      SurveyData.Hardware.PrimaryMonitor.MaxVerticalImageSizeCm = num;
      return;
    }
label_17:
    if (!string.IsNullOrEmpty(str1))
      str1 = "Errors found while searching: " + str1;
    throw new ApplicationException(string.Format("Could not find matching PNPID for Desktop monitor DeviceID {0}. {1}", (object) ofDesktopMonitor, (object) str1));
  }

  internal static unsafe UDKSurvey \u003FA0x3a4a4fc4\u002ERetrieveHardwareInfo()
  {
    ManagementObject managementObject1 = (ManagementObject) null;
    UDKSurvey SurveyData = new UDKSurvey();
    try
    {
      DateTime utcNow = DateTime.UtcNow;
      ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher();
      SurveyData.UDKHeader.Version = \u003CModule\u003E.GEngineVersion;
      SurveyData.UDKHeader.ModName = "UDK";
      SurveyData.UDKHeader.ModGuid = Guid.Empty;
      SurveyData.UDKHeader.ModAuthorID = Guid.Empty;
      try
      {
        FString fstring;
        FString* fstringPtr = \u003CModule\u003E.appGameDir(&fstring);
        bool flag;
        // ISSUE: fault handler
        try
        {
          flag = Directory.Exists(Path.Combine(new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr)), "Content"));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
        if (!flag)
        {
          SurveyData.UDKHeader.ModName = "";
          GameOptions gameOptions = (GameOptions) new XmlSerializer(typeof (GameOptions)).Deserialize((TextReader) File.OpenText(new string(\u003CModule\u003E.appBaseDir()) + "..\\..\\Binaries\\UnSetup.Game.xml"));
          SurveyData.UDKHeader.ModName = gameOptions.GameName;
          SurveyData.UDKHeader.ModGuid = gameOptions.GameUniqueID;
          SurveyData.UDKHeader.ModAuthorID = gameOptions.MachineUniqueID;
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to load UnSetup.Game.xml file that should be present. " + ex.ToString() + "\n\n";
      }
      Guid udkGeneratedId = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetUDKGeneratedID();
      SurveyData.UDKHeader.ID = udkGeneratedId;
      SurveyData.Locale.Culture = CultureInfo.CurrentCulture.Name;
      SurveyData.Locale.TimeZone = TimeZone.CurrentTimeZone.StandardName;
      SurveyData.OperatingSystem.Platform = Environment.OSVersion.Platform.ToString();
      SurveyData.OperatingSystem.ServicePack = Environment.OSVersion.ServicePack;
      SurveyData.OperatingSystem.Version = Environment.OSVersion.Version.ToString();
      if (Environment.OSVersion.Version.Major >= 6)
      {
        try
        {
          RegistryKey registryKey = Registry.LocalMachine.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System");
          if (registryKey != null)
          {
            object obj = registryKey.GetValue("EnableLUA");
            if (obj != null)
            {
              string str = (int) obj == 0 ? "false" : "true";
              SurveyData.OperatingSystem.IsUACEnabled = str;
            }
            else
              SurveyData.OperatingSystem.IsUACEnabled = "NotFound";
          }
          else
            SurveyData.OperatingSystem.IsUACEnabled = "NotFound";
        }
        catch (Exception ex)
        {
          SurveyData.OperatingSystem.IsUACEnabled = "Exception";
          SurveyData.DataCollectionErrorString += "Failed to check UAC settings. " + ex.ToString() + "\n\n";
        }
      }
      else
        SurveyData.OperatingSystem.IsUACEnabled = "N/A";
      _OSVERSIONINFOEXW osversioninfoexw;
      // ISSUE: initblk instruction
      __memset(ref osversioninfoexw, 0, 284);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref osversioninfoexw = 284;
      \u003CModule\u003E.GetVersionExW((_OSVERSIONINFOW*) &osversioninfoexw);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.OperatingSystem.ServicePackMajor = ^(ushort&) ((IntPtr) &osversioninfoexw + 276);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.OperatingSystem.ServicePackMinor = ^(ushort&) ((IntPtr) &osversioninfoexw + 278);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.OperatingSystem.SuiteMask = ^(ushort&) ((IntPtr) &osversioninfoexw + 280);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.OperatingSystem.ProductType = ^(byte&) ((IntPtr) &osversioninfoexw + 282);
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select Caption from Win32_OperatingSystem");
        using (ManagementObjectCollection.ManagementObjectEnumerator enumerator = managementObjectSearcher.Get().GetEnumerator())
        {
          if (enumerator.MoveNext())
          {
            ManagementObject current = (ManagementObject) enumerator.Current;
            SurveyData.OperatingSystem.Caption = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cclass\u0020System\u003A\u003AString\u0020\u005E\u003E(current, "Caption", ref SurveyData.DataCollectionErrorString);
          }
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_OperatingSystem WMI entry. " + ex.ToString() + "\n\n";
      }
      int num1 = \u003CModule\u003E.appIs64bitOperatingSystem() != 0U ? 1 : 0;
      SurveyData.OperatingSystem.Is64Bit = num1 != 0;
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select Capacity from Win32_PhysicalMemory");
        foreach (ManagementObject managementObject2 in managementObjectSearcher.Get())
        {
          Hardware hardware = SurveyData.Hardware;
          hardware.TotalPhysicalMemory = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020__int64\u003E(managementObject2, "Capacity", ref SurveyData.DataCollectionErrorString) + hardware.TotalPhysicalMemory;
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_PhysicalMemory WMI entry. " + ex.ToString() + "\n\n";
      }
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select Size, FreeSpace from Win32_LogicalDisk WHERE MediaType = 12");
        foreach (ManagementObject managementObject2 in managementObjectSearcher.Get())
        {
          Hardware hardware1 = SurveyData.Hardware;
          hardware1.TotalHardDriveSize = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020__int64\u003E(managementObject2, "Size", ref SurveyData.DataCollectionErrorString) + hardware1.TotalHardDriveSize;
          Hardware hardware2 = SurveyData.Hardware;
          hardware2.TotalHardDriveFreeSpace = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020__int64\u003E(managementObject2, "FreeSpace", ref SurveyData.DataCollectionErrorString) + hardware2.TotalHardDriveFreeSpace;
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_LogicalDisk WMI entry. " + ex.ToString() + "\n\n";
      }
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select * from Win32_Processor");
        foreach (ManagementObject managementObject2 in managementObjectSearcher.Get())
        {
          if (SurveyData.Hardware.ProcessorInfo.NumberOfPhysicalProcessors == 0U)
          {
            SurveyData.Hardware.ProcessorInfo.Description = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cclass\u0020System\u003A\u003AString\u0020\u005E\u003E(managementObject2, "Description", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.Family = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020short\u003E(managementObject2, "Family", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.Manufacturer = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cclass\u0020System\u003A\u003AString\u0020\u005E\u003E(managementObject2, "Manufacturer", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.MaxClockSpeed = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020int\u003E(managementObject2, "MaxClockSpeed", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.DataWidth = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020short\u003E(managementObject2, "DataWidth", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.Name = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cclass\u0020System\u003A\u003AString\u0020\u005E\u003E(managementObject2, "Name", ref SurveyData.DataCollectionErrorString);
            SurveyData.Hardware.ProcessorInfo.Features = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetCPUFeatures();
          }
          ++SurveyData.Hardware.ProcessorInfo.NumberOfPhysicalProcessors;
          string ErrStr = (string) null;
          Processors processorInfo1 = SurveyData.Hardware.ProcessorInfo;
          processorInfo1.NumberOfCores = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020int\u003E(managementObject2, "NumberOfCores", ref ErrStr) + processorInfo1.NumberOfCores;
          Processors processorInfo2 = SurveyData.Hardware.ProcessorInfo;
          processorInfo2.NumberOfLogicalProcessors = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020int\u003E(managementObject2, "NumberOfLogicalProcessors", ref ErrStr) + processorInfo2.NumberOfLogicalProcessors;
        }
        Processors processorInfo = SurveyData.Hardware.ProcessorInfo;
        if (processorInfo.NumberOfCores == 0U)
        {
          Processors processors = processorInfo;
          processors.NumberOfLogicalProcessors = processors.NumberOfPhysicalProcessors;
          SurveyData.Hardware.ProcessorInfo.NumberOfPhysicalProcessors = 0U;
          SurveyData.Hardware.ProcessorInfo.NumberOfCores = 0U;
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_Processor WMI entry. " + ex.ToString() + "\n\n";
      }
      FD3D9HardwareSurveyData hardwareSurveyData;
      \u003CModule\u003E.GetD3D9HardwareSurveyData(&hardwareSurveyData);
      SurveyData.Hardware.PrimaryVideoCard.Driver = new string((sbyte*) &hardwareSurveyData);
      SurveyData.Hardware.PrimaryVideoCard.Description = new string((sbyte*) ((IntPtr) &hardwareSurveyData + 512));
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.DriverVersion = (ulong) ^(long&) ((IntPtr) &hardwareSurveyData + 1024);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.VendorID = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1032);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.DeviceID = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1036);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.SubSysID = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1040);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.Revision = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1044);
      Guid guid = \u003CModule\u003E.FromGUID((_GUID*) ((IntPtr) &hardwareSurveyData + 1048));
      SurveyData.Hardware.PrimaryVideoCard.DeviceIdentifier = guid;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.VertexShaderVersionDX9 = (ushort) ^(int&) ((IntPtr) &hardwareSurveyData + 1064);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryVideoCard.PixelShaderVersionDX9 = (ushort) ^(int&) ((IntPtr) &hardwareSurveyData + 1068);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryMonitor.Width = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1072);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryMonitor.Height = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1076);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryMonitor.RefreshRate = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1080);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.PrimaryMonitor.BitsPerPixel = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1084);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.TotalMonitors = (uint) ^(int&) ((IntPtr) &hardwareSurveyData + 1088);
      int width = SystemInformation.VirtualScreen.Width;
      SurveyData.Hardware.PrimaryMonitor.VirtualScreenWidth = (uint) width;
      int height = SystemInformation.VirtualScreen.Height;
      SurveyData.Hardware.PrimaryMonitor.VirtualScreenHeight = (uint) height;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      int num2 = ^(int&) ((IntPtr) &hardwareSurveyData + 1092) != 0 ? 1 : 0;
      SurveyData.OperatingSystem.IsAdmin = num2 != 0;
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select * from Win32_DesktopMonitor");
        using (ManagementObjectCollection.ManagementObjectEnumerator enumerator = managementObjectSearcher.Get().GetEnumerator())
        {
          if (enumerator.MoveNext())
          {
            managementObject1 = (ManagementObject) enumerator.Current;
            ++SurveyData.Hardware.TotalVideoCards;
          }
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_DesktopMonitor WMI entry. " + ex.ToString() + "\n\n";
      }
      try
      {
        managementObjectSearcher.Query = new ObjectQuery("Select AdapterRAM from Win32_VideoController");
        using (ManagementObjectCollection.ManagementObjectEnumerator enumerator = managementObjectSearcher.Get().GetEnumerator())
        {
          if (enumerator.MoveNext())
          {
            ManagementObject current = (ManagementObject) enumerator.Current;
            SurveyData.Hardware.PrimaryVideoCard.TotalVRAM = \u003CModule\u003E.\u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020int\u003E(current, "AdapterRAM", ref SurveyData.DataCollectionErrorString);
          }
        }
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to get Win32_VideoController WMI entry. " + ex.ToString() + "\n\n";
      }
      try
      {
        \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ERecordPhysicalDimensionsOfDesktopMonitor(SurveyData);
      }
      catch (Exception ex)
      {
        SurveyData.DataCollectionErrorString += "Failed to determine physical dimensions of primary monitor. " + ex.ToString() + "\n\n";
      }
      char* chPtr1 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D291;
      char* chPtr2 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D292;
      char* chPtr3 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D293;
      char* chPtr4 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D294;
      FCompatibilityLevelInfo fcompatibilityLevelInfo;
      \u003CModule\u003E.FCompatibilityLevelInfo\u002E\u007Bctor\u007D(&fcompatibilityLevelInfo, uint.MaxValue, uint.MaxValue, uint.MaxValue);
      int num3 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D291, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D292, (int*) &fcompatibilityLevelInfo, (char*) &\u003CModule\u003E.GEngineIni);
      int num4 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D291, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D293, (int*) ((IntPtr) &fcompatibilityLevelInfo + 4), (char*) &\u003CModule\u003E.GEngineIni);
      int num5 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D291, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D294, (int*) ((IntPtr) &fcompatibilityLevelInfo + 8), (char*) &\u003CModule\u003E.GEngineIni);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.AppCompatLevelComposite = (sbyte) ^(int&) ref fcompatibilityLevelInfo;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.AppCompatLevelCPU = (sbyte) ^(int&) ((IntPtr) &fcompatibilityLevelInfo + 4);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      SurveyData.Hardware.AppCompatLevelGPU = (sbyte) ^(int&) ((IntPtr) &fcompatibilityLevelInfo + 8);
      char* chPtr5 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D295;
      char* chPtr6 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D296;
      char* chPtr7 = (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D297;
      int num6 = 0;
      int num7 = 0;
      int num8 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D295, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D297, &num7, (char*) &\u003CModule\u003E.GEngineIni);
      int num9 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D295, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D296, &num6, (char*) &\u003CModule\u003E.GEngineIni);
      SurveyData.UDKHeader.SurveysAttempted = num6;
      SurveyData.UDKHeader.SurveysFailed = num7;
      TimeSpan timeSpan = DateTime.UtcNow - utcNow;
      SurveyData.UDKHeader.SurveyTimeMS = (int) timeSpan.TotalMilliseconds;
    }
    catch (Exception ex)
    {
      SurveyData.DataCollectionErrorString += "Top-level exception in Hardware survey gathering. " + ex.ToString() + "\n\n";
    }
    if (string.IsNullOrEmpty(SurveyData.DataCollectionErrorString))
      SurveyData.DataCollectionErrorString = (string) null;
    return SurveyData;
  }

  internal static unsafe void PerformHardwareSurveyDumpCLR()
  {
    \u003CModule\u003E.FOutputDevice\u002ELogf((FOutputDevice*) \u003CModule\u003E.GLog, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D298);
    FString fstring;
    FString* fstringPtr = \u003CModule\u003E.appGameLogDir(&fstring);
    StreamWriter text;
    // ISSUE: fault handler
    try
    {
      text = File.CreateText(new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr)) + "HardwareSurvey.xml");
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring);
    new XmlSerializer(typeof (UDKSurvey)).Serialize(XmlWriter.Create((TextWriter) text, new XmlWriterSettings()
    {
      Indent = true,
      OmitXmlDeclaration = true,
      NewLineOnAttributes = true
    }), (object) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ERetrieveHardwareInfo());
  }

  internal static unsafe void PerformHardwareSurveyCLR(
    TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* OutPayload)
  {
    MemoryStream memoryStream = new MemoryStream();
    new XmlSerializer(typeof (UDKSurvey)).Serialize(XmlWriter.Create((Stream) memoryStream), (object) \u003CModule\u003E.\u003FA0x3a4a4fc4\u002ERetrieveHardwareInfo());
    byte[] array = memoryStream.ToArray();
    \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EEmpty(OutPayload, array.Length + 1);
    \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EAdd(OutPayload, array.Length + 1);
    IntPtr typedData = (IntPtr) (void*) \u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EGetTypedData(OutPayload);
    Marshal.Copy(array, 0, typedData, array.Length);
    *\u003CModule\u003E.TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(OutPayload, array.Length) = (byte) 0;
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__F\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A);

  internal static unsafe FStartPage* FStartPage\u002ECreateStartPage(
    WxStartPageHost* InParent,
    HWND__* InParentWindowHandle)
  {
    FStartPage* fstartPagePtr1 = (FStartPage*) \u003CModule\u003E.@new(16UL);
    FStartPage* fstartPagePtr2;
    // ISSUE: fault handler
    try
    {
      if ((IntPtr) fstartPagePtr1 != IntPtr.Zero)
      {
        *(long*) fstartPagePtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FStartPage\u0040\u00406B\u0040;
        \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) ((IntPtr) fstartPagePtr1 + 8L));
        // ISSUE: fault handler
        try
        {
          FStartPage* fstartPagePtr3 = fstartPagePtr1;
          \u003CModule\u003E.TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(&\u003CModule\u003E.\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, &fstartPagePtr3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) fstartPagePtr1 + 8L));
        }
        fstartPagePtr2 = fstartPagePtr1;
      }
      else
        fstartPagePtr2 = (FStartPage*) 0L;
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) fstartPagePtr1);
    }
    FStartPage* fstartPagePtr4 = (FStartPage*) ((IntPtr) fstartPagePtr2 + 8L);
    \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) fstartPagePtr4, new MStartPageControl());
    MStartPageControl mstartPageControl = \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMStartPageControl\u0040\u0040((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) fstartPagePtr4);
    if (mstartPageControl != null && mstartPageControl.InitStartPage(InParent, InParentWindowHandle) != 0U)
      return fstartPagePtr2;
    if ((IntPtr) fstartPagePtr2 != IntPtr.Zero)
    {
      FStartPage* fstartPagePtr3 = fstartPagePtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) fstartPagePtr2)((uint) fstartPagePtr3, new IntPtr(1));
    }
    return (FStartPage*) 0L;
  }

  internal static unsafe void* FStartPage\u002E__vecDelDtor([In] FStartPage* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FStartPage* fstartPagePtr = (FStartPage*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) fstartPagePtr, (__FnPtr<void (void*)>) __methodptr(FStartPage\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fstartPagePtr);
      return (void*) fstartPagePtr;
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FStartPage\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FStartPage* fstartPagePtr = obj0;
      \u003CModule\u003E.TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(&\u003CModule\u003E.\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, &fstartPagePtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
    }
    \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L));
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FStartPage\u002E\u007Bdtor\u007D([In] FStartPage* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FStartPage\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FStartPage* fstartPagePtr = obj0;
      \u003CModule\u003E.TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(&\u003CModule\u003E.\u003FStartPageInstances\u0040FStartPage\u0040\u00401V\u003F\u0024TArray\u0040PEAVFStartPage\u0040\u0040VFDefaultAllocator\u0040\u0040\u0040\u0040A, &fstartPagePtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
    }
    \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L));
  }

  internal static unsafe void FStartPage\u002EResize(
    [In] FStartPage* obj0,
    HWND__* hWndParent,
    int x,
    int y,
    int Width,
    int Height)
  {
    \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).Resize(hWndParent, x, y, Width, Height);
  }

  internal static unsafe void FStartPage\u002ESetFocus([In] FStartPage* obj0) => \u003CModule\u003E.gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMStartPageControl\u0040\u0040((gcroot\u003CMStartPageControl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L))?.SetFocus();

  internal static unsafe FLightmapResRatioWindow* FLightmapResRatioWindow\u002ECreateLightmapResRatioWindow(
    HWND__* InParentWindowHandle)
  {
    FLightmapResRatioWindow* flightmapResRatioWindowPtr1 = (FLightmapResRatioWindow*) \u003CModule\u003E.@new(16UL);
    FLightmapResRatioWindow* flightmapResRatioWindowPtr2;
    // ISSUE: fault handler
    try
    {
      flightmapResRatioWindowPtr2 = (IntPtr) flightmapResRatioWindowPtr1 == IntPtr.Zero ? (FLightmapResRatioWindow*) 0L : \u003CModule\u003E.FLightmapResRatioWindow\u002E\u007Bctor\u007D(flightmapResRatioWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) flightmapResRatioWindowPtr1);
    }
    MLightmapResRatioWindow _new_ptr = new MLightmapResRatioWindow();
    FLightmapResRatioWindow* flightmapResRatioWindowPtr3 = (FLightmapResRatioWindow*) ((IntPtr) flightmapResRatioWindowPtr2 + 8L);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr3, _new_ptr);
    if (\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr3).InitLightmapResRatioWindow(InParentWindowHandle) != 0U)
      return flightmapResRatioWindowPtr2;
    if ((IntPtr) flightmapResRatioWindowPtr2 != IntPtr.Zero)
    {
      FLightmapResRatioWindow* flightmapResRatioWindowPtr4 = flightmapResRatioWindowPtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) flightmapResRatioWindowPtr2)((uint) flightmapResRatioWindowPtr4, new IntPtr(1));
    }
    return (FLightmapResRatioWindow*) 0L;
  }

  internal static unsafe FLightmapResRatioWindow* FLightmapResRatioWindow\u002E\u007Bctor\u007D(
    [In] FLightmapResRatioWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLightmapResRatioWindow\u0040\u00406B\u0040;
      *(long*) ((IntPtr) obj0 + 8L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
        FLightmapResRatioWindow* flightmapResRatioWindowPtr1 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) flightmapResRatioWindowPtr1);
        FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
        FLightmapResRatioWindow* flightmapResRatioWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) flightmapResRatioWindowPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FLightmapResRatioWindow\u002E__vecDelDtor(
    [In] FLightmapResRatioWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FLightmapResRatioWindow* flightmapResRatioWindowPtr = (FLightmapResRatioWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) flightmapResRatioWindowPtr, (__FnPtr<void (void*)>) __methodptr(FLightmapResRatioWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) flightmapResRatioWindowPtr);
      return (void*) flightmapResRatioWindowPtr;
    }
    \u003CModule\u003E.FLightmapResRatioWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FLightmapResRatioWindow\u002E\u007Bdtor\u007D(
    [In] FLightmapResRatioWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLightmapResRatioWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FLightmapResRatioWindow* flightmapResRatioWindowPtr1;
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
        FLightmapResRatioWindow* flightmapResRatioWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) flightmapResRatioWindowPtr2);
        flightmapResRatioWindowPtr1 = (FLightmapResRatioWindow*) ((IntPtr) obj0 + 8L);
        auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* mlightmapResRatioWindowPtr = (auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr1;
        if (\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr) != null)
        {
          if ((\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr)?.Dispose();
          \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr, (MLightmapResRatioWindow) null);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* mlightmapResRatioWindowPtr1 = (auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr1;
      // ISSUE: fault handler
      try
      {
        if ((\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr1) != null ? 1 : 0) != 0)
          \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr1)?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) mlightmapResRatioWindowPtr1);
      }
      \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) mlightmapResRatioWindowPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FLightmapResRatioWindow\u002EShowWindow(
    [In] FLightmapResRatioWindow* obj0,
    uint bShow)
  {
    bool flag = bShow != 0U;
    \u003CModule\u003E.ShowWindow(\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), flag ? 5 : 0);
    if (bShow != 0U)
      return;
    \u003CModule\u003E.FLightmapResRatioWindow\u002ESaveWindowSettings(obj0);
  }

  internal static unsafe void FLightmapResRatioWindow\u002ESaveWindowSettings(
    [In] FLightmapResRatioWindow* obj0)
  {
    System.Windows.Point point = new System.Windows.Point(0.0, 0.0);
    ValueType screen = (ValueType) \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetRootVisual().PointToScreen(point);
    int x = (int) ((System.Windows.Point) screen).X;
    *(int*) ((IntPtr) \u003CModule\u003E.FLightmapResRatioAdjustSettings\u002EGet() + 64L) = x;
    int y = (int) ((System.Windows.Point) screen).Y;
    *(int*) ((IntPtr) \u003CModule\u003E.FLightmapResRatioAdjustSettings\u002EGet() + 68L) = y;
  }

  internal static unsafe void FLightmapResRatioWindow\u002ESend(
    [In] FLightmapResRatioWindow* obj0,
    ECallbackEventType Event)
  {
    FLightmapResRatioWindow* flightmapResRatioWindowPtr = (FLightmapResRatioWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr) == null)
      return;
    FrameworkElement rootVisual = (FrameworkElement) \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) flightmapResRatioWindowPtr).GetRootVisual();
    if (Event != (ECallbackEventType) 65)
    {
      if (Event != (ECallbackEventType) 66)
        return;
      rootVisual.IsEnabled = true;
    }
    else
      rootVisual.IsEnabled = false;
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGDirectorFrame\u0040MatineeWindows\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGDirectorFrame\u0040MatineeWindows\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGDirectorFrame\u0040MatineeWindows\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGDirectorPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGDirectorPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGDirectorPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper);

  internal static unsafe void MatineeWindows\u002ELaunchDirectorWindow(WxInterpEd* InInterpEd)
  {
    \u003CModule\u003E.MatineeWindows\u002ECloseDirectorWindow(InInterpEd);
    WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D300, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D299, (char*) 0L);
    // ISSUE: fault handler
    try
    {
      FString fstring2;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
      // ISSUE: fault handler
      try
      {
        string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
        InSettings.WindowTitle = str;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring3;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D301);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame, new MWPFFrame((wxWindow*) InInterpEd, InSettings, &fstring3));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper, new MDirectorPanelHelper());
    List<MWPFPanel> directorPanelList = \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper).DirectorPanelList;
    FString fstring4;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D302);
    MDirectorViewportLayoutPanel viewportLayoutPanel;
    // ISSUE: fault handler
    try
    {
      viewportLayoutPanel = new MDirectorViewportLayoutPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
    directorPanelList.Add((MWPFPanel) viewportLayoutPanel);
    FString fstring5;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring5, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D303);
    MViewportPanel InNewPreviewPanel;
    // ISSUE: fault handler
    try
    {
      InNewPreviewPanel = new MViewportPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring5), 0, \u003CModule\u003E.FString\u002ELen(&fstring5)), \u003CModule\u003E.SHOW_DefaultGame);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
    InNewPreviewPanel.ConnectToMatineeCamera(InInterpEd, -1);
    viewportLayoutPanel.SetPreviewViewport(InNewPreviewPanel);
    directorPanelList.Add((MWPFPanel) InNewPreviewPanel);
    FString fstring6;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring6, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D304);
    MDirectorControlPanel InNewControlPanel;
    // ISSUE: fault handler
    try
    {
      InNewControlPanel = new MDirectorControlPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring6), 0, \u003CModule\u003E.FString\u002ELen(&fstring6)));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring6);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring6);
    viewportLayoutPanel.SetControlPanel(InNewControlPanel);
    InNewControlPanel.SetMatinee(InInterpEd);
    directorPanelList.Add((MWPFPanel) InNewControlPanel);
    TStaticBitArray\u003C128\u003E InShowFlags;
    \u003CModule\u003E.\u007C(&InShowFlags, &\u003CModule\u003E.SHOW_DefaultEditor, &\u003CModule\u003E.SHOW_ViewMode_LightingOnly);
    int numCameraActors = \u003CModule\u003E.WxInterpEd\u002EGetNumCameraActors(InInterpEd);
    int InCameraIndex = 0;
    if (0 < numCameraActors)
    {
      do
      {
        FString fstring2;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D305);
        MViewportPanel InNewViewportPanel;
        // ISSUE: fault handler
        try
        {
          InNewViewportPanel = new MViewportPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2)), InShowFlags);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        InNewViewportPanel.ConnectToMatineeCamera(InInterpEd, InCameraIndex);
        viewportLayoutPanel.AddViewport(InNewViewportPanel);
        directorPanelList.Add((MWPFPanel) InNewViewportPanel);
        ++InCameraIndex;
      }
      while (InCameraIndex < numCameraActors);
    }
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame).Raise();
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame).SetContentAndShowComposite((ContentControl) viewportLayoutPanel, directorPanelList);
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame).GetEventBorder().KeyDown += new System.Windows.Input.KeyEventHandler(viewportLayoutPanel.OnKeyPressed);
    if (!(InSettings is IDisposable disposable))
      return;
    disposable.Dispose();
  }

  internal static unsafe void MatineeWindows\u002ECloseDirectorWindow(WxInterpEd* InInterpEd)
  {
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame) != null)
    {
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGDirectorFrame)?.Dispose();
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ref gcrootMwpfFrame = (long) num.ToPointer();
      // ISSUE: fault handler
      try
      {
        MWPFFrame mwpfFrame = \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ((GCHandle) new IntPtr((void*) ^(long&) ref \u003CModule\u003E.MatineeWindows\u002EGDirectorFrame)).Target = (object) mwpfFrame;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
      }
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
    }
    if (\u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMDirectorPanelHelper\u0040MatineeWindows\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMDirectorPanelHelper\u0040MatineeWindows\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.MatineeWindows\u002EGDirectorPanelHelper, (MDirectorPanelHelper) null);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGRecordFrame\u0040MatineeWindows\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGRecordFrame);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGRecordFrame\u0040MatineeWindows\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGRecordFrame\u0040MatineeWindows\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGRecordFrame);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGRecordPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGRecordPanelHelper);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGRecordPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGRecordPanelHelper\u0040MatineeWindows\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.MatineeWindows\u002EGRecordPanelHelper);

  internal static unsafe void MatineeWindows\u002ECloseRecordWindow(WxInterpEd* InInterpEd)
  {
    if (\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGRecordFrame) != null)
    {
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGRecordFrame)?.Dispose();
      IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
      gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ref gcrootMwpfFrame = (long) num.ToPointer();
      // ISSUE: fault handler
      try
      {
        MWPFFrame mwpfFrame = \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ((GCHandle) new IntPtr((void*) ^(long&) ref \u003CModule\u003E.MatineeWindows\u002EGRecordFrame)).Target = (object) mwpfFrame;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
      }
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
    }
    if (\u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMRecordPanelHelper\u0040MatineeWindows\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGRecordPanelHelper) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMRecordPanelHelper\u0040MatineeWindows\u0040\u0040(&\u003CModule\u003E.MatineeWindows\u002EGRecordPanelHelper)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.MatineeWindows\u002EGRecordPanelHelper, (MRecordPanelHelper) null);
  }

  internal static void MatineeWindows\u002EFocusRecordWindow()
  {
  }

  internal static unsafe void ObjectTools\u002EFConsolidationResults\u002E\u007Bdtor\u007D(
    [In] FConsolidationResults* obj0)
  {
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 40L));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
        }
        \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 24L));
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 8L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FSerializableObject\u002E\u007Bdtor\u007D((FSerializableObject*) obj0);
  }

  internal static unsafe void FConsolidateWindow\u002EShutdown()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
    {
      FConsolidateWindow* fconsolidateWindow0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA)((uint) fconsolidateWindow0PeaV1Ea, new IntPtr(1));
    }
    \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA = (FConsolidateWindow*) 0L;
  }

  internal static unsafe void FConsolidateWindow\u002EAddConsolidationObjects(
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* InObjects,
    TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* InResourceTypes)
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FConsolidateWindow* fconsolidateWindowPtr1 = (FConsolidateWindow*) \u003CModule\u003E.@new(32UL);
      FConsolidateWindow* fconsolidateWindowPtr2;
      // ISSUE: fault handler
      try
      {
        fconsolidateWindowPtr2 = (IntPtr) fconsolidateWindowPtr1 == IntPtr.Zero ? (FConsolidateWindow*) 0L : \u003CModule\u003E.FConsolidateWindow\u002E\u007Bctor\u007D(fconsolidateWindowPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fconsolidateWindowPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA = fconsolidateWindowPtr2;
    }
    FConsolidateWindow* fconsolidateWindow0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA;
    FConsolidateWindow* fconsolidateWindowPtr3 = (FConsolidateWindow*) ((IntPtr) fconsolidateWindow0PeaV1Ea + 24L);
    int num1 = \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3).AddConsolidationObjects(InObjects, InResourceTypes);
    FConsolidateWindow* fconsolidateWindowPtr4 = (FConsolidateWindow*) ((IntPtr) fconsolidateWindow0PeaV1Ea + 16L);
    uint num2 = (uint) \u003CModule\u003E.IsWindowVisible(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr4).GetWindowHandle());
    if (num1 == 0 || num2 != 0U)
      return;
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr4).SetContentAndShow((MWPFPanel) \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMConsolidateObjectsPanel\u0040\u0040((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3));
  }

  internal static unsafe uint FConsolidateWindow\u002EDetermineAssetCompatibility(
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* InProposedObjects,
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* OutCompatibleObjects)
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FConsolidateWindow* fconsolidateWindowPtr1 = (FConsolidateWindow*) \u003CModule\u003E.@new(32UL);
      FConsolidateWindow* fconsolidateWindowPtr2;
      // ISSUE: fault handler
      try
      {
        fconsolidateWindowPtr2 = (IntPtr) fconsolidateWindowPtr1 == IntPtr.Zero ? (FConsolidateWindow*) 0L : \u003CModule\u003E.FConsolidateWindow\u002E\u007Bctor\u007D(fconsolidateWindowPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fconsolidateWindowPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA = fconsolidateWindowPtr2;
    }
    return \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FConsolidateWindow\u0040\u00400PEAV1\u0040EA + 24L)).DetermineAssetCompatibility(InProposedObjects, OutCompatibleObjects);
  }

  internal static unsafe void FConsolidateWindow\u002ESerialize(
    [In] FConsolidateWindow* obj0,
    FArchive* Ar)
  {
    TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E fdefaultAllocator;
    \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(&fdefaultAllocator);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) ((IntPtr) obj0 + 24L)).QuerySerializableObjects(&fdefaultAllocator);
      TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E fdefaultAllocatorInt;
      \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(&fdefaultAllocatorInt, &fdefaultAllocator);
      if (\u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(&fdefaultAllocatorInt))
      {
        do
        {
          UObject* uobjectPtr = (UObject*) *(long*) \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(&fdefaultAllocatorInt);
          FArchive* farchivePtr1 = Ar;
          ref UObject* local = ref uobjectPtr;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          FArchive* farchivePtr2 = __calli((__FnPtr<FArchive* (IntPtr, UObject**)>) *(long*) (*(long*) Ar + 48L))((UObject**) farchivePtr1, (IntPtr) ref local);
          \u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(&fdefaultAllocatorInt);
        }
        while (\u003CModule\u003E.TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(&fdefaultAllocatorInt));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) &fdefaultAllocator);
    }
    \u003CModule\u003E.TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(&fdefaultAllocator);
  }

  internal static unsafe void FConsolidateWindow\u002ESend(
    [In] FConsolidateWindow* obj0,
    ECallbackEventType InType,
    uint InFlag)
  {
    if (InType != (ECallbackEventType) 2 || InFlag == 0U)
      return;
    \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) ((IntPtr) obj0 + 16L)).ClearConsolidationObjects();
  }

  internal static unsafe FConsolidateWindow* FConsolidateWindow\u002E\u007Bctor\u007D(
    [In] FConsolidateWindow* obj0)
  {
    \u003CModule\u003E.FSerializableObject\u002E\u007Bctor\u007D((FSerializableObject*) obj0);
    // ISSUE: fault handler
    try
    {
      FConsolidateWindow* fconsolidateWindowPtr1 = (FConsolidateWindow*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) fconsolidateWindowPtr1);
      // ISSUE: fault handler
      try
      {
        *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FConsolidateWindow\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
        *(long*) fconsolidateWindowPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FConsolidateWindow\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
        FConsolidateWindow* fconsolidateWindowPtr2 = (FConsolidateWindow*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr2);
        // ISSUE: fault handler
        try
        {
          FConsolidateWindow* fconsolidateWindowPtr3 = (FConsolidateWindow*) ((IntPtr) obj0 + 24L);
          \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3);
          // ISSUE: fault handler
          try
          {
            FConsolidateWindow* fconsolidateWindowPtr4 = fconsolidateWindowPtr1;
            FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
            FConsolidateWindow* fconsolidateWindowPtr5 = fconsolidateWindowPtr4;
            // ISSUE: cast to a function pointer type
            // ISSUE: function pointer call
            __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent, (ECallbackEventType) 2, (IntPtr) fconsolidateWindowPtr5);
            WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
            FString fstring1;
            FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D317, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D316, (char*) 0L);
            // ISSUE: fault handler
            try
            {
              FString fstring2;
              \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
              // ISSUE: fault handler
              try
              {
                string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
                InSettings.WindowTitle = str;
              }
              __fault
              {
                // ISSUE: method pointer
                // ISSUE: cast to a function pointer type
                \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
              }
              \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
            InSettings.bForceToFront = 1U;
            InSettings.bUseWxDialog = 0U;
            FString fstring3;
            \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D318);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr2, new MWPFFrame((wxWindow*) 0L, InSettings, &fstring3));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
            FString fstring4;
            \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D319);
            // ISSUE: fault handler
            try
            {
              string InXamlName = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4));
              \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3, new MConsolidateObjectsPanel(InXamlName));
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
            if (InSettings is IDisposable disposable8)
              disposable8.Dispose();
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
          }
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FConsolidateWindow\u002E__vecDelDtor(
    [In] FConsolidateWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FConsolidateWindow* fconsolidateWindowPtr = (FConsolidateWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 32UL, *(int*) fconsolidateWindowPtr, (__FnPtr<void (void*)>) __methodptr(FConsolidateWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fconsolidateWindowPtr);
      return (void*) fconsolidateWindowPtr;
    }
    \u003CModule\u003E.FConsolidateWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FConsolidateWindow\u002E\u007Bdtor\u007D([In] FConsolidateWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FConsolidateWindow\u0040\u00406BFSerializableObject\u0040\u0040\u0040;
    FConsolidateWindow* fconsolidateWindowPtr1 = (FConsolidateWindow*) ((IntPtr) obj0 + 8L);
    *(long*) fconsolidateWindowPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FConsolidateWindow\u0040\u00406BFCallbackEventDevice\u0040\u0040\u0040;
    // ISSUE: fault handler
    try
    {
      // ISSUE: fault handler
      try
      {
        FConsolidateWindow* fconsolidateWindowPtr2;
        // ISSUE: fault handler
        try
        {
          FConsolidateWindow* fconsolidateWindowPtr3;
          // ISSUE: fault handler
          try
          {
            fconsolidateWindowPtr2 = (FConsolidateWindow*) ((IntPtr) obj0 + 16L);
            \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr2)?.Dispose();
            fconsolidateWindowPtr3 = (FConsolidateWindow*) ((IntPtr) obj0 + 24L);
            \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMConsolidateObjectsPanel\u0040\u0040((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3)?.Dispose();
            IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
            gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(long&) ref gcrootMwpfFrame = (long) num1.ToPointer();
            // ISSUE: fault handler
            try
            {
              ((GCHandle) new IntPtr((void*) *(long*) fconsolidateWindowPtr2)).Target = (object) \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
            }
            \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
            IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
            gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E mconsolidateObjectsPanel;
            // ISSUE: cast to a reference type
            // ISSUE: explicit reference operation
            ^(long&) ref mconsolidateObjectsPanel = (long) num2.ToPointer();
            // ISSUE: fault handler
            try
            {
              ((GCHandle) new IntPtr((void*) *(long*) fconsolidateWindowPtr3)).Target = (object) \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMConsolidateObjectsPanel\u0040\u0040(&mconsolidateObjectsPanel);
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &mconsolidateObjectsPanel);
            }
            \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&mconsolidateObjectsPanel);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 24L));
          }
          \u003CModule\u003E.gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E*) fconsolidateWindowPtr3);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fconsolidateWindowPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) fconsolidateWindowPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FSerializableObject\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FSerializableObject\u002E\u007Bdtor\u007D((FSerializableObject*) obj0);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__EGFileNotificationWrapper\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bctor\u007D(&\u003CModule\u003E.GFileNotificationWrapper);
    // ISSUE: method pointer
    // ISSUE: cast to a function pointer type
    \u003CModule\u003E._atexit_m((__FnPtr<void ()>) __methodptr(\u003FA0x3a4a4fc4\u002E\u003F\u003F__FGFileNotificationWrapper\u0040\u0040YMXXZ));
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__FGFileNotificationWrapper\u0040\u0040YMXXZ() => \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&\u003CModule\u003E.GFileNotificationWrapper);

  internal static unsafe void TickFileSystemNotifications()
  {
    if (\u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&\u003CModule\u003E.GFileNotificationWrapper) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GFileNotificationWrapper).ProcessEvents();
  }

  internal static unsafe void SetFileSystemNotification(FString* InExtension, uint InStart)
  {
    if (InStart != 0U)
    {
      if (\u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&\u003CModule\u003E.GFileNotificationWrapper) == null)
        \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u003D(&\u003CModule\u003E.GFileNotificationWrapper, new MFileSystemNotificationWrapper());
      string InExtension1 = new string(\u003CModule\u003E.FString\u002E\u002A(InExtension), 0, \u003CModule\u003E.FString\u002ELen(InExtension));
      \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GFileNotificationWrapper).AddExtension(InExtension1);
    }
    else
    {
      if (\u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&\u003CModule\u003E.GFileNotificationWrapper) == null)
        return;
      string InExtension1 = new string(\u003CModule\u003E.FString\u002E\u002A(InExtension), 0, \u003CModule\u003E.FString\u002ELen(InExtension));
      \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002D\u003E(&\u003CModule\u003E.GFileNotificationWrapper).RemoveExtension(InExtension1);
    }
  }

  internal static unsafe void SetFileSystemNotificationsForEditor(
    uint bTextureListenOnOff,
    uint bApexListenOnOff)
  {
    FString fstring1;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D320);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring1, bTextureListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring2;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D321);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring2, bTextureListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    FString fstring3;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D322);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring3, bTextureListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
    FString fstring4;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D323);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring4, bTextureListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
    FString fstring5;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring5, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D324);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring5, bTextureListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring5);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring5);
    FString fstring6;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring6, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D325);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring6, bApexListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring6);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring6);
    FString fstring7;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring7, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D326);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring7, bApexListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring7);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring7);
  }

  internal static unsafe void SetFileSystemNotificationsForAnimSet(uint bAnimSetListenOnOff)
  {
    FString fstring1;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D327);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring1, bAnimSetListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring2;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D328);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring2, bAnimSetListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    FString fstring3;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D329);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.SetFileSystemNotification(&fstring3, bAnimSetListenOnOff);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
  }

  internal static unsafe void CloseFileSystemNotification()
  {
    if (\u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&\u003CModule\u003E.GFileNotificationWrapper) == null)
      return;
    if (\u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&\u003CModule\u003E.GFileNotificationWrapper) is IDisposable disposable)
      disposable.Dispose();
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E notificationWrapper1;
    // ISSUE: cast to a reference type
    // ISSUE: explicit reference operation
    ^(long&) ref notificationWrapper1 = (long) num.ToPointer();
    // ISSUE: fault handler
    try
    {
      MFileSystemNotificationWrapper notificationWrapper2 = \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(&notificationWrapper1);
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ((GCHandle) new IntPtr((void*) ^(long&) ref \u003CModule\u003E.GFileNotificationWrapper)).Target = (object) notificationWrapper2;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &notificationWrapper1);
    }
    \u003CModule\u003E.gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&notificationWrapper1);
  }

  internal static unsafe void FEditorBuildUtils\u002EFEditorAutomatedBuildSettings\u002E\u007Bdtor\u007D(
    [In] FEditorBuildUtils.FEditorAutomatedBuildSettings* obj0)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 52L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 28L));
    }
    \u003CModule\u003E.TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFString\u002CFDefaultAllocator\u003E*) ((IntPtr) obj0 + 28L));
  }

  internal static unsafe void BuildWindows\u002EPromptForBuildAndSubmit(
    FSourceControlEventListener* InEventListener)
  {
    WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D331, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D330, (char*) 0L);
    // ISSUE: fault handler
    try
    {
      string str = new string(\u003CModule\u003E.FString\u002E\u002A(fstringPtr), 0, \u003CModule\u003E.FString\u002ELen(fstringPtr));
      InSettings.WindowTitle = str;
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring2;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D332);
    MWPFFrame mwpfFrame;
    // ISSUE: fault handler
    try
    {
      mwpfFrame = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    FString fstring3;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D333);
    MBuildAndSubmitPanel mbuildAndSubmitPanel;
    // ISSUE: fault handler
    try
    {
      mbuildAndSubmitPanel = new MBuildAndSubmitPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring3), 0, \u003CModule\u003E.FString\u002ELen(&fstring3)), InEventListener);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
    mwpfFrame.SetContentAndShowModal((MWPFPanel) mbuildAndSubmitPanel, 0);
    if (InSettings is IDisposable disposable)
      disposable.Dispose();
    mwpfFrame?.Dispose();
  }

  internal static unsafe FLightingToolsWindow* FLightingToolsWindow\u002ECreateLightingToolsWindow(
    HWND__* InParentWindowHandle)
  {
    FLightingToolsWindow* flightingToolsWindowPtr1 = (FLightingToolsWindow*) \u003CModule\u003E.@new(16UL);
    FLightingToolsWindow* flightingToolsWindowPtr2;
    // ISSUE: fault handler
    try
    {
      flightingToolsWindowPtr2 = (IntPtr) flightingToolsWindowPtr1 == IntPtr.Zero ? (FLightingToolsWindow*) 0L : \u003CModule\u003E.FLightingToolsWindow\u002E\u007Bctor\u007D(flightingToolsWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) flightingToolsWindowPtr1);
    }
    if (\u003CModule\u003E.FLightingToolsWindow\u002EInitLightingToolsWindow(flightingToolsWindowPtr2, InParentWindowHandle) != 0U)
      return flightingToolsWindowPtr2;
    if ((IntPtr) flightingToolsWindowPtr2 != IntPtr.Zero)
    {
      FLightingToolsWindow* flightingToolsWindowPtr3 = flightingToolsWindowPtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) flightingToolsWindowPtr2)((uint) flightingToolsWindowPtr3, new IntPtr(1));
    }
    return (FLightingToolsWindow*) 0L;
  }

  internal static unsafe FLightingToolsWindow* FLightingToolsWindow\u002E\u007Bctor\u007D(
    [In] FLightingToolsWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLightingToolsWindow\u0040\u00406B\u0040;
      *(long*) ((IntPtr) obj0 + 8L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
        FLightingToolsWindow* flightingToolsWindowPtr1 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) flightingToolsWindowPtr1);
        FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
        FLightingToolsWindow* flightingToolsWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) flightingToolsWindowPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FLightingToolsWindow\u002E__vecDelDtor(
    [In] FLightingToolsWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FLightingToolsWindow* flightingToolsWindowPtr = (FLightingToolsWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) flightingToolsWindowPtr, (__FnPtr<void (void*)>) __methodptr(FLightingToolsWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) flightingToolsWindowPtr);
      return (void*) flightingToolsWindowPtr;
    }
    \u003CModule\u003E.FLightingToolsWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FLightingToolsWindow\u002E\u007Bdtor\u007D([In] FLightingToolsWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLightingToolsWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FLightingToolsWindow* flightingToolsWindowPtr1;
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
        FLightingToolsWindow* flightingToolsWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) flightingToolsWindowPtr2);
        flightingToolsWindowPtr1 = (FLightingToolsWindow*) ((IntPtr) obj0 + 8L);
        auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* mlightingToolsWindowPtr = (auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr1;
        if (\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr) != null)
        {
          if ((\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr)?.Dispose();
          \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr, (MLightingToolsWindow) null);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* mlightingToolsWindowPtr1 = (auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr1;
      // ISSUE: fault handler
      try
      {
        if ((\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr1) != null ? 1 : 0) != 0)
          \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr1)?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) mlightingToolsWindowPtr1);
      }
      \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) mlightingToolsWindowPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe uint FLightingToolsWindow\u002EInitLightingToolsWindow(
    [In] FLightingToolsWindow* obj0,
    HWND__* InParentWindowHandle)
  {
    MLightingToolsWindow _new_ptr = new MLightingToolsWindow();
    FLightingToolsWindow* flightingToolsWindowPtr = (FLightingToolsWindow*) ((IntPtr) obj0 + 8L);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr, _new_ptr);
    int num1 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D335, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D334, (int*) ((IntPtr) \u003CModule\u003E.FLightingToolsSettings\u002EGet() + 28L), (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    int num2 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D337, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D336, (int*) ((IntPtr) \u003CModule\u003E.FLightingToolsSettings\u002EGet() + 32L), (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    return \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr).InitLightingToolsWindow(obj0, InParentWindowHandle);
  }

  internal static unsafe void FLightingToolsWindow\u002EShowWindow(
    [In] FLightingToolsWindow* obj0,
    uint bShow)
  {
    bool flag = bShow != 0U;
    \u003CModule\u003E.ShowWindow(\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), flag ? 5 : 0);
    if (bShow != 0U)
      \u003CModule\u003E.FLightingToolsSettings\u002EInit();
    else
      \u003CModule\u003E.FLightingToolsWindow\u002ESaveWindowSettings(obj0);
  }

  internal static unsafe void FLightingToolsWindow\u002ESaveWindowSettings(
    [In] FLightingToolsWindow* obj0)
  {
    System.Windows.Point point = new System.Windows.Point(0.0, 0.0);
    ValueType screen = (ValueType) \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetRootVisual().PointToScreen(point);
    int x = (int) ((System.Windows.Point) screen).X;
    *(int*) ((IntPtr) \u003CModule\u003E.FLightingToolsSettings\u002EGet() + 28L) = x;
    int y = (int) ((System.Windows.Point) screen).Y;
    *(int*) ((IntPtr) \u003CModule\u003E.FLightingToolsSettings\u002EGet() + 32L) = y;
    \u003CModule\u003E.FConfigCacheIni\u002ESetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D339, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D338, (int) ((System.Windows.Point) screen).X, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    \u003CModule\u003E.FConfigCacheIni\u002ESetInt(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D341, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D340, (int) ((System.Windows.Point) screen).Y, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
  }

  internal static unsafe void FLightingToolsWindow\u002ESend(
    [In] FLightingToolsWindow* obj0,
    ECallbackEventType Event)
  {
    FLightingToolsWindow* flightingToolsWindowPtr = (FLightingToolsWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr) == null)
      return;
    FrameworkElement rootVisual = (FrameworkElement) \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) flightingToolsWindowPtr).GetRootVisual();
    if (Event != (ECallbackEventType) 65)
    {
      if (Event != (ECallbackEventType) 66)
        return;
      rootVisual.IsEnabled = true;
    }
    else
      rootVisual.IsEnabled = false;
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040VecZero\u0040\u0040YMXXZ() => \u003CModule\u003E.FVector\u002E\u007Bctor\u007D(&\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EVecZero, 0.0f, 0.0f, 0.0f);

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040SixteenSampleOffsets\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets, -1.5f, -1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 8), -0.5f, -1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 16), 0.5f, -1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 24), 1.5f, -1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 32), -1.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 40), -0.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 48), 0.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 56), 1.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 64), -1.5f, 0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 72), -0.5f, 0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 80), 0.5f, 0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 88), 1.5f, 0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 96), -1.5f, 1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 104), -0.5f, 1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 112), 0.5f, 1.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ESixteenSampleOffsets + 120), 1.5f, 1.5f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040FourSampleOffsets\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourSampleOffsets, -0.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourSampleOffsets + 8), 0.5f, -0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourSampleOffsets + 16), -0.5f, 0.5f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourSampleOffsets + 24), 0.5f, 0.5f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040FourEdgeSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourEdgeSamples, -0.096732f, 0.99531f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourEdgeSamples + 8), 0.260201f, -0.965555f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourEdgeSamples + 16), 0.901758f, 0.432242f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourEdgeSamples + 24), -0.976801f, -0.214147f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040EightEdgeSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples, -0.046244f, -0.99893f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 8), 0.316557f, 0.948573f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 16), -0.958236f, 0.285978f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 24), 0.912094f, -0.409981f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 32), -0.961936f, -0.273275f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 40), 0.982681f, 0.185307f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 48), -0.221212f, 0.975226f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightEdgeSamples + 56), 0.794196f, -0.607661f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040FourRefiningSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourRefiningSamples, 0.546429f, 0.291679f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourRefiningSamples + 8), -0.327817f, 0.058277f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourRefiningSamples + 16), -0.158216f, -0.463566f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EFourRefiningSamples + 24), 0.487845f, -0.512424f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040EightRefiningSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples, -0.071794f, -0.767445f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 8), 0.419721f, -0.704903f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 16), -0.000848f, -0.000485f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 24), -0.592816f, -0.303198f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 32), 0.841066f, -0.308718f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 40), 0.228044f, 0.84817f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 48), 0.612645f, 0.200965f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EEightRefiningSamples + 56), -0.588486f, 0.690574f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040TwelveRefiningSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples, 0.838311f, -0.535163f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 8), 0.250466f, -0.220627f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 16), 0.387744f, -0.548799f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 24), -0.512371f, 0.570049f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 32), -0.907283f, 0.113584f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 40), -0.738344f, -0.505436f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 48), 0.085194f, 0.305618f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 56), -0.293107f, -0.016795f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 64), 0.027704f, 0.708739f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 72), 0.053306f, -0.594006f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 80), 0.345382f, -0.909465f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwelveRefiningSamples + 88), -0.586266f, -0.229196f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040TwentyFourRefiningSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples, -0.840328f, 0.541797f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 8), 0.662232f, -0.656196f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 16), 0.559291f, 0.435458f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 24), -0.025865f, -0.064991f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 32), 0.83504f, 0.210535f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 40), 0.271059f, -0.505058f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 48), 0.248493f, 0.767084f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 56), -1013f / (625f * Math.E), 0.621869f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 64), -0.326291f, 0.1755f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 72), 0.643448f, -0.439298f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 80), -0.406031f, -0.841996f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 88), -0.795511f, -0.105329f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 96), 0.309025f, 0.352076f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 104), -0.162909f, 0.375198f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 112), -0.726905f, -0.446674f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 120), 0.027331f, -0.337222f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 128), 0.543546f, 0.735876f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 136), 0.309095f, -0.710946f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 144), -0.58279f, 0.154986f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 152), -0.20346f, -0.272108f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 160), 0.491919f, -0.171667f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 168), -0.405075f, -0.44773f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 176), -0.416467f, -0.07239f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002ETwentyFourRefiningSamples + 184), -0.025764f, 0.565929f);
  }

  internal static unsafe void \u003FA0x3a4a4fc4\u002E\u003F\u003F__E\u003FA0x3a4a4fc4\u0040ThirtyTwoRefiningSamples\u0040\u0040YMXXZ()
  {
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples, 0.522456f, 0.010821f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 8), 0.948822f, -0.133876f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 16), -0.25035f, -0.478179f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 24), -0.200341f, -0.181412f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 32), -0.216907f, 0.163176f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 40), 0.444341f, 0.582881f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 48), 0.318114f, -0.339968f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 56), 0.323013f, 0.893671f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 64), 0.103426f, 0.394928f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 72), 0.11775f, -0.064166f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 80), -0.54017f, -0.51283f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 88), 0.198264f, 0.719767f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 96), -0.446541f, 0.255523f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 104), -0.154845f, 0.399522f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 112), -0.132838f, -0.897569f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 120), -0.619868f, 0.685406f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 128), 0.359397f, 0.23167f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 136), -0.027417f, 0.040958f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 144), -0.044174f, -0.529273f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 152), 0.50418f, -0.377851f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 160), 0.175422f, 0.213013f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 168), -0.039336f, 0.7999f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 176), -0.28338f, -0.786142f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 184), 0.241633f, 0.61417f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 192), -0.948119f, 0.020092f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 200), 0.584043f, 0.276241f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 208), -0.052446f, 0.235604f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 216), -0.077916f, -0.310481f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 224), 0.139518f, -0.312672f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 232), -0.371752f, 0.465338f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 240), 0.28738f, -0.041448f);
    \u003CModule\u003E.FVector2D\u002E\u007Bctor\u007D((FVector2D*) ((IntPtr) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002EThirtyTwoRefiningSamples + 248), 0.202267f, -0.726132f);
  }

  internal static unsafe void FGizmoImportLayer\u002E\u007Bdtor\u007D([In] FGizmoImportLayer* obj0)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 16L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) obj0);
  }

  internal static unsafe FLandscapeEditWindow* FLandscapeEditWindow\u002ECreateLandscapeEditWindow(
    FEdModeLandscape* InLandscapeEditSystem,
    HWND__* InParentWindowHandle)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr1 = (FLandscapeEditWindow*) \u003CModule\u003E.@new(16UL);
    FLandscapeEditWindow* flandscapeEditWindowPtr2;
    // ISSUE: fault handler
    try
    {
      flandscapeEditWindowPtr2 = (IntPtr) flandscapeEditWindowPtr1 == IntPtr.Zero ? (FLandscapeEditWindow*) 0L : \u003CModule\u003E.FLandscapeEditWindow\u002E\u007Bctor\u007D(flandscapeEditWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) flandscapeEditWindowPtr1);
    }
    MLandscapeEditWindow _new_ptr = new MLandscapeEditWindow(InLandscapeEditSystem);
    FLandscapeEditWindow* flandscapeEditWindowPtr3 = (FLandscapeEditWindow*) ((IntPtr) flandscapeEditWindowPtr2 + 8L);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr3, _new_ptr);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr3).InitLandscapeEditWindow(InParentWindowHandle) != 0U)
      return flandscapeEditWindowPtr2;
    if ((IntPtr) flandscapeEditWindowPtr2 != IntPtr.Zero)
    {
      FLandscapeEditWindow* flandscapeEditWindowPtr4 = flandscapeEditWindowPtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) flandscapeEditWindowPtr2)((uint) flandscapeEditWindowPtr4, new IntPtr(1));
    }
    return (FLandscapeEditWindow*) 0L;
  }

  internal static unsafe FLandscapeEditWindow* FLandscapeEditWindow\u002E\u007Bctor\u007D(
    [In] FLandscapeEditWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLandscapeEditWindow\u0040\u00406B\u0040;
      *(long*) ((IntPtr) obj0 + 8L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr1 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) flandscapeEditWindowPtr1);
        FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) flandscapeEditWindowPtr2);
        FCallbackEventObserver* gcallbackEvent3 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr3 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent3, (ECallbackEventType) 2, (IntPtr) flandscapeEditWindowPtr3);
        FCallbackEventObserver* gcallbackEvent4 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr4 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent4, (ECallbackEventType) 4, (IntPtr) flandscapeEditWindowPtr4);
        FCallbackEventObserver* gcallbackEvent5 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr5 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent5, (ECallbackEventType) 36, (IntPtr) flandscapeEditWindowPtr5);
        FCallbackEventObserver* gcallbackEvent6 = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr6 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent6, (ECallbackEventType) 81, (IntPtr) flandscapeEditWindowPtr6);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FLandscapeEditWindow\u002E__vecDelDtor(
    [In] FLandscapeEditWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) flandscapeEditWindowPtr, (__FnPtr<void (void*)>) __methodptr(FLandscapeEditWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) flandscapeEditWindowPtr);
      return (void*) flandscapeEditWindowPtr;
    }
    \u003CModule\u003E.FLandscapeEditWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FLandscapeEditWindow\u002E\u007Bdtor\u007D([In] FLandscapeEditWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FLandscapeEditWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FLandscapeEditWindow* flandscapeEditWindowPtr1;
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
        FLandscapeEditWindow* flandscapeEditWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) flandscapeEditWindowPtr2);
        flandscapeEditWindowPtr1 = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
        auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* mlandscapeEditWindowPtr = (auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr1;
        if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr) != null)
        {
          if ((\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr)?.Dispose();
          \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr, (MLandscapeEditWindow) null);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* mlandscapeEditWindowPtr1 = (auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr1;
      // ISSUE: fault handler
      try
      {
        if ((\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr1) != null ? 1 : 0) != 0)
          \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr1)?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) mlandscapeEditWindowPtr1);
      }
      \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) mlandscapeEditWindowPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FLandscapeEditWindow\u002ESaveWindowSettings(
    [In] FLandscapeEditWindow* obj0)
  {
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).SaveWindowSettings();
  }

  internal static unsafe void FLandscapeEditWindow\u002ESend(
    [In] FLandscapeEditWindow* obj0,
    ECallbackEventType Event)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr) == null)
      return;
    FrameworkElement rootVisual = (FrameworkElement) \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).GetRootVisual();
    switch (Event)
    {
      case (ECallbackEventType) 2:
      case (ECallbackEventType) 4:
      case (ECallbackEventType) 36:
        \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).UpdateLandscapeList();
        break;
      case (ECallbackEventType) 65:
        rootVisual.IsEnabled = false;
        break;
      case (ECallbackEventType) 66:
        rootVisual.IsEnabled = true;
        break;
      case (ECallbackEventType) 81:
        \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).UpdateTargets();
        break;
    }
  }

  internal static unsafe void FLandscapeEditWindow\u002ENotifyCurrentToolChanged(
    [In] FLandscapeEditWindow* obj0,
    FString* ToolSetName)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr) == null)
      return;
    string ToolSetName1 = new string(\u003CModule\u003E.FString\u002E\u002A(ToolSetName), 0, \u003CModule\u003E.FString\u002ELen(ToolSetName));
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).NotifyCurrentToolChanged(ToolSetName1);
  }

  internal static unsafe void FLandscapeEditWindow\u002ENotifyMaskEnableChanged(
    [In] FLandscapeEditWindow* obj0,
    uint bEnabled)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr) == null)
      return;
    bool MaskEnabled = bEnabled != 0U;
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).NotifyMaskEnableChanged(MaskEnabled);
  }

  internal static unsafe void FLandscapeEditWindow\u002ENotifyBrushSizeChanged(
    [In] FLandscapeEditWindow* obj0,
    float Radius)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).NotifyBrushSizeChanged(Radius);
  }

  internal static unsafe void FLandscapeEditWindow\u002ENotifyBrushComponentSizeChanged(
    [In] FLandscapeEditWindow* obj0,
    int Size)
  {
    FLandscapeEditWindow* flandscapeEditWindowPtr = (FLandscapeEditWindow*) ((IntPtr) obj0 + 8L);
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr) == null)
      return;
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) flandscapeEditWindowPtr).NotifyBrushComponentSizeChanged(Size);
  }

  internal static unsafe uint FWelcomeScreen\u002EShouldDisplayWelcomeScreenAtStartup()
  {
    uint num1 = 0;
    int num2 = (int) \u003CModule\u003E.FConfigCacheIni\u002EGetBool(\u003CModule\u003E.GConfig, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D346, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D345, &num1, (char*) &\u003CModule\u003E.GEditorUserSettingsIni);
    return num1;
  }

  internal static unsafe void FWelcomeScreen\u002EDisplayWelcomeScreen()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FWelcomeScreen* fwelcomeScreenPtr1 = (FWelcomeScreen*) \u003CModule\u003E.@new(24UL);
      FWelcomeScreen* fwelcomeScreenPtr2;
      // ISSUE: fault handler
      try
      {
        fwelcomeScreenPtr2 = (IntPtr) fwelcomeScreenPtr1 == IntPtr.Zero ? (FWelcomeScreen*) 0L : \u003CModule\u003E.FWelcomeScreen\u002E\u007Bctor\u007D(fwelcomeScreenPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fwelcomeScreenPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA = fwelcomeScreenPtr2;
    }
    FWelcomeScreen* fwelcomeScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA;
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) fwelcomeScreen0PeaV1Ea + 8L)).SetContentAndShow((MWPFPanel) \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWelcomeScreenPanel\u0040\u0040((gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E*) ((IntPtr) fwelcomeScreen0PeaV1Ea + 16L)));
  }

  internal static unsafe void FWelcomeScreen\u002EShutdown()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
    {
      FWelcomeScreen* fwelcomeScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA)((uint) fwelcomeScreen0PeaV1Ea, new IntPtr(1));
    }
    \u003CModule\u003E.\u003FInstance\u0040FWelcomeScreen\u0040\u00400PEAV1\u0040EA = (FWelcomeScreen*) 0L;
  }

  internal static unsafe FWelcomeScreen* FWelcomeScreen\u002E\u007Bctor\u007D(
    [In] FWelcomeScreen* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FWelcomeScreen\u0040\u00406B\u0040;
      FWelcomeScreen* fwelcomeScreenPtr1 = (FWelcomeScreen*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fwelcomeScreenPtr1);
      // ISSUE: fault handler
      try
      {
        FWelcomeScreen* fwelcomeScreenPtr2 = (FWelcomeScreen*) ((IntPtr) obj0 + 16L);
        \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E*) fwelcomeScreenPtr2);
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
          FWelcomeScreen* fwelcomeScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) fwelcomeScreenPtr3);
          FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
          FWelcomeScreen* fwelcomeScreenPtr4 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) fwelcomeScreenPtr4);
          WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
          FString fstring1;
          FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D348, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D347, (char*) 0L);
          // ISSUE: fault handler
          try
          {
            FString fstring2;
            \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
            // ISSUE: fault handler
            try
            {
              string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
              InSettings.WindowTitle = str;
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
            }
            \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
          InSettings.bCenterWindow = 1U;
          InSettings.bUseSaveLayout = 0U;
          FString fstring3;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D349);
          // ISSUE: fault handler
          try
          {
            \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fwelcomeScreenPtr1, new MWPFFrame((wxWindow*) 0L, InSettings, &fstring3));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
          FString fstring4;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D350);
          // ISSUE: fault handler
          try
          {
            string InXaml = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4));
            \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E*) fwelcomeScreenPtr2, new MWelcomeScreenPanel(InXaml));
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
          if (InSettings is IDisposable disposable6)
            disposable6.Dispose();
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FWelcomeScreen\u002E__vecDelDtor([In] FWelcomeScreen* obj0, uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FWelcomeScreen* fwelcomeScreenPtr = (FWelcomeScreen*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 24UL, *(int*) fwelcomeScreenPtr, (__FnPtr<void (void*)>) __methodptr(FWelcomeScreen\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) fwelcomeScreenPtr);
      return (void*) fwelcomeScreenPtr;
    }
    \u003CModule\u003E.FWelcomeScreen\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FWelcomeScreen\u002E\u007Bdtor\u007D([In] FWelcomeScreen* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FWelcomeScreen\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FWelcomeScreen* fwelcomeScreenPtr1;
      // ISSUE: fault handler
      try
      {
        FWelcomeScreen* fwelcomeScreenPtr2;
        // ISSUE: fault handler
        try
        {
          FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
          FWelcomeScreen* fwelcomeScreenPtr3 = obj0;
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) fwelcomeScreenPtr3);
          fwelcomeScreenPtr2 = (FWelcomeScreen*) ((IntPtr) obj0 + 16L);
          if (\u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWelcomeScreenPanel\u0040\u0040((gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E*) fwelcomeScreenPtr2) is IDisposable disposable6)
            disposable6.Dispose();
          fwelcomeScreenPtr1 = (FWelcomeScreen*) ((IntPtr) obj0 + 8L);
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fwelcomeScreenPtr1)?.Dispose();
          IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E mwelcomeScreenPanel;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref mwelcomeScreenPanel = (long) num1.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) fwelcomeScreenPtr2)).Target = (object) \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWelcomeScreenPanel\u0040\u0040(&mwelcomeScreenPanel);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &mwelcomeScreenPanel);
          }
          \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&mwelcomeScreenPanel);
          IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
          gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
          // ISSUE: cast to a reference type
          // ISSUE: explicit reference operation
          ^(long&) ref gcrootMwpfFrame = (long) num2.ToPointer();
          // ISSUE: fault handler
          try
          {
            ((GCHandle) new IntPtr((void*) *(long*) fwelcomeScreenPtr1)).Target = (object) \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
          }
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 16L));
        }
        \u003CModule\u003E.gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E*) fwelcomeScreenPtr2);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) fwelcomeScreenPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FWelcomeScreen\u002ESend(
    [In] FWelcomeScreen* obj0,
    ECallbackEventType Event)
  {
    if (Event != (ECallbackEventType) 65)
    {
      if (Event != (ECallbackEventType) 66)
        return;
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 1);
    }
    else
      \u003CModule\u003E.EnableWindow(\u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).GetWindowHandle(), 0);
  }

  internal static unsafe uint ExportLocalizationWindow\u002EPromptForExportLocalizationOptions(
    FExportLocalizationOptions* OutOptions)
  {
    WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
    FString fstring1;
    FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D352, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D351, (char*) 0L);
    // ISSUE: fault handler
    try
    {
      FString fstring2;
      \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
      // ISSUE: fault handler
      try
      {
        string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
        InSettings.WindowTitle = str;
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
      }
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
    FString fstring3;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D353);
    MWPFFrame mwpfFrame;
    // ISSUE: fault handler
    try
    {
      mwpfFrame = new MWPFFrame((wxWindow*) *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L), InSettings, &fstring3);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
    FString fstring4;
    \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D354);
    MExportLocalizationPanel localizationPanel;
    // ISSUE: fault handler
    try
    {
      localizationPanel = new MExportLocalizationPanel(new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4)), OutOptions);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
    }
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
    return mwpfFrame.SetContentAndShowModal((MWPFPanel) localizationPanel, 1) == 1 ? 0U : 1U;
  }

  internal static unsafe FFoliageEditWindow* FFoliageEditWindow\u002ECreateFoliageEditWindow(
    FEdModeFoliage* InFoliageEditSystem,
    HWND__* InParentWindowHandle)
  {
    FFoliageEditWindow* ffoliageEditWindowPtr1 = (FFoliageEditWindow*) \u003CModule\u003E.@new(16UL);
    FFoliageEditWindow* ffoliageEditWindowPtr2;
    // ISSUE: fault handler
    try
    {
      ffoliageEditWindowPtr2 = (IntPtr) ffoliageEditWindowPtr1 == IntPtr.Zero ? (FFoliageEditWindow*) 0L : \u003CModule\u003E.FFoliageEditWindow\u002E\u007Bctor\u007D(ffoliageEditWindowPtr1);
    }
    __fault
    {
      \u003CModule\u003E.delete((void*) ffoliageEditWindowPtr1);
    }
    MFoliageEditWindow _new_ptr = new MFoliageEditWindow(InFoliageEditSystem);
    FFoliageEditWindow* ffoliageEditWindowPtr3 = (FFoliageEditWindow*) ((IntPtr) ffoliageEditWindowPtr2 + 8L);
    \u003CModule\u003E.msclr\u002Eauto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002Ereset((auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr3, _new_ptr);
    if (\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr3).InitFoliageEditWindow(InParentWindowHandle) != 0U)
      return ffoliageEditWindowPtr2;
    if ((IntPtr) ffoliageEditWindowPtr2 != IntPtr.Zero)
    {
      FFoliageEditWindow* ffoliageEditWindowPtr4 = ffoliageEditWindowPtr2;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) ffoliageEditWindowPtr2)((uint) ffoliageEditWindowPtr4, new IntPtr(1));
    }
    return (FFoliageEditWindow*) 0L;
  }

  internal static unsafe FFoliageEditWindow* FFoliageEditWindow\u002E\u007Bctor\u007D(
    [In] FFoliageEditWindow* obj0)
  {
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bctor\u007D((FCallbackEventDevice*) obj0);
    // ISSUE: fault handler
    try
    {
      *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FFoliageEditWindow\u0040\u00406B\u0040;
      *(long*) ((IntPtr) obj0 + 8L) = (long) ((IntPtr) GCHandle.Alloc((object) null)).ToPointer();
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent1 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr1 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent1, (ECallbackEventType) 65, (IntPtr) ffoliageEditWindowPtr1);
        FCallbackEventObserver* gcallbackEvent2 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent2, (ECallbackEventType) 66, (IntPtr) ffoliageEditWindowPtr2);
        FCallbackEventObserver* gcallbackEvent3 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr3 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent3, (ECallbackEventType) 2, (IntPtr) ffoliageEditWindowPtr3);
        FCallbackEventObserver* gcallbackEvent4 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr4 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent4, (ECallbackEventType) 4, (IntPtr) ffoliageEditWindowPtr4);
        FCallbackEventObserver* gcallbackEvent5 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr5 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent5, (ECallbackEventType) 36, (IntPtr) ffoliageEditWindowPtr5);
        FCallbackEventObserver* gcallbackEvent6 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr6 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent6, (ECallbackEventType) 6, (IntPtr) ffoliageEditWindowPtr6);
        FCallbackEventObserver* gcallbackEvent7 = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr7 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, ECallbackEventType, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 80L))((FCallbackEventDevice*) gcallbackEvent7, (ECallbackEventType) 32, (IntPtr) ffoliageEditWindowPtr7);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void* FFoliageEditWindow\u002E__vecDelDtor(
    [In] FFoliageEditWindow* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FFoliageEditWindow* ffoliageEditWindowPtr = (FFoliageEditWindow*) ((IntPtr) obj0 - 4L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) ffoliageEditWindowPtr, (__FnPtr<void (void*)>) __methodptr(FFoliageEditWindow\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete\u005B\u005D((void*) ffoliageEditWindowPtr);
      return (void*) ffoliageEditWindowPtr;
    }
    \u003CModule\u003E.FFoliageEditWindow\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void FFoliageEditWindow\u002E\u007Bdtor\u007D([In] FFoliageEditWindow* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FFoliageEditWindow\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      FFoliageEditWindow* ffoliageEditWindowPtr1;
      // ISSUE: fault handler
      try
      {
        FCallbackEventObserver* gcallbackEvent = \u003CModule\u003E.GCallbackEvent;
        FFoliageEditWindow* ffoliageEditWindowPtr2 = obj0;
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void (IntPtr, FCallbackEventDevice*)>) *(long*) (*(long*) \u003CModule\u003E.GCallbackEvent + 96L))((FCallbackEventDevice*) gcallbackEvent, (IntPtr) ffoliageEditWindowPtr2);
        ffoliageEditWindowPtr1 = (FFoliageEditWindow*) ((IntPtr) obj0 + 8L);
        auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* mfoliageEditWindowPtr = (auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr1;
        if (\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr) != null)
        {
          if ((\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr) != null ? 1 : 0) != 0)
            \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr)?.Dispose();
          \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr, (MFoliageEditWindow) null);
        }
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(msclr\u002Eauto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* mfoliageEditWindowPtr1 = (auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr1;
      // ISSUE: fault handler
      try
      {
        if ((\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr1) != null ? 1 : 0) != 0)
          \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr1)?.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) mfoliageEditWindowPtr1);
      }
      \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) mfoliageEditWindowPtr1);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FCallbackEventDevice\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.FCallbackEventDevice\u002E\u007Bdtor\u007D((FCallbackEventDevice*) obj0);
  }

  internal static unsafe void FFoliageEditWindow\u002ESaveWindowSettings([In] FFoliageEditWindow* obj0) => \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).SaveWindowSettings();

  internal static unsafe void FFoliageEditWindow\u002ESend(
    [In] FFoliageEditWindow* obj0,
    ECallbackEventType Event)
  {
    if (Event != (ECallbackEventType) 6)
    {
      if (Event != (ECallbackEventType) 32)
        return;
      \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).RefreshMeshList();
    }
    else
    {
      FFoliageEditWindow* ffoliageEditWindowPtr = (FFoliageEditWindow*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr).NotifyNewCurrentLevel();
      \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ffoliageEditWindowPtr).RefreshMeshList();
    }
  }

  internal static unsafe void FFoliageEditWindow\u002ERefreshMeshListProperties(
    [In] FFoliageEditWindow* obj0)
  {
    \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).FoliageMeshesValue.NotifyChanged();
  }

  internal static unsafe int FNewMapScreen\u002EDisplayNewMapScreen(
    TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E* Templates,
    FString* OutTemplateName)
  {
    \u003CModule\u003E.FString\u002EEmpty(OutTemplateName, 0);
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA == IntPtr.Zero)
    {
      FNewMapScreen* fnewMapScreenPtr1 = (FNewMapScreen*) \u003CModule\u003E.@new(16UL);
      FNewMapScreen* fnewMapScreenPtr2;
      // ISSUE: fault handler
      try
      {
        fnewMapScreenPtr2 = (IntPtr) fnewMapScreenPtr1 == IntPtr.Zero ? (FNewMapScreen*) 0L : \u003CModule\u003E.FNewMapScreen\u002E\u007Bctor\u007D(fnewMapScreenPtr1);
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fnewMapScreenPtr1);
      }
      \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA = fnewMapScreenPtr2;
    }
    FNewMapScreen* mapScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA;
    FNewMapScreen* fnewMapScreenPtr = (FNewMapScreen*) ((IntPtr) mapScreen0PeaV1Ea + 8L);
    \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr).Templates = Templates;
    int num1;
    if (0 != \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) mapScreen0PeaV1Ea).SetContentAndShowModal((MWPFPanel) \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMNewMapPanel\u0040\u0040((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr), 0))
    {
      num1 = 1;
      if (!string.IsNullOrEmpty(\u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr).SelectedTemplate))
      {
        FString fstring1;
        FString* fstring2 = \u003CModule\u003E.CLRTools\u002EToFString(&fstring1, \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr).SelectedTemplate);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.FString\u002E\u003D(OutTemplateName, fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
      }
    }
    else
      num1 = 0;
    \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr).Templates = (TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E*) 0L;
    long num2 = *(long*) ((IntPtr) \u003CModule\u003E.GApp + 172L);
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    __calli((__FnPtr<void (IntPtr)>) *(long*) (*(long*) num2 + 176L))((IntPtr) num2);
    return num1;
  }

  internal static unsafe void FNewMapScreen\u002EShutdown()
  {
    FNewMapScreen* mapScreen0PeaV1Ea = \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA;
    if ((IntPtr) \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA != IntPtr.Zero)
    {
      \u003CModule\u003E.FNewMapScreen\u002E\u007Bdtor\u007D(\u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA);
      \u003CModule\u003E.delete((void*) mapScreen0PeaV1Ea);
    }
    \u003CModule\u003E.\u003FInstance\u0040FNewMapScreen\u0040\u00400PEAV1\u0040EA = (FNewMapScreen*) 0L;
  }

  internal static unsafe FNewMapScreen* FNewMapScreen\u002E\u007Bctor\u007D(
    [In] FNewMapScreen* obj0)
  {
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0);
    // ISSUE: fault handler
    try
    {
      FNewMapScreen* fnewMapScreenPtr = (FNewMapScreen*) ((IntPtr) obj0 + 8L);
      \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr);
      // ISSUE: fault handler
      try
      {
        WPFFrameInitStruct InSettings = new WPFFrameInitStruct();
        FString fstring1;
        FString* fstringPtr = \u003CModule\u003E.LocalizeUnrealEd(&fstring1, (sbyte*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D356, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D355, (char*) 0L);
        // ISSUE: fault handler
        try
        {
          FString fstring2;
          \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring2, \u003CModule\u003E.FString\u002E\u002A(fstringPtr));
          // ISSUE: fault handler
          try
          {
            string str = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring2), 0, \u003CModule\u003E.FString\u002ELen(&fstring2));
            InSettings.WindowTitle = str;
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring2);
          }
          \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring2);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring1);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring1);
        InSettings.bCenterWindow = 1U;
        InSettings.bUseSaveLayout = 0U;
        FString fstring3;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring3, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D357);
        // ISSUE: fault handler
        try
        {
          \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0, new MWPFFrame((wxWindow*) 0L, InSettings, &fstring3));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring3);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring3);
        FString fstring4;
        \u003CModule\u003E.FString\u002E\u007Bctor\u007D(&fstring4, (char*) &\u003CModule\u003E.\u003FA0x3a4a4fc4\u002Eunnamed\u002Dglobal\u002D358);
        // ISSUE: fault handler
        try
        {
          string InXaml = new string(\u003CModule\u003E.FString\u002E\u002A(&fstring4), 0, \u003CModule\u003E.FString\u002ELen(&fstring4));
          \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr, new MNewMapPanel(InXaml));
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(FString\u002E\u007Bdtor\u007D), (void*) &fstring4);
        }
        \u003CModule\u003E.FString\u002E\u007Bdtor\u007D(&fstring4);
        if (InSettings is IDisposable disposable4)
          disposable4.Dispose();
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    return obj0;
  }

  internal static unsafe void FNewMapScreen\u002E\u007Bdtor\u007D([In] FNewMapScreen* obj0)
  {
    // ISSUE: fault handler
    try
    {
      FNewMapScreen* fnewMapScreenPtr;
      // ISSUE: fault handler
      try
      {
        fnewMapScreenPtr = (FNewMapScreen*) ((IntPtr) obj0 + 8L);
        if (\u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMNewMapPanel\u0040\u0040((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr) is IDisposable disposable4)
          disposable4.Dispose();
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0)?.Dispose();
        IntPtr num1 = (IntPtr) GCHandle.Alloc((object) null);
        gcroot\u003CMNewMapPanel\u0020\u005E\u003E gcrootMnewMapPanel;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(long&) ref gcrootMnewMapPanel = (long) num1.ToPointer();
        // ISSUE: fault handler
        try
        {
          ((GCHandle) new IntPtr((void*) *(long*) fnewMapScreenPtr)).Target = (object) \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMNewMapPanel\u0040\u0040(&gcrootMnewMapPanel);
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMnewMapPanel);
        }
        \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMnewMapPanel);
        IntPtr num2 = (IntPtr) GCHandle.Alloc((object) null);
        gcroot\u003CMWPFFrame\u0020\u005E\u003E gcrootMwpfFrame;
        // ISSUE: cast to a reference type
        // ISSUE: explicit reference operation
        ^(long&) ref gcrootMwpfFrame = (long) num2.ToPointer();
        // ISSUE: fault handler
        try
        {
          MWPFFrame mwpfFrame = \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWPFFrame\u0040\u0040(&gcrootMwpfFrame);
          ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) mwpfFrame;
        }
        __fault
        {
          // ISSUE: method pointer
          // ISSUE: cast to a function pointer type
          \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) &gcrootMwpfFrame);
        }
        \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(&gcrootMwpfFrame);
      }
      __fault
      {
        // ISSUE: method pointer
        // ISSUE: cast to a function pointer type
        \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) obj0 + 8L));
      }
      \u003CModule\u003E.gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMNewMapPanel\u0020\u005E\u003E*) fnewMapScreenPtr);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMWPFFrame\u0020\u005E\u003E*) obj0);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMWPFFrame\u0020\u005E\u003E* gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MWPFFrame gcroot\u003CMWPFFrame\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMWPFFrame\u0020\u005E\u003E* obj0)
  {
    return (MWPFFrame) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* obj0,
    MAboutScreenPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MAboutScreenPanel gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMAboutScreenPanel\u0040\u0040(
    [In] gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* obj0)
  {
    return (MAboutScreenPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MAboutScreenPanel gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMAboutScreenPanel\u0020\u005E\u003E* obj0)
  {
    return (MAboutScreenPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* obj0,
    MContentBrowserControl t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MContentBrowserControl gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMContentBrowserControl\u0040\u0040(
    [In] gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* obj0)
  {
    return (MContentBrowserControl) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MContentBrowserControl gcroot\u003CMContentBrowserControl\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMContentBrowserControl\u0020\u005E\u003E* obj0)
  {
    return (MContentBrowserControl) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      {
        if (\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0) is IDisposable disposable4)
          disposable4.Dispose();
      }
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe MGameAssetJournalClient msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0)
  {
    return \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe MGameAssetJournalFile msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0)
  {
    return \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* obj0,
    MConsolidateObjectsPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MConsolidateObjectsPanel gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMConsolidateObjectsPanel\u0040\u0040(
    [In] gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* obj0)
  {
    return (MConsolidateObjectsPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MConsolidateObjectsPanel gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMConsolidateObjectsPanel\u0020\u005E\u003E* obj0)
  {
    return (MConsolidateObjectsPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* obj0,
    MColorPickerPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MColorPickerPanel gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMColorPickerPanel\u0040\u0040(
    [In] gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* obj0)
  {
    return (MColorPickerPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MColorPickerPanel gcroot\u003CMColorPickerPanel\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMColorPickerPanel\u0020\u005E\u003E* obj0)
  {
    return (MColorPickerPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* obj0,
    MImportColorsScreenPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MImportColorsScreenPanel gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMImportColorsScreenPanel\u0040\u0040(
    [In] gcroot\u003CMImportColorsScreenPanel\u0020\u005E\u003E* obj0)
  {
    return (MImportColorsScreenPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* obj0,
    MMeshPaintFrame _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* obj0,
    MMeshPaintWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E*) obj0);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMStartPageControl\u0020\u005E\u003E* gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMStartPageControl\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMStartPageControl\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMStartPageControl\u0020\u005E\u003E* gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMStartPageControl\u0020\u005E\u003E* obj0,
    MStartPageControl t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MStartPageControl gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMStartPageControl\u0040\u0040(
    [In] gcroot\u003CMStartPageControl\u0020\u005E\u003E* obj0)
  {
    return (MStartPageControl) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MStartPageControl gcroot\u003CMStartPageControl\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMStartPageControl\u0020\u005E\u003E* obj0)
  {
    return (MStartPageControl) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* obj0,
    MLightmapResRatioWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* obj0,
    MDirectorPanelHelper t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MDirectorPanelHelper gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMDirectorPanelHelper\u0040MatineeWindows\u0040\u0040(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* obj0)
  {
    return (MDirectorPanelHelper) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MDirectorPanelHelper gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMDirectorPanelHelper\u0020\u005E\u003E* obj0)
  {
    return (MDirectorPanelHelper) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* obj0,
    MRecordPanelHelper t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MRecordPanelHelper gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMRecordPanelHelper\u0040MatineeWindows\u0040\u0040(
    [In] gcroot\u003CMatineeWindows\u003A\u003AMRecordPanelHelper\u0020\u005E\u003E* obj0)
  {
    return (MRecordPanelHelper) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  internal static unsafe gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* obj0,
    MFileSystemNotificationWrapper t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MFileSystemNotificationWrapper gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFileSystemNotificationWrapper\u0040\u0040(
    [In] gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* obj0)
  {
    return (MFileSystemNotificationWrapper) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MFileSystemNotificationWrapper gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMFileSystemNotificationWrapper\u0020\u005E\u003E* obj0)
  {
    return (MFileSystemNotificationWrapper) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* obj0,
    MLightingToolsWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E*) obj0);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* obj0,
    MLandscapeEditWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E*) obj0);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* obj0,
    MWelcomeScreenPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MWelcomeScreenPanel gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMWelcomeScreenPanel\u0040\u0040(
    [In] gcroot\u003CMWelcomeScreenPanel\u0020\u005E\u003E* obj0)
  {
    return (MWelcomeScreenPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* obj0,
    MFoliageEditWindow _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] auto_gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* obj0)
  {
    // ISSUE: fault handler
    try
    {
      if ((\u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
        \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0)?.Dispose();
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E*) obj0);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMNewMapPanel\u0020\u005E\u003E* gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CMNewMapPanel\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMNewMapPanel\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMNewMapPanel\u0020\u005E\u003E* gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMNewMapPanel\u0020\u005E\u003E* obj0,
    MNewMapPanel t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MNewMapPanel gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMNewMapPanel\u0040\u0040(
    [In] gcroot\u003CMNewMapPanel\u0020\u005E\u003E* obj0)
  {
    return (MNewMapPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecuritySafeCritical]
  internal static unsafe MNewMapPanel gcroot\u003CMNewMapPanel\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CMNewMapPanel\u0020\u005E\u003E* obj0)
  {
    return (MNewMapPanel) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void TSortableMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSortableMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TSortableMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSortableMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  internal static unsafe void TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0)
  {
    \u003CModule\u003E.TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E*) obj0);
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecuritySafeCritical]
  internal static unsafe Dictionary<string, int> gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* obj0)
  {
    return (Dictionary<string, int>) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecuritySafeCritical]
  internal static unsafe MGameAssetJournalClient gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040(
    [In] gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0)
  {
    return (MGameAssetJournalClient) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecuritySafeCritical]
  internal static unsafe MGameAssetJournalFile gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040(
    [In] gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0)
  {
    return (MGameAssetJournalFile) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* obj0,
    MMeshPaintFrame t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MMeshPaintFrame gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintFrame\u0040\u0040(
    [In] gcroot\u003CMMeshPaintFrame\u0020\u005E\u003E* obj0)
  {
    return (MMeshPaintFrame) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* obj0,
    MMeshPaintWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MMeshPaintWindow gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMMeshPaintWindow\u0040\u0040(
    [In] gcroot\u003CMMeshPaintWindow\u0020\u005E\u003E* obj0)
  {
    return (MMeshPaintWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* obj0,
    MLightmapResRatioWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MLightmapResRatioWindow gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightmapResRatioWindow\u0040\u0040(
    [In] gcroot\u003CMLightmapResRatioWindow\u0020\u005E\u003E* obj0)
  {
    return (MLightmapResRatioWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* obj0,
    MLightingToolsWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MLightingToolsWindow gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLightingToolsWindow\u0040\u0040(
    [In] gcroot\u003CMLightingToolsWindow\u0020\u005E\u003E* obj0)
  {
    return (MLightingToolsWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* obj0,
    MLandscapeEditWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MLandscapeEditWindow gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMLandscapeEditWindow\u0040\u0040(
    [In] gcroot\u003CMLandscapeEditWindow\u0020\u005E\u003E* obj0)
  {
    return (MLandscapeEditWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* obj0,
    MFoliageEditWindow t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe MFoliageEditWindow gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMFoliageEditWindow\u0040\u0040(
    [In] gcroot\u003CMFoliageEditWindow\u0020\u005E\u003E* obj0)
  {
    return (MFoliageEditWindow) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void* FObjectSupportedCommandType\u002E__delDtor(
    [In] FObjectSupportedCommandType* obj0,
    uint _param1)
  {
    \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 8L));
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* FSourceControl\u002EFSourceControlFileHistoryInfo\u002E__delDtor(
    [In] FSourceControl.FSourceControlFileHistoryInfo* obj0,
    uint _param1)
  {
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.FString\u002E\u007Bdtor\u007D((FString*) ((IntPtr) obj0 + 16L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    \u003CModule\u003E.TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D((TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E*) obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* obj0,
    Dictionary<string, int> _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0 && \u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u002EPE\u0024AAV\u003F\u0024Dictionary\u0040PE\u0024AAVString\u0040System\u0040\u0040H\u0040Generic\u0040Collections\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0) is IDisposable disposable)
      disposable.Dispose();
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0,
    MGameAssetJournalClient _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalClient\u0040\u0040((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void msclr\u002Eauto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002Ereset(
    [In] auto_gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0,
    MGameAssetJournalFile _new_ptr)
  {
    if (\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0) == _new_ptr)
      return;
    if ((\u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0) != null ? 1 : 0) != 0)
      \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u002EPE\u0024AAVMGameAssetJournalFile\u0040\u0040((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0)?.Dispose();
    \u003CModule\u003E.gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u003D((gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E*) obj0, _new_ptr);
  }

  internal static unsafe void TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002EFPair\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.FPair* obj0)
  {
    \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 8L));
  }

  internal static unsafe void* TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002EFElement\u002E__delDtor(
    [In] TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E.FElement* obj0,
    uint _param1)
  {
    \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 8L));
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003ACollections\u003A\u003AGeneric\u003A\u003ADictionary\u003CSystem\u003A\u003AString\u0020\u005E\u002Cint\u003E\u0020\u005E\u003E* obj0,
    Dictionary<string, int> t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMGameAssetJournalClient\u0020\u005E\u003E* obj0,
    MGameAssetJournalClient t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CMGameAssetJournalFile\u0020\u005E\u003E* obj0,
    MGameAssetJournalFile t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  internal static string \u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cclass\u0020System\u003A\u003AString\u0020\u005E\u003E(
    ManagementObject Obj,
    string Property,
    ref string ErrStr)
  {
    try
    {
      object propertyValue = Obj.GetPropertyValue(Property);
      if (propertyValue != null)
        return (string) propertyValue;
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' not found. " + "\n\n";
    }
    catch (Exception ex)
    {
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' threw exception. " + ex.ToString() + "\n\n";
    }
    return (string) null;
  }

  internal static ulong \u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020__int64\u003E(
    ManagementObject Obj,
    string Property,
    ref string ErrStr)
  {
    try
    {
      object propertyValue = Obj.GetPropertyValue(Property);
      if (propertyValue != null)
        return (ulong) propertyValue;
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' not found. " + "\n\n";
    }
    catch (Exception ex)
    {
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' threw exception. " + ex.ToString() + "\n\n";
    }
    return 0;
  }

  internal static ushort \u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020short\u003E(
    ManagementObject Obj,
    string Property,
    ref string ErrStr)
  {
    try
    {
      object propertyValue = Obj.GetPropertyValue(Property);
      if (propertyValue != null)
        return (ushort) propertyValue;
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' not found. " + "\n\n";
    }
    catch (Exception ex)
    {
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' threw exception. " + ex.ToString() + "\n\n";
    }
    return 0;
  }

  internal static uint \u003FA0x3a4a4fc4\u002EGetWMIProperty\u003Cunsigned\u0020int\u003E(
    ManagementObject Obj,
    string Property,
    ref string ErrStr)
  {
    try
    {
      object propertyValue = Obj.GetPropertyValue(Property);
      if (propertyValue != null)
        return (uint) propertyValue;
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' not found. " + "\n\n";
    }
    catch (Exception ex)
    {
      if (ErrStr != null)
        ErrStr += "WMI property '" + Property + "' threw exception. " + ex.ToString() + "\n\n";
    }
    return 0;
  }

  internal static unsafe void* TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002EFPair\u002E__delDtor(
    [In] TMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.FPair* obj0,
    uint _param1)
  {
    \u003CModule\u003E.TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D((TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E*) ((IntPtr) obj0 + 8L));
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* \u003F\u003F_EFContentBrowser\u0040\u0040\u0024\u0024FW7EAAPEAXI\u0040Z(
    [In] FContentBrowser* obj0,
    uint _param1)
  {
    obj0 -= 8L;
    // ISSUE: jmp instruction
    __jump \u003CModule\u003E.FContentBrowser\u002E__vecDelDtor;
  }

  internal static unsafe void* \u003F\u003F_EFContentBrowser\u0040\u0040\u0024\u0024FWBA\u0040EAAPEAXI\u0040Z(
    [In] FContentBrowser* obj0,
    uint _param1)
  {
    obj0 -= 16L;
    // ISSUE: jmp instruction
    __jump \u003CModule\u003E.FContentBrowser\u002E__vecDelDtor;
  }

  internal static unsafe void* \u003F\u003F_EFConsolidateWindow\u0040\u0040\u0024\u0024FG7EAAPEAXI\u0040Z(
    [In] FConsolidateWindow* obj0,
    uint _param1)
  {
    obj0 -= 8L;
    // ISSUE: jmp instruction
    __jump \u003CModule\u003E.FConsolidateWindow\u002E__vecDelDtor;
  }

  internal static unsafe NSwarm.FGuid* NSwarm\u002EFGuid\u002E\u007Bctor\u007D(
    [In] NSwarm.FGuid* obj0,
    uint InA,
    uint InB,
    uint InC,
    uint InD)
  {
    *(int*) obj0 = (int) InA;
    *(int*) ((IntPtr) obj0 + 4L) = (int) InB;
    *(int*) ((IntPtr) obj0 + 8L) = (int) InC;
    *(int*) ((IntPtr) obj0 + 12L) = (int) InD;
    return obj0;
  }

  internal static unsafe FMessage* NSwarm\u002EFMessage\u002E\u007Bctor\u007D(
    [In] FMessage* obj0,
    TSwarmVersionValue NewVersion,
    TMessageType NewType)
  {
    *(int*) obj0 = (int) NewVersion;
    *(int*) ((IntPtr) obj0 + 4L) = (int) NewType;
    return obj0;
  }

  internal static unsafe FInfoMessage* NSwarm\u002EFInfoMessage\u002E\u007Bctor\u007D(
    [In] FInfoMessage* obj0,
    char* InTextMessage)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 1;
    *(long*) ((IntPtr) obj0 + 8L) = (long) InTextMessage;
    return obj0;
  }

  internal static unsafe FAlertMessage* NSwarm\u002EFAlertMessage\u002E\u007Bctor\u007D(
    [In] FAlertMessage* obj0,
    NSwarm.FGuid* InJobGuid,
    TAlertLevel InAlertLevel,
    NSwarm.FGuid* InObjectGuid,
    int InTypeId)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 2;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8L, (IntPtr) InJobGuid, 16);
    *(int*) ((IntPtr) obj0 + 24L) = (int) InAlertLevel;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 28L, (IntPtr) InObjectGuid, 16);
    *(int*) ((IntPtr) obj0 + 44L) = InTypeId;
    *(long*) ((IntPtr) obj0 + 48L) = 0L;
    return obj0;
  }

  internal static unsafe FTaskRequestResponse* NSwarm\u002EFTaskRequestResponse\u002E\u007Bctor\u007D(
    [In] FTaskRequestResponse* obj0,
    TTaskRequestResponseType NewResponseType)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 512;
    *(int*) ((IntPtr) obj0 + 8L) = (int) NewResponseType;
    return obj0;
  }

  internal static unsafe FTaskSpecification* NSwarm\u002EFTaskSpecification\u002E\u007Bctor\u007D(
    [In] FTaskSpecification* obj0,
    NSwarm.FGuid TaskTaskGuid,
    char* TaskParameters,
    TJobTaskFlags TaskFlags)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 512;
    *(int*) ((IntPtr) obj0 + 8L) = 3;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 12L, ref TaskTaskGuid, 16);
    *(long*) ((IntPtr) obj0 + 32L) = (long) TaskParameters;
    *(int*) ((IntPtr) obj0 + 40L) = (int) TaskFlags;
    *(long*) ((IntPtr) obj0 + 48L) = 0L;
    *(int*) ((IntPtr) obj0 + 56L) = 0;
    return obj0;
  }

  internal static unsafe FJobState* NSwarm\u002EFJobState\u002E\u007Bctor\u007D(
    [In] FJobState* obj0,
    NSwarm.FGuid NewJobGuid,
    TJobTaskState NewJobState)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 32;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8L, ref NewJobGuid, 16);
    *(int*) ((IntPtr) obj0 + 24L) = (int) NewJobState;
    *(long*) ((IntPtr) obj0 + 32L) = 0L;
    *(int*) ((IntPtr) obj0 + 40L) = 0;
    *(double*) ((IntPtr) obj0 + 48L) = 0.0;
    return obj0;
  }

  internal static unsafe FTaskState* NSwarm\u002EFTaskState\u002E\u007Bctor\u007D(
    [In] FTaskState* obj0,
    NSwarm.FGuid NewTaskGuid,
    TJobTaskState NewTaskState)
  {
    *(int*) obj0 = 16;
    *(int*) ((IntPtr) obj0 + 4L) = 768;
    // ISSUE: cpblk instruction
    __memcpy((IntPtr) obj0 + 8L, ref NewTaskGuid, 16);
    *(int*) ((IntPtr) obj0 + 24L) = (int) NewTaskState;
    *(long*) ((IntPtr) obj0 + 32L) = 0L;
    *(int*) ((IntPtr) obj0 + 40L) = 0;
    *(double*) ((IntPtr) obj0 + 48L) = 0.0;
    return obj0;
  }

  internal static unsafe void NSwarm\u002EFSwarmInterface\u002E\u007Bdtor\u007D(
    [In] FSwarmInterface* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
  }

  internal static unsafe void* NSwarm\u002EFSwarmInterface\u002E__vecDelDtor(
    [In] FSwarmInterface* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FSwarmInterface* fswarmInterfacePtr = (FSwarmInterface*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 8UL, *(int*) fswarmInterfacePtr, (__FnPtr<void (void*)>) __methodptr(NSwarm\u002EFSwarmInterface\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) fswarmInterfacePtr);
      return (void*) fswarmInterfacePtr;
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void* NSwarm\u002EFSwarmInterfaceImpl\u002E__vecDelDtor(
    [In] FSwarmInterfaceImpl* obj0,
    uint _param1)
  {
    if (((int) _param1 & 2) != 0)
    {
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = (FSwarmInterfaceImpl*) ((IntPtr) obj0 - 8L);
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.__ehvec_dtor((void*) obj0, 16UL, *(int*) fswarmInterfaceImplPtr, (__FnPtr<void (void*)>) __methodptr(NSwarm\u002EFSwarmInterfaceImpl\u002E\u007Bdtor\u007D));
      if (((int) _param1 & 1) != 0)
        \u003CModule\u003E.delete((void*) fswarmInterfaceImplPtr);
      return (void*) fswarmInterfaceImplPtr;
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterfaceImpl\u0040NSwarm\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(NSwarm\u002EFSwarmInterface\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static unsafe void NSwarm\u002EFSwarmInterfaceImpl\u002E\u007Bdtor\u007D(
    [In] FSwarmInterfaceImpl* obj0)
  {
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterfaceImpl\u0040NSwarm\u0040\u00406B\u0040;
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L));
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(NSwarm\u002EFSwarmInterface\u002E\u007Bdtor\u007D), (void*) obj0);
    }
    *(long*) obj0 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
  }

  internal static unsafe FSwarmInterface* NSwarm\u002EFSwarmInterface\u002EGet()
  {
    if ((IntPtr) \u003CModule\u003E.\u003FGInstance\u0040FSwarmInterface\u0040NSwarm\u0040\u00400PEAV12\u0040EA == IntPtr.Zero)
    {
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr1 = (FSwarmInterfaceImpl*) \u003CModule\u003E.@new(16UL);
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr2;
      // ISSUE: fault handler
      try
      {
        if ((IntPtr) fswarmInterfaceImplPtr1 != IntPtr.Zero)
        {
          *(long*) fswarmInterfaceImplPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterface\u0040NSwarm\u0040\u00406B\u0040;
          // ISSUE: fault handler
          try
          {
            *(long*) fswarmInterfaceImplPtr1 = (long) &\u003CModule\u003E.\u003F\u003F_7FSwarmInterfaceImpl\u0040NSwarm\u0040\u00406B\u0040;
            FSwarmInterfaceImpl* fswarmInterfaceImplPtr3 = (FSwarmInterfaceImpl*) ((IntPtr) fswarmInterfaceImplPtr1 + 8L);
            \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) fswarmInterfaceImplPtr3);
            // ISSUE: fault handler
            try
            {
              \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u003D((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) fswarmInterfaceImplPtr3, new FSwarmInterfaceManagedImpl());
            }
            __fault
            {
              // ISSUE: method pointer
              // ISSUE: cast to a function pointer type
              \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bdtor\u007D), (void*) ((IntPtr) fswarmInterfaceImplPtr1 + 8L));
            }
          }
          __fault
          {
            // ISSUE: method pointer
            // ISSUE: cast to a function pointer type
            \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(NSwarm\u002EFSwarmInterface\u002E\u007Bdtor\u007D), (void*) fswarmInterfaceImplPtr1);
          }
          fswarmInterfaceImplPtr2 = fswarmInterfaceImplPtr1;
        }
        else
          fswarmInterfaceImplPtr2 = (FSwarmInterfaceImpl*) 0L;
      }
      __fault
      {
        \u003CModule\u003E.delete((void*) fswarmInterfaceImplPtr1);
      }
      \u003CModule\u003E.\u003FGInstance\u0040FSwarmInterface\u0040NSwarm\u0040\u00400PEAV12\u0040EA = (FSwarmInterface*) fswarmInterfaceImplPtr2;
    }
    return \u003CModule\u003E.\u003FGInstance\u0040FSwarmInterface\u0040NSwarm\u0040\u00400PEAV12\u0040EA;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EOpenConnection(
    [In] FSwarmInterfaceImpl* obj0,
    __FnPtr<void (FMessage*, void*)> CallbackFunc,
    void* CallbackData,
    TLogFlags LoggingFlags)
  {
    return \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).OpenConnection(CallbackFunc, CallbackData, (ELogFlags) LoggingFlags);
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ECloseConnection(
    [In] FSwarmInterfaceImpl* obj0)
  {
    return \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).CloseConnection();
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ESendMessage(
    [In] FSwarmInterfaceImpl* obj0,
    FMessage* Message)
  {
    return \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).SendMessage(Message);
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EAddChannel(
    [In] FSwarmInterfaceImpl* obj0,
    char* FullPath,
    char* ChannelName)
  {
    if ((IntPtr) FullPath == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG1;
    if ((IntPtr) ChannelName == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG2;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).AddChannel(FullPath, ChannelName);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D1;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ETestChannel(
    [In] FSwarmInterfaceImpl* obj0,
    char* ChannelName)
  {
    if ((IntPtr) ChannelName == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG1;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).TestChannel(ChannelName);
    if (num1 < 0 && num1 != Constants.ERROR_FILE_FOUND_NOT)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D2;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EOpenChannel(
    [In] FSwarmInterfaceImpl* obj0,
    char* ChannelName,
    TChannelFlags ChannelFlags)
  {
    if ((IntPtr) ChannelName == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG1;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).OpenChannel(ChannelName, ChannelFlags);
    if (num1 < 0 && (ChannelFlags & (TChannelFlags) 32) != (TChannelFlags) 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D3;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ECloseChannel(
    [In] FSwarmInterfaceImpl* obj0,
    int Channel)
  {
    if (Channel < 0)
      return Constants.ERROR_INVALID_ARG1;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).CloseChannel(Channel);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D4;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EWriteChannel(
    [In] FSwarmInterfaceImpl* obj0,
    int Channel,
    void* Data,
    int DataSize)
  {
    if (Channel < 0)
      return Constants.ERROR_INVALID_ARG1;
    if ((IntPtr) Data == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG2;
    if (DataSize < 0)
      return Constants.ERROR_INVALID_ARG3;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).WriteChannel(Channel, Data, DataSize);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D5;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EReadChannel(
    [In] FSwarmInterfaceImpl* obj0,
    int Channel,
    void* Data,
    int DataSize)
  {
    if (Channel < 0)
      return Constants.ERROR_INVALID_ARG1;
    if ((IntPtr) Data == IntPtr.Zero)
      return Constants.ERROR_INVALID_ARG2;
    if (DataSize < 0)
      return Constants.ERROR_INVALID_ARG3;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).ReadChannel(Channel, Data, DataSize);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D6;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EOpenJob(
    [In] FSwarmInterfaceImpl* obj0,
    NSwarm.FGuid* JobGuid)
  {
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).OpenJob(JobGuid);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D7;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EBeginJobSpecification(
    [In] FSwarmInterfaceImpl* obj0,
    FJobSpecification* Specification32,
    FJobSpecification* Specification64)
  {
    if (*(long*) Specification32 == 0L && *(long*) Specification64 == 0L || *(long*) ((IntPtr) Specification32 + 8L) == 0L && *(long*) ((IntPtr) Specification64 + 8L) == 0L || ((uint) *(int*) ((IntPtr) Specification32 + 32L) > 0U && *(long*) ((IntPtr) Specification32 + 24L) == 0L || (uint) *(int*) ((IntPtr) Specification32 + 48L) > 0U && *(long*) ((IntPtr) Specification32 + 40L) == 0L) || ((uint) *(int*) ((IntPtr) Specification64 + 32L) > 0U && *(long*) ((IntPtr) Specification64 + 24L) == 0L || (uint) *(int*) ((IntPtr) Specification64 + 48L) > 0U && *(long*) ((IntPtr) Specification64 + 40L) == 0L))
      return Constants.ERROR_INVALID_ARG;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).BeginJobSpecification(Specification32, Specification64);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D8;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EAddTask(
    [In] FSwarmInterfaceImpl* obj0,
    FTaskSpecification* Specification)
  {
    if (*(long*) ((IntPtr) Specification + 32L) == 0L || (uint) *(int*) ((IntPtr) Specification + 56L) > 0U && *(long*) ((IntPtr) Specification + 48L) == 0L)
      return Constants.ERROR_INVALID_ARG;
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).AddTask(Specification);
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D9;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002EEndJobSpecification(
    [In] FSwarmInterfaceImpl* obj0)
  {
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).EndJobSpecification();
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D10;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ECloseJob([In] FSwarmInterfaceImpl* obj0)
  {
    int num1 = \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).CloseJob();
    if (num1 < 0)
    {
      FInfoMessage finfoMessage;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ref finfoMessage = 16;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(int&) ((IntPtr) &finfoMessage + 4) = 1;
      // ISSUE: cast to a reference type
      // ISSUE: explicit reference operation
      ^(long&) ((IntPtr) &finfoMessage + 8) = (long) &\u003CModule\u003E.\u003FA0x28ecff6c\u002Eunnamed\u002Dglobal\u002D11;
      FSwarmInterfaceImpl* fswarmInterfaceImplPtr = obj0;
      ref FInfoMessage local = ref finfoMessage;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num2 = __calli((__FnPtr<int (IntPtr, FMessage*)>) *(long*) (*(long*) obj0 + 16L))((FMessage*) fswarmInterfaceImplPtr, (IntPtr) ref local);
    }
    return num1;
  }

  internal static unsafe int NSwarm\u002EFSwarmInterfaceImpl\u002ELog(
    [In] FSwarmInterfaceImpl* obj0,
    TVerbosityLevel Verbosity,
    uint TextColour,
    char* Message)
  {
    if ((IntPtr) Message == IntPtr.Zero)
      return Constants.ERROR_NULL_POINTER;
    string Message1 = new string(Message);
    System.Drawing.Color TextColour1 = System.Drawing.Color.FromArgb((int) TextColour);
    return \u003CModule\u003E.gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E((gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E*) ((IntPtr) obj0 + 8L)).Log((EVerbosityLevel) Verbosity, TextColour1, Message1);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* obj0,
    FSwarmInterfaceManagedImpl t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe FSwarmInterfaceManagedImpl gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E\u002E\u002D\u003E(
    [In] gcroot\u003CNSwarm\u003A\u003AFSwarmInterfaceManagedImpl\u0020\u005E\u003E* obj0)
  {
    return (FSwarmInterfaceManagedImpl) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode() => (\u003CModule\u003E.__native_dllmain_reason != uint.MaxValue ? 1 : 0) == 0 || (\u003CModule\u003E.__native_vcclrit_reason != uint.MaxValue ? 1 : 0) != 0 || \u003CModule\u003E.__native_dllmain_reason != 1U && \u003CModule\u003E.__native_dllmain_reason != 0U;

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(
    Exception innerException,
    Exception nestedException)
  {
    throw new ModuleLoadExceptionHandlerException("A nested exception occurred after the primary exception that caused the C++ module to fail to load.\n", innerException, nestedException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage)
  {
    throw new ModuleLoadException(errorMessage);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(
    string errorMessage,
    Exception innerException)
  {
    throw new ModuleLoadException(errorMessage, innerException);
  }

  internal static void \u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(
    EventHandler handler)
  {
    ModuleUninitializer._ModuleUninitializer.AddHandler(handler);
  }

  [SecuritySafeCritical]
  internal static unsafe Guid \u003CCrtImplementationDetails\u003E\u002EFromGUID(_GUID* guid) => new Guid((uint) *(int*) guid, *(ushort*) ((IntPtr) guid + 4L), *(ushort*) ((IntPtr) guid + 6L), *(byte*) ((IntPtr) guid + 8L), *(byte*) ((IntPtr) guid + 9L), *(byte*) ((IntPtr) guid + 10L), *(byte*) ((IntPtr) guid + 11L), *(byte*) ((IntPtr) guid + 12L), *(byte*) ((IntPtr) guid + 13L), *(byte*) ((IntPtr) guid + 14L), *(byte*) ((IntPtr) guid + 15L));

  [SecurityCritical]
  internal static unsafe int __get_default_appdomain(IUnknown** ppUnk)
  {
    ICorRuntimeHost* icorRuntimeHostPtr1 = (ICorRuntimeHost*) 0L;
    int num1;
    try
    {
      Guid riid = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_cb2f6722_ab3a_11d2_9c40_00c04fa30a3e);
      icorRuntimeHostPtr1 = (ICorRuntimeHost*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_cb2f6723_ab3a_11d2_9c40_00c04fa30a3e), riid).ToPointer();
      goto label_4;
    }
    catch (Exception ex)
    {
      num1 = Marshal.GetHRForException(ex);
    }
    if (num1 < 0)
      goto label_5;
label_4:
    ICorRuntimeHost* icorRuntimeHostPtr2 = icorRuntimeHostPtr1;
    IUnknown** iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    num1 = __calli((__FnPtr<int (IntPtr, IUnknown**)>) *(long*) (*(long*) icorRuntimeHostPtr1 + 104L))((IUnknown**) icorRuntimeHostPtr2, (IntPtr) iunknownPtr);
    ICorRuntimeHost* icorRuntimeHostPtr3 = icorRuntimeHostPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num2 = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) icorRuntimeHostPtr3 + 16L))((IntPtr) icorRuntimeHostPtr3);
label_5:
    return num1;
  }

  internal static unsafe void __release_appdomain(IUnknown* ppUnk)
  {
    IUnknown* iunknownPtr = ppUnk;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) iunknownPtr + 16L))((IntPtr) iunknownPtr);
  }

  [SecurityCritical]
  internal static unsafe AppDomain \u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain()
  {
    IUnknown* ppUnk = (IUnknown*) 0L;
    int defaultAppdomain = \u003CModule\u003E.__get_default_appdomain(&ppUnk);
    if (defaultAppdomain >= 0)
    {
      try
      {
        return (AppDomain) Marshal.GetObjectForIUnknown(new IntPtr((void*) ppUnk));
      }
      finally
      {
        \u003CModule\u003E.__release_appdomain(ppUnk);
      }
    }
    else
    {
      Marshal.ThrowExceptionForHR(defaultAppdomain);
      return (AppDomain) null;
    }
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain(
    __FnPtr<int (void*)> function,
    void* cookie)
  {
    Guid riid = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_90f1a06c_7712_4762_86b5_7a5eba6bdb02);
    ICLRRuntimeHost* pointer = (ICLRRuntimeHost*) RuntimeEnvironment.GetRuntimeInterfaceAsIntPtr(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EFromGUID((_GUID*) &\u003CModule\u003E._GUID_90f1a06e_7712_4762_86b5_7a5eba6bdb02), riid).ToPointer();
    try
    {
      AppDomain defaultDomain = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EGetDefaultDomain();
      // ISSUE: cast to a function pointer type
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int errorCode = __calli((__FnPtr<int (IntPtr, uint, __FnPtr<int (void*)>, void*)>) *(long*) (*(long*) pointer + 64L))((void*) pointer, (__FnPtr<int (void*)>) defaultDomain.Id, (uint) function, (IntPtr) cookie);
      if (errorCode >= 0)
        return;
      Marshal.ThrowExceptionForHR(errorCode);
    }
    finally
    {
      ICLRRuntimeHost* iclrRuntimeHostPtr = pointer;
      // ISSUE: cast to a function pointer type
      // ISSUE: function pointer call
      int num = (int) __calli((__FnPtr<uint (IntPtr)>) *(long*) (*(long*) iclrRuntimeHostPtr + 16L))((IntPtr) iclrRuntimeHostPtr);
    }
  }

  [SecuritySafeCritical]
  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EDoNothing(
    void* cookie)
  {
    GC.KeepAlive((object) int.MaxValue);
    return 0;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess()
  {
    if (\u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr = (void**) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_a;
    if (ref \u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_a < ref \u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_z)
    {
      while (*(long*) voidPtr == 0L)
      {
        voidPtr += 8L;
        if ((IntPtr) voidPtr >= ref \u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    \u003CModule\u003E.\u003FhasPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static unsafe bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative()
  {
    if (\u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A != (TriBool.State) 2)
      return \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A == (TriBool.State) -1;
    void** voidPtr1 = (void**) &\u003CModule\u003E.__xi_a;
    if (ref \u003CModule\u003E.__xi_a < ref \u003CModule\u003E.__xi_z)
    {
      while (*(long*) voidPtr1 == 0L)
      {
        voidPtr1 += 8L;
        if ((IntPtr) voidPtr1 >= ref \u003CModule\u003E.__xi_z)
          goto label_5;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_5:
    void** voidPtr2 = (void**) &\u003CModule\u003E.__xc_a;
    if (ref \u003CModule\u003E.__xc_a < ref \u003CModule\u003E.__xc_z)
    {
      while (*(long*) voidPtr2 == 0L)
      {
        voidPtr2 += 8L;
        if ((IntPtr) voidPtr2 >= ref \u003CModule\u003E.__xc_z)
          goto label_9;
      }
      \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) -1;
      return true;
    }
label_9:
    \u003CModule\u003E.\u003FhasNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00400W4State\u0040TriBool\u00402\u0040A = (TriBool.State) 0;
    return false;
  }

  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasPerProcess() && !\u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA || \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EHasNative() && !\u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA && \u003CModule\u003E.__native_startup_state == (__enative_startup_state) 0;

  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization() => \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003FDoNothing\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z, (void*) 0L);

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 0;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = false;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  internal static void \u003FA0x73b2ab14\u002E\u003F\u003F__E\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 0;

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during vtable initialization.\n");
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xi_vt_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xi_vt_z);
    \u003CModule\u003E.\u003FInitializedVtables\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load while attempting to initialize the default appdomain.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002EInitialize();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during native initialization.\n");
    \u003CModule\u003E.__security_init_cookie();
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ENativeDll\u002EIsSafeForManagedCode())
      \u003CModule\u003E._amsg_exit(33);
    switch (\u003CModule\u003E.__native_startup_state)
    {
      case (__enative_startup_state) 0:
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 1;
        if (\u003CModule\u003E._initterm_e((__FnPtr<int ()>*) &\u003CModule\u003E.__xi_a, (__FnPtr<int ()>*) &\u003CModule\u003E.__xi_z) != 0)
          \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0));
        \u003CModule\u003E._initterm((__FnPtr<void ()>*) &\u003CModule\u003E.__xc_a, (__FnPtr<void ()>*) &\u003CModule\u003E.__xc_z);
        \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 2;
        \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
        \u003CModule\u003E.\u003FInitializedNative\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
        break;
      case (__enative_startup_state) 1:
        \u003CModule\u003E._amsg_exit(33);
        break;
    }
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during process initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_m();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_mp_z);
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = true;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during appdomain initialization.\n");
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 1;
    \u003CModule\u003E._initatexit_app_domain();
    \u003CModule\u003E._initterm_m((__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_ma_a, (__FnPtr<void* ()>*) &\u003CModule\u003E.\u003FA0x73b2ab14\u002E__xc_ma_z);
    \u003CModule\u003E.\u003FInitializedPerAppDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2W4State\u0040Progress\u00402\u0040A = (Progress.State) 2;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load during registration for the unload events.\n");
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ERegisterModuleUninitializer(new EventHandler(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload));
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA = AppDomain.CurrentDomain.IsDefaultAppDomain();
    \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = \u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA || \u003CModule\u003E.\u003FEntered\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA;
    void* fiberPtrId = \u003CModule\u003E._getFiberPtrId();
    int num1 = 0;
    int num2 = 0;
    int num3 = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      while (num2 == 0)
      {
        try
        {
        }
        finally
        {
          // ISSUE: cast to a reference type
          void* voidPtr = (void*) Interlocked.CompareExchange((long&) ref \u003CModule\u003E.__native_startup_lock, (long) fiberPtrId, 0L);
          if ((IntPtr) voidPtr == IntPtr.Zero)
            num2 = 1;
          else if (voidPtr == fiberPtrId)
          {
            num1 = 1;
            num2 = 1;
          }
        }
        if (num2 == 0)
          \u003CModule\u003E.Sleep(1000U);
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeVtables(obj0);
      if (\u003CModule\u003E.\u003FIsDefaultDomain\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2_NA)
      {
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeNative(obj0);
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerProcess(obj0);
      }
      else
        num3 = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsInitialization() ? 1 : num3;
    }
    finally
    {
      if (num1 == 0)
      {
        // ISSUE: cast to a reference type
        Interlocked.Exchange((long&) ref \u003CModule\u003E.__native_startup_lock, 0L);
      }
    }
    if (num3 != 0)
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeDefaultAppDomain(obj0);
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializePerAppDomain(obj0);
    \u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA = 1;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitializeUninitializer(obj0);
  }

  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain() => \u003CModule\u003E._app_exit_callback();

  [SecurityCritical]
  internal static unsafe int \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain(
    void* cookie)
  {
    \u003CModule\u003E._exit_callback();
    \u003CModule\u003E.\u003FInitializedPerProcess\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    if (\u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA)
    {
      \u003CModule\u003E._cexit();
      \u003CModule\u003E.__native_startup_state = (__enative_startup_state) 0;
      \u003CModule\u003E.\u003FInitializedNativeFromCCTOR\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    }
    \u003CModule\u003E.\u003FInitializedNative\u0040DefaultDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402_NA = false;
    return 0;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDefaultDomain\u002ENeedsUninitialization())
      return;
    if (AppDomain.CurrentDomain.IsDefaultAppDomain())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_UninitializeDefaultDomain((void*) 0L);
    }
    else
    {
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EDoCallBackInDefaultDomain((__FnPtr<int (void*)>) (IntPtr) \u003CModule\u003E.__unep\u0040\u003F_UninitializeDefaultDomain\u0040LanguageSupport\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024FCAJPEAX\u0040Z, (void*) 0L);
    }
  }

  [SecurityCritical]
  [PrePrepareMethod]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EDomainUnload(
    object source,
    EventArgs arguments)
  {
    if (\u003CModule\u003E.\u003FInitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA == 0 || Interlocked.Exchange(ref \u003CModule\u003E.\u003FUninitialized\u0040CurrentDomain\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q2HA, 1) != 0)
      return;
    int num = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0 ? 1 : 0;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
    if ((byte) num == (byte) 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(
    [In] LanguageSupport* obj0,
    Exception innerException)
  {
    try
    {
      bool flag = Interlocked.Decrement(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA) == 0;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeAppDomain();
      if (!flag)
        return;
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EUninitializeDefaultDomain();
    }
    catch (Exception ex)
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, ex);
    }
    catch
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowNestedModuleLoadException(innerException, (Exception) null);
    }
  }

  [SecurityCritical]
  internal static unsafe LanguageSupport* \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
    return obj0;
  }

  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(
    [In] LanguageSupport* obj0)
  {
    \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0);
  }

  [DebuggerStepThrough]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(
    [In] LanguageSupport* obj0)
  {
    bool flag = false;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      \u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0, "The C++ module failed to load.\n");
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref \u003CModule\u003E.\u003FCount\u0040AllDomains\u0040\u003CCrtImplementationDetails\u003E\u0040\u00402HA);
        flag = true;
      }
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E_Initialize(obj0);
    }
    catch (Exception ex)
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, ex);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), ex);
    }
    catch
    {
      if (flag)
        \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002ECleanup(obj0, (Exception) null);
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThrowModuleLoadException(\u003CModule\u003E.gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040((gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E*) obj0), (Exception) null);
    }
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  static unsafe \u003CModule\u003E()
  {
    LanguageSupport languageSupport;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bctor\u007D(&languageSupport);
    // ISSUE: fault handler
    try
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002EInitialize(&languageSupport);
    }
    __fault
    {
      // ISSUE: method pointer
      // ISSUE: cast to a function pointer type
      \u003CModule\u003E.___CxxCallUnwindDtor((__FnPtr<void (void*)>) __methodptr(\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D), (void*) &languageSupport);
    }
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002ELanguageSupport\u002E\u007Bdtor\u007D(&languageSupport);
  }

  [SecuritySafeCritical]
  [DebuggerStepThrough]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bctor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    IntPtr num = (IntPtr) GCHandle.Alloc((object) null);
    *(long*) obj0 = (long) num.ToPointer();
    return obj0;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u007Bdtor\u007D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Free();
    *(long*) obj0 = 0L;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u003D(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0,
    string t)
  {
    ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target = (object) t;
    return obj0;
  }

  [SecuritySafeCritical]
  internal static unsafe string gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E\u002E\u002EPE\u0024AAVString\u0040System\u0040\u0040(
    [In] gcroot\u003CSystem\u003A\u003AString\u0020\u005E\u003E* obj0)
  {
    return (string) ((GCHandle) new IntPtr((void*) *(long*) obj0)).Target;
  }

  internal static unsafe void std\u002E_Fac_node\u002E\u007Bdtor\u007D([In] _Fac_node* obj0)
  {
    locale.facet* facetPtr1 = \u003CModule\u003E.std\u002Elocale\u002Efacet\u002E_Decref((locale.facet*) *(long*) ((IntPtr) obj0 + 8L));
    if ((IntPtr) facetPtr1 == IntPtr.Zero)
      return;
    locale.facet* facetPtr2 = facetPtr1;
    // ISSUE: cast to a function pointer type
    // ISSUE: function pointer call
    void* voidPtr = __calli((__FnPtr<void* (IntPtr, uint)>) *(long*) *(long*) facetPtr1)((uint) facetPtr2, new IntPtr(1));
  }

  internal static unsafe void \u003FA0x89bca58d\u002E_Fac_tidy()
  {
    bool flag = false;
    int num = 0;
    RuntimeHelpers.PrepareConstrainedRegions();
    try
    {
      RuntimeHelpers.PrepareConstrainedRegions();
      try
      {
      }
      finally
      {
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_ctor(num);
        flag = true;
      }
      while ((IntPtr) \u003CModule\u003E.std\u002E\u003FA0x89bca58d\u002E_Fac_head != IntPtr.Zero)
      {
        _Fac_node* a0x89bca58dFacHead = \u003CModule\u003E.std\u002E\u003FA0x89bca58d\u002E_Fac_head;
        \u003CModule\u003E.std\u002E\u003FA0x89bca58d\u002E_Fac_head = (_Fac_node*) *(long*) \u003CModule\u003E.std\u002E\u003FA0x89bca58d\u002E_Fac_head;
        \u003CModule\u003E.std\u002E_Fac_node\u002E__delDtor(a0x89bca58dFacHead, 1U);
      }
    }
    finally
    {
      if (flag)
        \u003CModule\u003E.std\u002E_Lockit\u002E_Lockit_dtor(num);
    }
  }

  internal static unsafe void* std\u002E_Fac_node\u002E__delDtor([In] _Fac_node* obj0, uint _param1)
  {
    \u003CModule\u003E.std\u002E_Fac_node\u002E\u007Bdtor\u007D(obj0);
    if (((int) _param1 & 1) != 0)
      \u003CModule\u003E.delete((void*) obj0);
    return (void*) obj0;
  }

  internal static void \u003FA0x89bca58d\u002E\u003F\u003F__E\u003FA0x89bca58d\u0040_Fac_tidy_reg\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E._atexit_m_appdomain((__FnPtr<void ()>) __methodptr(\u003FA0x89bca58d\u002E\u003F\u003F__F\u003FA0x89bca58d\u0040_Fac_tidy_reg\u0040std\u0040\u0040YMXXZ));

  internal static void \u003FA0x89bca58d\u002E\u003F\u003F__F\u003FA0x89bca58d\u0040_Fac_tidy_reg\u0040std\u0040\u0040YMXXZ() => \u003CModule\u003E.\u003FA0x89bca58d\u002E_Fac_tidy();

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [HandleProcessCorruptedStateExceptions]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void ___CxxCallUnwindDtor(__FnPtr<void (void*)> pDtor, void* pThis)
  {
    try
    {
      void* voidPtr = pThis;
      // ISSUE: function pointer call
      __calli(pDtor)(voidPtr);
    }
    catch (Exception ex) when (\u003CModule\u003E.__FrameUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [HandleProcessCorruptedStateExceptions]
  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  internal static unsafe void __ehvec_dtor(
    void* ptr,
    ulong size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    int num = 0;
    ptr = (void*) ((long) count * (long) size + (IntPtr) ptr);
    try
    {
      while (true)
      {
        count += -1;
        if (count >= 0)
        {
          ptr -= (long) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
      num = 1;
    }
    finally
    {
      if (num == 0)
        \u003CModule\u003E.__ArrayUnwind(ptr, size, count, pDtor);
    }
  }

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe int \u003FA0xb49558ae\u002EArrayUnwindFilter(_EXCEPTION_POINTERS* pExPtrs)
  {
    if (*(int*) *(long*) pExPtrs != -529697949)
      return 0;
    \u003CModule\u003E.terminate();
    return 0;
  }

  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void __ArrayUnwind(
    void* ptr,
    ulong size,
    int count,
    __FnPtr<void (void*)> pDtor)
  {
    try
    {
      while (true)
      {
        count += -1;
        if (count >= 0)
        {
          ptr -= (long) size;
          void* voidPtr = ptr;
          // ISSUE: function pointer call
          __calli(pDtor)(voidPtr);
        }
        else
          break;
      }
    }
    catch (Exception ex) when (\u003CModule\u003E.\u003FA0xb49558ae\u002EArrayUnwindFilter((_EXCEPTION_POINTERS*) Marshal.GetExceptionPointers()) != 0)
    {
    }
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe ValueType \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle() => (IntPtr) \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA != IntPtr.Zero ? (ValueType) GCHandle.FromIntPtr(new IntPtr(\u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA)) : (ValueType) null;

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(
    object value)
  {
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = (void*) 0L;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(value);
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Set(
    object value)
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = GCHandle.ToIntPtr(GCHandle.Alloc(value)).ToPointer();
    else
      ((GCHandle) valueType).Target = value;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static object \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    return valueType != null ? ((GCHandle) valueType).Target : (object) null;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct()
  {
    ValueType valueType = \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_handle();
    if (valueType == null)
      return;
    ((GCHandle) valueType).Free();
    \u003CModule\u003E.\u003F_lock\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0PEAXEA = (void*) 0L;
  }

  [DebuggerStepThrough]
  [SecuritySafeCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get() != null;

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef()
  {
    if (!\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Construct(new object());
      \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA = 0;
    }
    ++\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef()
  {
    \u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA += -1;
    if (\u003CModule\u003E.\u003F_ref_count\u0040AtExitLock\u0040\u003CCrtImplementationDetails\u003E\u0040\u0040\u0024\u0024Q0HA != 0)
      return;
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Destruct();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter() => System.Threading.Monitor.Enter(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static void \u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit() => System.Threading.Monitor.Exit(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002E_lock_Get());

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x47cf2733\u002E__global_lock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EEnter();
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x47cf2733\u002E__global_unlock()
  {
    bool flag = false;
    if (\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized())
    {
      \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EExit();
      flag = true;
    }
    return flag;
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static bool \u003FA0x47cf2733\u002E__alloc_global_lock()
  {
    \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EAddRef();
    return \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002EIsInitialized();
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static void \u003FA0x47cf2733\u002E__dealloc_global_lock() => \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EAtExitLock\u002ERemoveRef();

  [SecurityCritical]
  internal static unsafe int _atexit_helper(
    __FnPtr<void ()> func,
    ulong* __pexit_list_size,
    __FnPtr<void ()>** __ponexitend_e,
    __FnPtr<void ()>** __ponexitbegin_e)
  {
    // ISSUE: cast to a function pointer type
    __FnPtr<void ()> local1 = (__FnPtr<void ()>) 0L;
    if (func == null)
      return -1;
    int num1;
    if (\u003CModule\u003E.\u003FA0x47cf2733\u002E__global_lock())
    {
      try
      {
        __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) *(long*) __ponexitbegin_e);
        __FnPtr<void ()>* local3 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) *(long*) __ponexitend_e);
        long num2 = (long) ((IntPtr) local3 - (IntPtr) local2);
        if (*__pexit_list_size - 1UL < (ulong) num2 >> 3)
        {
          try
          {
            ulong num3 = *__pexit_list_size * 8UL;
            ulong num4 = num3 < 4096UL ? num3 : 4096UL;
            IntPtr cb = new IntPtr((int) ((long) num3 + (long) num4));
            IntPtr num5 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num5.ToPointer() + num2);
            local2 = (__FnPtr<void ()>*) num5.ToPointer();
            ulong num6 = *__pexit_list_size;
            ulong num7 = 512UL < num6 ? 512UL : num6;
            *__pexit_list_size = num6 + num7;
          }
          catch (OutOfMemoryException ex)
          {
            IntPtr cb = new IntPtr((int) ((long) *__pexit_list_size * 8L + 12L));
            IntPtr num3 = Marshal.ReAllocHGlobal(new IntPtr((void*) local2), cb);
            local3 = (__FnPtr<void ()>*) ((IntPtr) num3.ToPointer() - (IntPtr) local2 + (IntPtr) local3);
            local2 = (__FnPtr<void ()>*) num3.ToPointer();
            ulong* numPtr = __pexit_list_size;
            long num4 = (long) *numPtr + 4L;
            *numPtr = (ulong) num4;
          }
        }
        *(long*) local3 = (long) func;
        __FnPtr<void ()>* local4 = (__FnPtr<void ()>*) ((IntPtr) local3 + 8L);
        local1 = func;
        *(long*) __ponexitbegin_e = (long) \u003CModule\u003E.EncodePointer((void*) local2);
        *(long*) __ponexitend_e = (long) \u003CModule\u003E.EncodePointer((void*) local4);
      }
      catch (OutOfMemoryException ex)
      {
      }
      finally
      {
        \u003CModule\u003E.\u003FA0x47cf2733\u002E__global_unlock();
      }
      if (local1 != null)
      {
        num1 = 0;
        goto label_12;
      }
    }
    num1 = -1;
label_12:
    return num1;
  }

  [SecurityCritical]
  internal static unsafe void _exit_callback()
  {
    if (\u003CModule\u003E.\u003FA0x47cf2733\u002E__exit_list_size == 0UL)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitbegin_m);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitend_m);
    if ((IntPtr) local1 != -1L && (IntPtr) local1 != IntPtr.Zero && (IntPtr) local2 != IntPtr.Zero)
    {
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 8L;
            if (local2 < local1)
              goto label_7;
          }
          while (*(long*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          void* voidPtr = \u003CModule\u003E.DecodePointer((void*) *(long*) local2);
          *(long*) local2 = (long) \u003CModule\u003E._encoded_null();
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          __calli((__FnPtr<void ()>) (IntPtr) voidPtr)();
          local5 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitbegin_m);
          local6 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitend_m);
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_7:
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
    }
    \u003CModule\u003E.\u003FA0x47cf2733\u002E__dealloc_global_lock();
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe int _initatexit_m()
  {
    if (!\u003CModule\u003E.\u003FA0x47cf2733\u002E__alloc_global_lock())
      return 0;
    \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitbegin_m = (__FnPtr<void ()>*) \u003CModule\u003E.EncodePointer(Marshal.AllocHGlobal(256).ToPointer());
    \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitend_m = \u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitbegin_m;
    \u003CModule\u003E.\u003FA0x47cf2733\u002E__exit_list_size = 32UL;
    return 1;
  }

  [SecurityCritical]
  internal static unsafe int _atexit_m(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.EncodePointer((void*) func), &\u003CModule\u003E.\u003FA0x47cf2733\u002E__exit_list_size, &\u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitend_m, &\u003CModule\u003E.\u003FA0x47cf2733\u002E__onexitbegin_m);

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initatexit_app_domain()
  {
    if (\u003CModule\u003E.\u003FA0x47cf2733\u002E__alloc_global_lock())
    {
      \u003CModule\u003E.__onexitbegin_app_domain = (__FnPtr<void ()>*) \u003CModule\u003E.EncodePointer(Marshal.AllocHGlobal(256).ToPointer());
      \u003CModule\u003E.__onexitend_app_domain = \u003CModule\u003E.__onexitbegin_app_domain;
      \u003CModule\u003E.__exit_list_size_app_domain = 32UL;
    }
    return 1;
  }

  [SecurityCritical]
  [HandleProcessCorruptedStateExceptions]
  internal static unsafe void _app_exit_callback()
  {
    if (\u003CModule\u003E.__exit_list_size_app_domain == 0UL)
      return;
    __FnPtr<void ()>* local1 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
    __FnPtr<void ()>* local2 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
    try
    {
      if ((IntPtr) local1 == -1L || (IntPtr) local1 == IntPtr.Zero || (IntPtr) local2 == IntPtr.Zero)
        return;
      __FnPtr<void ()>* local3 = local1;
      __FnPtr<void ()>* local4 = local2;
      while (true)
      {
        __FnPtr<void ()>* local5;
        __FnPtr<void ()>* local6;
        do
        {
          do
          {
            local2 -= 8L;
          }
          while (local2 >= local1 && *(long*) local2 == (IntPtr) \u003CModule\u003E._encoded_null());
          if (local2 >= local1)
          {
            // ISSUE: cast to a function pointer type
            __FnPtr<void ()> local7 = (__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.DecodePointer((void*) *(long*) local2);
            *(long*) local2 = (long) \u003CModule\u003E._encoded_null();
            // ISSUE: function pointer call
            __calli(local7)();
            local5 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitbegin_app_domain);
            local6 = (__FnPtr<void ()>*) \u003CModule\u003E.DecodePointer((void*) \u003CModule\u003E.__onexitend_app_domain);
          }
          else
            goto label_12;
        }
        while (local3 == local5 && local4 == local6);
        local3 = local5;
        local1 = local5;
        local4 = local6;
        local2 = local6;
      }
label_12:;
    }
    finally
    {
      Marshal.FreeHGlobal(new IntPtr((void*) local1));
      \u003CModule\u003E.\u003FA0x47cf2733\u002E__dealloc_global_lock();
    }
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _atexit_m_appdomain(__FnPtr<void ()> func) => \u003CModule\u003E._atexit_helper((__FnPtr<void ()>) (IntPtr) \u003CModule\u003E.EncodePointer((void*) func), &\u003CModule\u003E.__exit_list_size_app_domain, &\u003CModule\u003E.__onexitend_app_domain, &\u003CModule\u003E.__onexitbegin_app_domain);

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* DecodePointer(void* Ptr);

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("MSVCR100.dll", CallingConvention = CallingConvention.Cdecl)]
  public static extern unsafe void* _encoded_null();

  [SecurityCritical]
  [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
  [SuppressUnmanagedCodeSecurity]
  [DllImport("KERNEL32.dll")]
  public static extern unsafe void* EncodePointer(void* Ptr);

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe int _initterm_e(__FnPtr<int ()>* pfbegin, __FnPtr<int ()>* pfend)
  {
    int num1 = 0;
    if (pfbegin < pfend)
    {
      while (num1 == 0)
      {
        ulong num2 = (ulong) *(long*) pfbegin;
        if (num2 != 0UL)
        {
          // ISSUE: cast to a function pointer type
          // ISSUE: function pointer call
          num1 = __calli((__FnPtr<int ()>) (long) num2)();
        }
        pfbegin += 8L;
        if (pfbegin >= pfend)
          break;
      }
    }
    return num1;
  }

  [SecurityCritical]
  [DebuggerStepThrough]
  internal static unsafe void _initterm(__FnPtr<void ()>* pfbegin, __FnPtr<void ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      ulong num = (ulong) *(long*) pfbegin;
      if (num != 0UL)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        __calli((__FnPtr<void ()>) (long) num)();
      }
      pfbegin += 8L;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  internal static ModuleHandle \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle() => typeof (ThisModule).Module.ModuleHandle;

  [DebuggerStepThrough]
  [SecurityCritical]
  [SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
  internal static unsafe void _initterm_m(__FnPtr<void* ()>* pfbegin, __FnPtr<void* ()>* pfend)
  {
    if (pfbegin >= pfend)
      return;
    do
    {
      ulong num = (ulong) *(long*) pfbegin;
      if (num != 0UL)
      {
        // ISSUE: cast to a function pointer type
        // ISSUE: function pointer call
        void* voidPtr = __calli(\u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E((__FnPtr<void* ()>) (long) num))();
      }
      pfbegin += 8L;
    }
    while (pfbegin < pfend);
  }

  [DebuggerStepThrough]
  [SecurityCritical]
  internal static unsafe __FnPtr<void* ()> \u003CCrtImplementationDetails\u003E\u002EThisModule\u002EResolveMethod\u003Cvoid\u0020const\u0020\u002A\u0020__clrcall\u0028void\u0029\u003E(
    __FnPtr<void* ()> methodToken)
  {
    // ISSUE: cast to a function pointer type
    return (__FnPtr<void* ()>) (IntPtr) \u003CModule\u003E.\u003CCrtImplementationDetails\u003E\u002EThisModule\u002EHandle().ResolveMethodHandle((int) methodToken).GetFunctionPointer().ToPointer();
  }

  [STAThread]
  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint WinMainCRTStartup();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxString* wxString\u002E\u007Bctor\u007D(
    [In] wxString* obj0,
    [In] wxString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxString* wxString\u002E\u007Bctor\u007D(
    [In] wxString* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxString\u002E\u007Bdtor\u007D([In] wxString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxRect* wxRect\u002E\u007Bctor\u007D([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxRect* wxRect\u002E\u007Bctor\u007D(
    [In] wxRect* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetX([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetY([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetWidth([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetHeight([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxColour* wxColour\u002E\u007Bctor\u007D(
    [In] wxColour* obj0,
    [In] byte obj1,
    [In] byte obj2,
    [In] byte obj3,
    [In] byte obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* wxGetTranslation([In] char* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxRect* wxWindowBase\u002EGetRect(
    [In] wxWindowBase* obj0,
    [In] wxRect* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern float appPow([In] float obj0, [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int appRand();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FHeapAllocator\u002EForAnyElementType\u002E\u007Bdtor\u007D(
    [In] FHeapAllocator.ForAnyElementType* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* @new([In] ulong obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void delete([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void delete\u005B\u005D([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u007Bctor\u007D([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u007Bctor\u007D(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u007Bctor\u007D(
    [In] FString* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FString\u002E\u002A([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FString\u002E\u003D\u003D([In] FString* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FString\u002ELen([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FString\u002E\u007Bdtor\u007D([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* FName\u002E\u007Bctor\u007D([In] FName* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UObject\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UObject\u002EHasAnyFlags([In] UObject* obj0, [In] ulong obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern VectorRegister MakeVectorRegister(
    [In] float obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor* FLinearColor\u002E\u007Bctor\u007D(
    [In] FLinearColor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float* FLinearColor\u002EComponent([In] FLinearColor* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColor* FColor\u002E\u007Bctor\u007D(
    [In] FColor* obj0,
    [In] byte obj1,
    [In] byte obj2,
    [In] byte obj3,
    [In] byte obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float* FVector2D\u002E\u005B\u005D([In] FVector2D* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FVector* FVector\u002E\u007Bctor\u007D(
    [In] FVector* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float* FVector\u002E\u005B\u005D([In] FVector* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float* FVector4\u002E\u005B\u005D([In] FVector4* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FRotator* FRotator\u002E\u007Bctor\u007D(
    [In] FRotator* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FStringNoInit\u002E\u007Bdtor\u007D([In] FStringNoInit* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FCallbackEventDevice* FCallbackEventDevice\u002E\u007Bctor\u007D(
    [In] FCallbackEventDevice* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* USelection\u002EGetTop(
    [In] USelection* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArrayNoInit\u003Cint\u003E\u002E\u007Bdtor\u007D(
    [In] TArrayNoInit\u003Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FPostProcessSettings\u002E\u007Bdtor\u007D(
    [In] FPostProcessSettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FPostProcessSettings* FPostProcessSettings\u002E\u007Bctor\u007D(
    [In] FPostProcessSettings* obj0,
    [In] FPostProcessSettings* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FMusicTrackStruct\u002E\u007Bdtor\u007D([In] FMusicTrackStruct* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FMusicTrackStruct* FMusicTrackStruct\u002E\u007Bctor\u007D(
    [In] FMusicTrackStruct* obj0,
    [In] FMusicTrackStruct* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArrayNoInit\u003CFSeqOpOutputInputLink\u003E\u002E\u007Bdtor\u007D(
    [In] TArrayNoInit\u003CFSeqOpOutputInputLink\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMap\u003CFString\u002Cint\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003CFString\u002Cint\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe Vec3* SpeedTree\u002EVec3\u002E\u007Bctor\u007D(
    [In] Vec3* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FPickColorStruct* FPickColorStruct\u002E\u007Bctor\u007D(
    [In] FPickColorStruct* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSelectedAssetInfo* FSelectedAssetInfo\u002E\u007Bctor\u007D(
    [In] FSelectedAssetInfo* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void OC3Ent\u002EFace\u002EFxArray\u003Cfloat\u003E\u002E\u007Bdtor\u007D(
    [In] FxArray\u003Cfloat\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void OC3Ent\u002EFace\u002EFxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E\u002E\u007Bdtor\u007D(
    [In] FxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* FIntVector2\u002E\u005B\u005D([In] FIntVector2* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* FIntVector3\u002E\u005B\u005D([In] FIntVector3* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* FIntVector4\u002E\u005B\u005D([In] FIntVector4* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EList\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E\u002E\u007Bdtor\u007D(
    [In] List\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E\u002E\u007Bdtor\u007D(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFString\u002CFDefaultAllocator\u003E* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UObject** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cint\u002CFDefaultAllocator\u003E* TArray\u003Cint\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cint\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cint\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* TArray\u003Cint\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cint\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj0,
    [In] int* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cfloat\u002CFDefaultAllocator\u003E* TArray\u003Cfloat\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cfloat\u002CFDefaultAllocator\u003E* TArray\u003Cfloat\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cfloat\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cfloat\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float* TArray\u003Cfloat\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E* TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003Cunsigned\u0020long\u002CFDefaultAllocator\u003E* obj0,
    [In] uint* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CFString\u002Cint\u002CFDefaultSetAllocator\u003E* TMap\u003CFString\u002Cint\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003CFString\u002Cint\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E\u002ESet(
    [In] TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E\u002EHasKey(
    [In] TMapBase\u003CFString\u002Cint\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFDebugNavCost\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFDebugNavCost\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CANavigationPoint\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CANavigationPoint\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFPathStep\u003A\u003AFPathEnd\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFPathStep\u003A\u003AFPathEnd\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CTArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FLinearColor** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USubstanceAirTexture2D** std\u002Etr1\u002Eshared_ptr\u003CUSubstanceAirTexture2D\u0020\u002A\u003E\u002E\u002A(
    [In] shared_ptr\u003CUSubstanceAirTexture2D\u0020\u002A\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E\u002Eitfront(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E* obj0,
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E\u002E\u0028\u0029(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E\u002ENum(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E* TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe List\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E* SubstanceAir\u002EList\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E\u002E\u007Bctor\u007D(
    [In] List\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EList\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E\u002Epush(
    [In] List\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E* obj0,
    [In] FGraphInstance** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* SubstanceAir\u002EList\u003CSubstanceAir\u003A\u003AFOutputInstance\u003E\u002Eitfront(
    [In] List\u003CSubstanceAir\u003A\u003AFOutputInstance\u003E* obj0,
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E\u002Eitfront(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E* obj0,
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E\u002E\u0028\u0029(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SubstanceAir\u002EList\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E\u002ENum(
    [In] List\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u0020\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E* TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FInputDescBase* std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002Eget(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FInputDescBase* std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002E\u002A(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FInputDescBase* std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002E\u002D\u003E(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FInputInstanceBase* std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002Eget(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FInputInstanceBase* std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002E\u002A(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FOutputInstance* TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FOutputInstance* TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002D\u003E(
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerIterator\u003CTArray\u003CSubstanceAir\u003A\u003AFOutputInstance\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerIterator\u003CTArray\u003Cstd\u003A\u003Atr1\u003A\u003Ashared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0,
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E* obj1,
    [In] uint obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002E_N(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002EKey(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002EValue(
    [In] TMapBase\u003Cint\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSelectedAssetInfo* TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E\u002E\u007Bdtor\u007D(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002Etr1\u002Eshared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002E\u007Bdtor\u007D(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFPathStep\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFPathStep\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int Clamp\u003Cint\u003E([In] int obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cint\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void Sort\u003Cclass\u0020std\u003A\u003Atr1\u003A\u003Ashared_ptr\u003Cstruct\u0020SubstanceAir\u003A\u003AFInputDescBase\u003E\u002Cclass\u0020CompareSubstanceAirEdGraphInstanceEditorinput_desc_ptrConstRef\u003E(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputDescBase\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void Sort\u003Cclass\u0020std\u003A\u003Atr1\u003A\u003Ashared_ptr\u003Cstruct\u0020SubstanceAir\u003A\u003AFInputInstanceBase\u003E\u002Cclass\u0020CompareSubstanceAirEdGraphInstanceEditorinput_inst_t_ptrConstRef\u003E(
    [In] shared_ptr\u003CSubstanceAir\u003A\u003AFInputInstanceBase\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EFNumericalInputInstanceBase\u002EGetValue\u003Cfloat\u003E(
    [In] FNumericalInputInstanceBase* obj0,
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EFNumericalInputInstanceBase\u002EGetValue\u003Cint\u003E(
    [In] FNumericalInputInstanceBase* obj0,
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cstruct\u0020FSelectedAssetInfo\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USubstanceAirImageInput* Cast\u003Cclass\u0020USubstanceAirImageInput\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USubstanceAirTexture2D* Cast\u003Cclass\u0020USubstanceAirTexture2D\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* LoadObject\u003Cclass\u0020UObject\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] UPackageMap* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SubstanceAir\u002EFGraphInstance\u002EUpdateInput\u003Cint\u003E(
    [In] FGraphInstance* obj0,
    [In] uint* obj1,
    [In] TArray\u003Cint\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SubstanceAir\u002EFGraphInstance\u002EUpdateInput\u003Cfloat\u003E(
    [In] FGraphInstance* obj0,
    [In] uint* obj1,
    [In] TArray\u003Cfloat\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E* OC3Ent\u002EFace\u002EFxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E\u002E\u007Bctor\u007D(
    [In] FxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E* obj0,
    [In] FxArray\u003COC3Ent\u003A\u003AFace\u003A\u003AFxEmphasisActionTrack\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FxName* OC3Ent\u002EFace\u002EFxName\u002E\u007Bctor\u007D(
    [In] FxName* obj0,
    [In] FxName* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void OC3Ent\u002EFace\u002EFxName\u002E\u007Bdtor\u007D([In] FxName* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GetWindowRect([In] HWND__* obj0, [In] tagRECT* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint WxUnrealEdApp\u002ECheckIfGlobalHotkey(
    [In] FName obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FCallbackEventDevice\u002E\u007Bdtor\u007D(
    [In] FCallbackEventDevice* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* Localize(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] uint obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* GetEditorResourcesDir([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GetClientRect([In] HWND__* obj0, [In] tagRECT* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxColour\u002E\u007Bdtor\u007D([In] wxColour* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxEditorFrame\u002ESyncBrowserToObjects(
    [In] WxEditorFrame* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern short GetAsyncKeyState([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* FName\u002E\u007Bctor\u007D(
    [In] FName* obj0,
    [In] char* obj1,
    [In] EFindName obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SubstanceAir\u002EFGraphInstance\u002EUpdateInput(
    [In] FGraphInstance* obj0,
    [In] uint* obj1,
    [In] UObject* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EHelpers\u002ERenderAsync([In] FGraphInstance* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EHelpers\u002ERenderAsync(
    [In] List\u003CSubstanceAir\u003A\u003AFGraphInstance\u0020\u002A\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EHelpers\u002ECreateTexture2D(
    [In] FOutputInstance* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EHelpers\u002EResetToDefault(
    [In] FGraphInstance* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void SubstanceAir\u002EHelpers\u002ERegisterForDeletion(
    [In] USubstanceAirTexture2D* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void SubstanceAir\u002EHelpers\u002EFlagRefreshContentBrowser([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void SubstanceAir\u002EHelpers\u002ETick();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGraphInstance* SubstanceAir\u002EFOutputInstance\u002EGetParentGraphInstance(
    [In] FOutputInstance* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FOutputDesc* SubstanceAir\u002EFOutputInstance\u002EGetOutputDesc(
    [In] FOutputInstance* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe HWND__* GetDesktopWindow();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int SetWindowPos(
    [In] HWND__* obj0,
    [In] HWND__* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] int obj5,
    [In] uint obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FString\u002EParseIntoArray(
    [In] FString* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1,
    [In] char* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int ShowWindow([In] HWND__* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern int GetSystemMetrics([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UObject\u002EIsReferenced([In] UObject** obj0, [In] ulong obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* UObject\u002EGetOutermost([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int EnableWindow([In] HWND__* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] exception* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002Eexception\u002E\u007Bdtor\u007D([In] exception* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe long DefWindowProcW(
    [In] HWND__* obj0,
    [In] uint obj1,
    [In] ulong obj2,
    [In] long obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USelection* UEditorEngine\u002EGetSelectedSet(
    [In] UEditorEngine* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FScopedTransaction* FScopedTransaction\u002E\u007Bctor\u007D(
    [In] FScopedTransaction* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FScopedTransaction\u002E\u007Bdtor\u007D(
    [In] FScopedTransaction* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* wxStringBase\u002Ec_str([In] wxStringBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* wxString\u002E\u002EPEB_W([In] wxString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxArrayString* wxArrayString\u002E\u007Bctor\u007D(
    [In] wxArrayString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ulong wxArrayString\u002EGetCount([In] wxArrayString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxString* wxArrayString\u002E\u005B\u005D(
    [In] wxArrayString* obj0,
    [In] ulong obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxSize\u002EGetWidth([In] wxSize* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxSize\u002EGetHeight([In] wxSize* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetLeft([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxRect\u002EGetTop([In] wxRect* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxEvent\u002ESetEventType([In] wxEvent* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxPostEvent([In] wxEvtHandler* obj0, [In] wxEvent* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxWindowBase\u002ESetSize(
    [In] wxWindowBase* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxPoint* wxWindowBase\u002EGetPosition(
    [In] wxWindowBase* obj0,
    [In] wxPoint* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxSize* wxWindowBase\u002EGetSize(
    [In] wxWindowBase* obj0,
    [In] wxSize* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool wxWindowBase\u002EHide([In] wxWindowBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxWindowBase\u002ESetWindowStyle([In] wxWindowBase* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxWindowBase\u002EGetWindowStyle([In] wxWindowBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxWindow* wxWindowBase\u002EGetParent([In] wxWindowBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxFrame* wxFrame\u002E\u007Bctor\u007D([In] wxFrame* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxDialog* wxDialog\u002E\u007Bctor\u007D([In] wxDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxTextDataObject* wxTextDataObject\u002E\u007Bctor\u007D(
    [In] wxTextDataObject* obj0,
    [In] wxString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxTextDataObject\u002E\u007Bdtor\u007D([In] wxTextDataObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int appTrunc([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int appFloor([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int appCeil([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern float appSqrt([In] float obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern double appSeconds();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FCompatibilityLevelInfo* FCompatibilityLevelInfo\u002E\u007Bctor\u007D(
    [In] FCompatibilityLevelInfo* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf([In] FOutputDevice* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint \u003FA0x3a4a4fc4\u002EappMsgf([In] EAppMsgType obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int appStrlen([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int appStricmp([In] char* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint Min\u003Cunsigned\u0020long\u003E([In] uint obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u007Bctor\u007D(
    [In] FString* obj0,
    [In] int obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u007Bctor\u007D(
    [In] FString* obj0,
    [In] sbyte* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u003D([In] FString* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u003D([In] FString* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FString\u002EEmpty([In] FString* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E* FString\u002EGetCharArray(
    [In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u002B\u003D(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u002B(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u002B(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] FString* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002E\u002A(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] FString* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FString\u002E\u003D\u003D([In] FString* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FString\u002E\u0021\u003D([In] FString* obj0, [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002ELeft(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002ERight(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EMid(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] int obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FString\u002EInStr(
    [In] FString* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FString\u002EInStr(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EToLower([In] FString* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FString\u002EEndsWith([In] FString* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FStringNoInit* FStringNoInit\u002E\u003D(
    [In] FStringNoInit* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FFilename* FFilename\u002E\u007Bctor\u007D(
    [In] FFilename* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FFilename* FFilename\u002E\u007Bctor\u007D(
    [In] FFilename* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FName\u002E\u003D\u003D([In] FName* obj0, [In] FName* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FName\u002E\u0021\u003D([In] FName* obj0, [In] FName* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* FName\u002E\u007Bctor\u007D([In] FName* obj0, [In] EName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FGuid\u002EString([In] FGuid* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* UObject\u002EGetPureName([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UObject\u002EGetClass([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UObject\u002EHasAllFlags([In] UObject* obj0, [In] ulong obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* UObject\u002EGetName([In] UObject* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* UObject\u002EGetFName([In] UObject* obj0, [In] FName* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* UObject\u002EGetOuter([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FObjectIterator\u002E\u002B\u002B([In] FObjectIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FObjectIterator\u002E\u002E_N([In] FObjectIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor* FLinearColor\u002E\u007Bctor\u007D(
    [In] FLinearColor* obj0,
    [In] float obj1,
    [In] float obj2,
    [In] float obj3,
    [In] float obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint* FColor\u002EDWColor([In] FColor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColor* FColor\u002E\u007Bctor\u007D([In] FColor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColor* FColor\u002E\u007Bctor\u007D(
    [In] FColor* obj0,
    [In] FLinearColor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FVector2D* FVector2D\u002E\u007Bctor\u007D(
    [In] FVector2D* obj0,
    [In] float obj1,
    [In] float obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FObjectThumbnail\u002EGetImageWidth([In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FObjectThumbnail\u002EGetImageHeight([In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FObjectThumbnail\u002ESetImageSize(
    [In] FObjectThumbnail* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FObjectThumbnail\u002EIsCreatedAfterCustomThumbsEnabled(
    [In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FObjectThumbnail\u002ESetCreatedAfterCustomThumbsEnabled(
    [In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FObjectThumbnail\u002EIsDirty([In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FObjectThumbnail\u002EMarkAsDirty([In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* FObjectThumbnail\u002EAccessImageData(
    [In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FObjectThumbnail\u002EIsEmpty([In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UPackage\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UPackage\u002EIsDirty([In] UPackage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGuid* UPackage\u002EGetGuid([In] UPackage* obj0, [In] FGuid* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UStruct\u002EIsChildOf([In] UStruct* obj0, [In] UStruct* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UClass\u002EHasAnyClassFlags([In] UClass* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FPropertyChangedEvent* FPropertyChangedEvent\u002E\u007Bctor\u007D(
    [In] FPropertyChangedEvent* obj0,
    [In] UProperty* obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UObject\u002EIsA([In] UObject* obj0, [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UFactory\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSerializableObject* FSerializableObject\u002E\u007Bctor\u007D(
    [In] FSerializableObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FSerializableObject\u002E\u007Bdtor\u007D(
    [In] FSerializableObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FFeedbackContext\u002EStatusUpdatef(
    [In] FFeedbackContext* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FTickableObject* FTickableObject\u002E\u007Bctor\u007D(
    [In] FTickableObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FTickableObject\u002E\u007Bdtor\u007D([In] FTickableObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int USelection\u002ENum([In] USelection* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* USelection\u002E\u0028\u0029(
    [In] USelection* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void USelection\u002EBeginBatchSelectOperation([In] USelection* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void USelection\u002EEndBatchSelectOperation([In] USelection* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int USelection\u002EGetSelectedObjects(
    [In] USelection* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FSelectionIterator\u002E\u002B\u002B([In] FSelectionIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* FSelectionIterator\u002E\u002A(
    [In] FSelectionIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSelectionIterator\u002E\u002EI([In] FSelectionIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FReadSurfaceDataFlags* FReadSurfaceDataFlags\u002E\u007Bctor\u007D(
    [In] FReadSurfaceDataFlags* obj0,
    [In] ERangeCompressionMode obj1,
    [In] ECubeFace obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* AActor\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UTexture\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UTexture2D\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFilename\u002E\u007Bdtor\u007D([In] FFilename* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UPhysicalMaterial\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UMaterialInterface\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UMaterial\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UStaticMesh\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AActor* FActorIteratorBase\u002E\u002A(
    [In] FActorIteratorBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FActorIteratorBase\u002E\u002EI([In] FActorIteratorBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FActorIterator* FActorIterator\u002E\u007Bctor\u007D(
    [In] FActorIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FDeferredInitializationWindow* FDeferredInitializationWindow\u002E\u007Bctor\u007D(
    [In] FDeferredInitializationWindow* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FDeferredInitializationWindow\u002E\u007Bdtor\u007D(
    [In] FDeferredInitializationWindow* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxDockEvent* WxDockEvent\u002E\u007Bctor\u007D(
    [In] WxDockEvent* obj0,
    [In] int obj1,
    [In] EDockingChangeType obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxDockEvent\u002E\u007Bdtor\u007D([In] WxDockEvent* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int WxBrowser\u002EGetDockID([In] WxBrowser* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint WxBrowser\u002EIsDocked([In] WxBrowser* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint WxBrowser\u002EIsFloating([In] WxBrowser* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UUIRoot\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEditorLevelViewportClient\u002ESetRealtime(
    [In] FEditorLevelViewportClient* obj0,
    [In] uint obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEditorLevelViewportClient\u002ESetAllowMatineePreview(
    [In] FEditorLevelViewportClient* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectSupportedCommandType* FObjectSupportedCommandType\u002E\u007Bctor\u007D(
    [In] FObjectSupportedCommandType* obj0,
    [In] int obj1,
    [In] FString* obj2,
    [In] uint obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UGenericBrowserType\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* UGenericBrowserType\u002EGetBrowserTypeDescription(
    [In] UGenericBrowserType* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UGenericBrowserType_Custom\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UGenericBrowserType_All\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UGenericBrowserType_Sounds\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UThumbnailLabelRenderer.ThumbnailOptions* UThumbnailLabelRenderer\u002EThumbnailOptions\u002E\u007Bctor\u007D(
    [In] UThumbnailLabelRenderer.ThumbnailOptions* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UIconThumbnailRenderer\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UArchetypeThumbnailRenderer\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMap\u003CFName\u002Cfloat\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TMap\u003CFName\u002Cfloat\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeLayerInfo* FLandscapeLayerInfo\u002E\u007Bctor\u007D(
    [In] FLandscapeLayerInfo* obj0,
    [In] FName obj1,
    [In] float obj2,
    [In] uint obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* ALandscape\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* ULandscapeLayerInfoObject\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* WxDlgNewGeneric\u002EGetFactoryClass(
    [In] WxDlgNewGeneric* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* WxDlgNewGeneric\u002EGetCreatedObject(
    [In] WxDlgNewGeneric* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxChoiceDialogBase.Choice* WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(
    [In] WxChoiceDialogBase.Choice* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxChoiceDialogBase.Choice* WxChoiceDialogBase\u002EChoice\u002E\u007Bctor\u007D(
    [In] WxChoiceDialogBase.Choice* obj0,
    [In] int obj1,
    [In] FString* obj2,
    [In] WxChoiceDialogBase.EDialogChoiceType obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxChoiceDialogBase\u002EChoice\u002E\u007Bdtor\u007D(
    [In] WxChoiceDialogBase.Choice* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FNewUDKProjectSettings* FNewUDKProjectSettings\u002EGet();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FUserProjSetting\u002EGetSettingDisplayName(
    [In] FUserProjSetting* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FFilename* FFilename\u002E\u007Bctor\u007D(
    [In] FFilename* obj0,
    [In] FFilename* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSelectedAssetInfo\u002EIsValid(
    [In] FSelectedAssetInfo* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FPropertyNode\u002EHasNodeFlags([In] FPropertyNode* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UProperty* FPropertyNode\u002EGetProperty(
    [In] FPropertyNode* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxPropertyControl* FPropertyNode\u002EGetNodeWindow(
    [In] FPropertyNode* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindow\u002EChangeActiveCallbackCount(
    [In] WxPropertyWindow* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindowFrame\u002EAllowClose(
    [In] WxPropertyWindowFrame* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxFileDialog\u002E\u007Bdtor\u007D([In] wxFileDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FGameAssetDatabase\u002EQueryTagsForAsset(
    [In] FGameAssetDatabase* obj0,
    [In] FName obj1,
    [In] ETagQueryOptions.Type obj2,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FGameAssetDatabase\u002EQueryAssetsWithTags(
    [In] FGameAssetDatabase* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj2,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FGameAssetDatabase\u002EQueryAssetsWithTagInAllSets(
    [In] FGameAssetDatabase* obj0,
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E__delDtor(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FMeshPaintSettings* FMeshPaintSettings\u002EGet();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EAddWindowMessage(
    [In] FEdModeMeshPaint* obj0,
    [In] uint obj1,
    [In] ulong obj2,
    [In] long obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FEdModeMeshPaint\u002ECanPasteVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FPerforceSourceControlProvider\u002ESaveSettings(
    [In] FPerforceSourceControlProvider* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void \u003FA0x3a4a4fc4\u002ECallCPUID([In] int* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLightmapResRatioAdjustSettings* FLightmapResRatioAdjustSettings\u002EGet();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLightingToolsSettings* FLightingToolsSettings\u002EGet();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FLandscapeToolSet\u002EGetToolSetName([In] FLandscapeToolSet* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGizmoHistory* FGizmoHistory\u002E\u007Bctor\u007D(
    [In] FGizmoHistory* obj0,
    [In] ALandscapeGizmoActor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGizmoImportLayer* FGizmoImportLayer\u002E\u007Bctor\u007D(
    [In] FGizmoImportLayer* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetWindowSizePos(
    [In] FLandscapeUISettings* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002EGetWindowSizePos(
    [In] FLandscapeUISettings* obj0,
    [In] int* obj1,
    [In] int* obj2,
    [In] int* obj3,
    [In] int* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetToolStrength(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetToolStrength(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetWeightTargetValue(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetWeightTargetValue(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbUseWeightTargetValue(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbUseWeightTargetValue(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeToolNoiseMode.Type FLandscapeUISettings\u002EGetFlattenMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetFlattenMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeToolNoiseMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbUseSlopeFlatten(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbUseSlopeFlatten(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbPickValuePerApply(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbPickValuePerApply(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetErodeThresh(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetErodeThresh(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetErodeIterationNum(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetErodeIterationNum(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetErodeSurfaceThickness(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetErodeSurfaceThickness(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeToolNoiseMode.Type FLandscapeUISettings\u002EGetErosionNoiseMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetErosionNoiseMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeToolNoiseMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetErosionNoiseScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetErosionNoiseScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetRainAmount(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetRainAmount(
    [In] FLandscapeUISettings* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetSedimentCapacity(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetSedimentCapacity(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetHErodeIterationNum(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetHErodeIterationNum(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeToolNoiseMode.Type FLandscapeUISettings\u002EGetRainDistMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetRainDistMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeToolNoiseMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetRainDistScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetRainDistScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetHErosionDetailScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetHErosionDetailScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbHErosionDetailSmooth(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbHErosionDetailSmooth(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeToolNoiseMode.Type FLandscapeUISettings\u002EGetNoiseMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetNoiseMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeToolNoiseMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetNoiseScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetNoiseScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetDetailScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetDetailScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbDetailSmooth(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbDetailSmooth(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbMaskEnabled(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbMaskEnabled(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeToolNoiseMode.Type FLandscapeUISettings\u002EGetPasteMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ELandscapeConvertMode.Type FLandscapeUISettings\u002EGetConvertMode(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetConvertMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeConvertMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetBrushRadius(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetBrushRadius(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetBrushComponentSize(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetBrushComponentSize(
    [In] FLandscapeUISettings* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetBrushFalloff(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetBrushFalloff(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbUseClayBrush(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbUseClayBrush(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetAlphaBrushScale(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetAlphaBrushScale(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetAlphaBrushRotation(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetAlphaBrushRotation(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetAlphaBrushPanU(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetAlphaBrushPanU(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetAlphaBrushPanV(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetAlphaBrushPanV(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UTexture2D* FLandscapeUISettings\u002EGetAlphaTexture(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetAlphaTextureSizeX(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FLandscapeUISettings\u002EGetAlphaTextureSizeY(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe byte* FLandscapeUISettings\u002EGetAlphaTextureData(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetbSmoothGizmoBrush(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbSmoothGizmoBrush(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E* FLandscapeUISettings\u002EGetGizmoHistories(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E* FLandscapeUISettings\u002EGetGizmoImportLayers(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFGizmoData\u002CFDefaultAllocator\u003E* FLandscapeUISettings\u002EGetGizmoData(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbApplyToAllTargets(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbApplyToAllTargets(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FLandscapeUISettings\u002EGetLODBiasThreshold(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetLODBiasThreshold(
    [In] FLandscapeUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002EAddWindowMessage(
    [In] FEdModeLandscape* obj0,
    [In] uint obj1,
    [In] ulong obj2,
    [In] long obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxDirDialog\u002E\u007Bdtor\u007D([In] wxDirDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetWindowSizePos(
    [In] FFoliageUISettings* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002EGetWindowSizePos(
    [In] FFoliageUISettings* obj0,
    [In] int* obj1,
    [In] int* obj2,
    [In] int* obj3,
    [In] int* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetPaintToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetPaintToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetReapplyToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetReapplyToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetSelectToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetSelectToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetLassoSelectToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetLassoSelectToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetPaintBucketToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetPaintBucketToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetReapplyPaintBucketToolSelected(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetReapplyPaintBucketToolSelected(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FFoliageUISettings\u002EGetRadius([In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetRadius(
    [In] FFoliageUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FFoliageUISettings\u002EGetPaintDensity(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetPaintDensity(
    [In] FFoliageUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe float FFoliageUISettings\u002EGetUnpaintDensity(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetUnpaintDensity(
    [In] FFoliageUISettings* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetFilterLandscape(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetFilterLandscape(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetFilterStaticMesh(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetFilterStaticMesh(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetFilterBSP([In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetFilterBSP(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool FFoliageUISettings\u002EGetFilterTerrain(
    [In] FFoliageUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageUISettings\u002ESetFilterTerrain(
    [In] FFoliageUISettings* obj0,
    [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UInstancedFoliageSettings\u002EStaticClass();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E\u002EGetData(
    [In] TArray\u003Cwchar_t\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFString\u002CFDefaultAllocator\u003E* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EGetTypedData(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TArray\u003CFString\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EInsertItem(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] FString* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ERemove(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002ERemoveSwap(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddZeroed(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EAddUniqueItem(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EReserve(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFString\u002CFDefaultAllocator\u003E\u002EReset(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EIsValidIndex(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject** TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject** TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EPop(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EContainsItem(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UObject** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemove(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAppend(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddUniqueItem(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UObject** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveSingleItem(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UObject** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002EReset(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* TMapBase\u003CFString\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E\u002ESet(
    [In] TMapBase\u003CFString\u002CFString\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1,
    [In] FString* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe byte* TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EGetTypedData(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe byte* TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe byte* TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EAdd(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002EAddZeroed(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage** TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage** TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EInsertItem(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UPackage** obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemove(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAppend(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UPackage** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddUniqueItem(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UPackage** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UPackage** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFName\u002CFDefaultAllocator\u003E* TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFName\u002CFDefaultAllocator\u003E* TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFName\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TArray\u003CFName\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFName\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0,
    [In] FName* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFColor\u002CFDefaultAllocator\u003E* TArray\u003CFColor\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFColor\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColor* TArray\u003CFColor\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFColor\u002CFDefaultAllocator\u003E\u002EAdd(
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFColor\u002CFDefaultAllocator\u003E* TArray\u003CFColor\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSetElementId* TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FSetElementId* obj1,
    [In] UObject* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(
    [In] TSet\u003CUObject\u0020\u002A\u002CDefaultKeyFuncs\u003CUObject\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] UObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectExport* TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFObjectExport\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass** TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UClass** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddUniqueItem(
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UClass** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject** TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject** TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass** TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TStaticBitArray\u003C128\u003E* \u007C(
    [In] TStaticBitArray\u003C128\u003E* obj0,
    [In] TStaticBitArray\u003C128\u003E* obj1,
    [In] TStaticBitArray\u003C128\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TActorIteratorBase\u003CFActorFilter\u002CFTickableLevelFilter\u003E\u002E\u002B\u002B(
    [In] TActorIteratorBase\u003CFActorFilter\u002CFTickableLevelFilter\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003Cint\u002CDefaultKeyFuncs\u003Cint\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003Cint\u002CDefaultKeyFuncs\u003Cint\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFFoliageInstanceCluster\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFFoliageInstanceCluster\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFFoliageInstance\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFFoliageInstance\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGenericBrowserTypeInfo* TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFGenericBrowserTypeInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSetElementId* TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FSetElementId* obj1,
    [In] FString* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(
    [In] TSet\u003CFString\u002CDefaultKeyFuncs\u003CFString\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* TMapBase\u003CFString\u002CTMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ESet(
    [In] TMapBase\u003CFString\u002CTMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1,
    [In] TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* TMapBase\u003CFString\u002CTMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CFString\u002CTMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003Cunsigned\u0020__int64\u002CFGizmoSelectData\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003Cunsigned\u0020__int64\u002CFGizmoSelectData\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeLayerStruct* TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002EFindRef(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003Cunsigned\u0020__int64\u002CULandscapeComponent\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003Cunsigned\u0020__int64\u002CULandscapeComponent\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003Cunsigned\u0020__int64\u002CULandscapeHeightfieldCollisionComponent\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003Cunsigned\u0020__int64\u002CULandscapeHeightfieldCollisionComponent\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003Cunsigned\u0020__int64\u002Cfloat\u002C0\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003Cunsigned\u0020__int64\u002Cfloat\u002C0\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EAddItem(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E.FLookupMapElementReference* TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EGetItem(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj0,
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E.FLookupMapElementReference* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFName\u002CFDefaultAllocator\u003E* TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EGetUniqueElements(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int* TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002EHasKey(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType** TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType** TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UGenericBrowserType** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddUniqueItem(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UGenericBrowserType** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxWindow** TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002EContainsItem(
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] wxWindow** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CwxWindow\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColor** TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor** TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFLinearColor\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FColorChannelStruct* TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E\u002E\u003D(
    [In] TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFColorChannelStruct\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E* TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003Cint\u002CFName\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002ESet(
    [In] TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] int obj1,
    [In] FName obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u002EFindRef(
    [In] TMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CFName\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FContentBrowser** TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FContentBrowser** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(
    [In] TArray\u003CFContentBrowser\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FContentBrowser** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSetMap\u003CFName\u002CFName\u003E* TSetMap\u003CFName\u002CFName\u003E\u002E\u007Bctor\u007D(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TSetMap\u003CFName\u002CFName\u003E\u002ENumKeys(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSetMap\u003CFName\u002CFName\u003E\u002EAdd(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] FName obj1,
    [In] FName obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSetMap\u003CFName\u002CFName\u003E\u002ERemove(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] FName obj1,
    [In] FName obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSetMap\u003CFName\u002CFName\u003E\u002EGetKeys(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TSetMap\u003CFName\u002CFName\u003E\u002EContainsKey(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] FName obj1,
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSetMap\u003CFName\u002CFName\u003E\u002EFindValuesForKey(
    [In] TSetMap\u003CFName\u002CFName\u003E* obj0,
    [In] FName obj1,
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EEmpty(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSetElementId* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FSetElementId* obj1,
    [In] FName obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ERemoveKey(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EContains(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CTSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] UFactory** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E* TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UFactory** TMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003Cint\u002CUFactory\u0020\u002A\u002C1\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TIterator* TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bctor\u007D(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TIterator* obj0,
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002B\u002B(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002E_N(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage** TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002A(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFString\u002CFDefaultAllocator\u003E** TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CTArray\u003CFString\u002CFDefaultAllocator\u003E\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage** TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A(
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectSupportedCommandType* TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectSupportedCommandType* TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002EEmpty(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj0,
    [In] FObjectSupportedCommandType* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* TMap\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TConstIterator* TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType** TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EValue(
    [In] TMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TConstIterator* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass** TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EValue(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType** TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TObjectIterator\u003CUClass\u003E* TObjectIterator\u003CUClass\u003E\u002E\u007Bctor\u007D(
    [In] TObjectIterator\u003CUClass\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* TObjectIterator\u003CUClass\u003E\u002E\u002A(
    [In] TObjectIterator\u003CUClass\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* TObjectIterator\u003CUClass\u003E\u002E\u002D\u003E(
    [In] TObjectIterator\u003CUClass\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TGuardValue\u003Cunsigned\u0020int\u003E* TGuardValue\u003Cunsigned\u0020int\u003E\u002E\u007Bctor\u007D(
    [In] TGuardValue\u003Cunsigned\u0020int\u003E* obj0,
    [In] uint* obj1,
    [In] uint* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TGuardValue\u003Cunsigned\u0020int\u003E\u002E\u007Bdtor\u007D(
    [In] TGuardValue\u003Cunsigned\u0020int\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0,
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E* obj1,
    [In] uint obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002E_N(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass** TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002EKey(
    [In] TMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectSupportedCommandType* TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E* TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* TMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u002EFind(
    [In] TMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CFName\u002CFObjectThumbnail\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] FSelectedAssetInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ENum(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSetElementId* TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FSetElementId* obj1,
    [In] UClass* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] TArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A(
    [In] TSet\u003CFName\u002CDefaultKeyFuncs\u003CFName\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator* TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002EKey(
    [In] TMapBase\u003CFName\u002Cint\u002C1\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E\u002EFLookupMapElementReference\u002E\u002EAEBVFName\u0040\u0040(
    [In] TLookupMap\u003CFName\u002CFDefaultSetAllocator\u003E.FLookupMapElementReference* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass** TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A(
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSourceControl.FSourceControlFileRevisionInfo* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E* TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSourceControl.FSourceControlFileHistoryInfo* TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UWorld** TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FStartPage** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E\u002ERemoveItem(
    [In] TArray\u003CFStartPage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FStartPage** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSetElementId* TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002EAdd(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] FSetElementId* obj1,
    [In] UGenericBrowserType* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETConstIterator\u002E\u007Bctor\u007D(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TConstIterator* obj0,
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002B\u002B(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002E_N(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType** TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C1\u003E\u002E\u002A(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C1\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSelectedAssetInfo* TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerIterator\u003CTArray\u003CFSelectedAssetInfo\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u007Bctor\u007D(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0,
    [In] TArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002B\u002B(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ULevelStreaming** TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002A(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E\u002E\u002E_N(
    [In] TIndexedContainerConstIterator\u003CTArray\u003CULevelStreaming\u0020\u002A\u002CFDefaultAllocator\u003E\u002Cint\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E\u002EIsValidIndex(
    [In] TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeBrush** TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLandscapeBrush\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGizmoHistory* TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E\u002ERemove(
    [In] TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGizmoImportLayer* TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E\u002ERemove(
    [In] TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLandscapeToolSet\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLandscapeToolSet\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeToolSet** TArray\u003CFLandscapeToolSet\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLandscapeToolSet\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLandscapeBrushSet\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLandscapeBrushSet\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeBrushSet* TArray\u003CFLandscapeBrushSet\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLandscapeBrushSet\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLandscapeTargetListInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLandscapeTargetListInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeTargetListInfo* TArray\u003CFLandscapeTargetListInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLandscapeTargetListInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFLandscapeListInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFLandscapeListInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeListInfo* TArray\u003CFLandscapeListInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFLandscapeListInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bctor\u007D(
    [In] TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe byte** TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E\u002EAddItem(
    [In] TArray\u003Cunsigned\u0020char\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] byte** obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bctor\u007D(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0,
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E* obj1,
    [In] uint obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ETIterator\u002E\u007Bdtor\u007D(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TIterator* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002E\u002B\u002B(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002EKey(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLandscapeLayerStruct** TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E\u002ETBaseIterator\u003C0\u003E\u002EValue(
    [In] TMapBase\u003CFName\u002CFLandscapeLayerStruct\u0020\u002A\u002C0\u002CFDefaultSetAllocator\u003E.TBaseIterator\u003C0\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UTemplateMapMetadata** TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CUTemplateMapMetadata\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AFPair\u002CTMapBase\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002C0\u002CFDefaultSetAllocator\u003E\u003A\u003AKeyFuncs\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TSet\u003CUGenericBrowserType\u0020\u002A\u002CDefaultKeyFuncs\u003CUGenericBrowserType\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFTemplateTargetListInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFTemplateTargetListInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FTemplateTargetListInfo* TArray\u003CFTemplateTargetListInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFTemplateTargetListInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFUserProjectSettingsListInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFUserProjectSettingsListInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FUserProjectSettingsListInfo* TArray\u003CFUserProjectSettingsListInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFUserProjectSettingsListInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E\u002E\u007Bdtor\u007D(
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileRevisionInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFTextureTargetListInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFTextureTargetListInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FTextureTargetListInfo* TArray\u003CFTextureTargetListInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFTextureTargetListInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFGizmoData\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFGizmoData\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FGizmoData* TArray\u003CFGizmoData\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFGizmoData\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TArray\u003CFFoliageMeshUIInfo\u002CFDefaultAllocator\u003E\u002ENum(
    [In] TArray\u003CFFoliageMeshUIInfo\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FFoliageMeshUIInfo* TArray\u003CFFoliageMeshUIInfo\u002CFDefaultAllocator\u003E\u002E\u0028\u0029(
    [In] TArray\u003CFFoliageMeshUIInfo\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void TRefCountPtr\u003CFStaticMesh\u003A\u003AFDrawListElementLink\u003E\u002E\u007Bdtor\u007D(
    [In] TRefCountPtr\u003CFStaticMesh\u003A\u003AFDrawListElementLink\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int Max\u003Cint\u003E([In] int obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern float Clamp\u003Cfloat\u003E([In] float obj0, [In] float obj1, [In] float obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cint\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cunsigned\u0020int\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cfloat\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] float obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cint\u002Cint\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] int obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* FindObject\u003Cclass\u0020UClass\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FormatLocalizedString\u003Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] char* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FormatLocalizedString\u003Cint\u002Cint\u003E(
    [In] char* obj0,
    [In] int obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern double Max\u003Cdouble\u003E([In] double obj0, [In] double obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* FindObject\u003Cclass\u0020UPackage\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* Cast\u003Cclass\u0020UPackage\u003E([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UFactory* UClass\u002EGetDefaultObject\u003Cclass\u0020UFactory\u003E(
    [In] UClass* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindowFrame\u002ESetObjectArray\u003Cclass\u0020UObject\u003E(
    [In] WxPropertyWindowFrame* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AActor* CastChecked\u003Cclass\u0020AActor\u002Cclass\u0020UObject\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType_Archetype* ConstCast\u003Cclass\u0020UGenericBrowserType_Archetype\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType_Archetype* Cast\u003Cclass\u0020UGenericBrowserType_Archetype\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UFactory* Cast\u003Cclass\u0020UFactory\u003E([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void Sort\u003Cclass\u0020UClass\u0020\u002A\u002Cclass\u0020CompareContentBrowserCLRUClassPointer\u003E(
    [In] UClass** obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType_Sounds* Cast\u003Cclass\u0020UGenericBrowserType_Sounds\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USoundCue* Cast\u003Cclass\u0020USoundCue\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USoundNodeWave* Cast\u003Cclass\u0020USoundNodeWave\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint \u003FA0x3a4a4fc4\u002EappMsgf\u003Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] EAppMsgType obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] char* obj5,
    [In] char* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void Sort\u003Cclass\u0020FString\u002Cclass\u0020CompareGameAssetDatabaseFStringConstRef\u003E(
    [In] FString* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* LoadObject\u003Cclass\u0020UClass\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] UPackageMap* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UGenericBrowserType* ConstructObject\u003Cclass\u0020UGenericBrowserType\u003E(
    [In] UClass* obj0,
    [In] UObject* obj1,
    [In] FName obj2,
    [In] ulong obj3,
    [In] UObject* obj4,
    [In] UObject* obj5,
    [In] FObjectInstancingGraph* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cunsigned\u0020long\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cfloat\u002Cwchar_t\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] float obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AStaticMeshActor* Cast\u003Cclass\u0020AStaticMeshActor\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ADynamicSMActor* Cast\u003Cclass\u0020ADynamicSMActor\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] char* obj5,
    [In] char* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4,
    [In] char* obj5,
    [In] char* obj6,
    [In] char* obj7);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cint\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] char* obj4,
    [In] char* obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cint\u002Cint\u002Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] int obj4,
    [In] char* obj5,
    [In] char* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELogf\u003Cwchar_t\u0020const\u0020\u002A\u002Cwchar_t\u0020const\u0020\u002A\u003E(
    [In] FOutputDevice* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FormatLocalizedString\u003Cwchar_t\u0020\u002A\u003E(
    [In] char* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FormatLocalizedString\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FormatLocalizedString\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(
    [In] char* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u002Cwchar_t\u0020\u002A\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* appStrcat\u003C16384\u003E(
    [In] \u0024ArrayType\u0024\u0024\u0024BY0EAAA\u0040_W* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPhysicalMaterial* FindObject\u003Cclass\u0020UPhysicalMaterial\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EPrintf\u003Cint\u002Cint\u002Cint\u002Cint\u003E(
    [In] FString* obj0,
    [In] char* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ULandscapeLayerInfoObject* LoadObject\u003Cclass\u0020ULandscapeLayerInfoObject\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] UPackageMap* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ALandscape* Cast\u003Cclass\u0020ALandscape\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern int Square\u003Cint\u003E([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UTexture2D* Cast\u003Cclass\u0020UTexture2D\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cstruct\u0020FGizmoHistory\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CFGizmoHistory\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPhysicalMaterial* Cast\u003Cclass\u0020UPhysicalMaterial\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cstruct\u0020FGizmoImportLayer\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CFGizmoImportLayer\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cclass\u0020TArray\u003Cunsigned\u0020char\u002Cclass\u0020FDefaultAllocator\u003E\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CTArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cclass\u0020FName\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* operator\u0020new\u003Cstruct\u0020FLandscapeLayerInfo\u002Cclass\u0020FDefaultAllocator\u003E(
    [In] ulong obj0,
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ATerrain* Cast\u003Cclass\u0020ATerrain\u003E([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UStaticMesh* LoadObject\u003Cclass\u0020UStaticMesh\u003E(
    [In] UObject* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] UPackageMap* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UStaticMesh* Cast\u003Cclass\u0020UStaticMesh\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UInstancedFoliageSettings* Cast\u003Cclass\u0020UInstancedFoliageSettings\u003E(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FEditorModeTools* GEditorModeTools();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UPackage\u002EIsFullyLoaded([In] UPackage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UPackage\u002EFullyLoad([In] UPackage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxWindow* OC3Ent\u002EFace\u002EFxStudioApp\u002EGetMainWindow();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FImageUtils\u002EImageResize(
    [In] int obj0,
    [In] int obj1,
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj2,
    [In] int obj3,
    [In] int obj4,
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj5,
    [In] uint obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint Parse([In] char* obj0, [In] char* obj1, [In] FString* obj2, [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FWindowUtil\u002ELoadPosSize(
    [In] FString* obj0,
    [In] wxTopLevelWindow* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] int obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FWindowUtil\u002ESavePosSize(
    [In] FString* obj0,
    [In] wxTopLevelWindow* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* appBaseDir();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern int __CxxQueryExceptionSize();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxDetectRethrow([In] void* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FEditorLevelViewportClient* FEditorLevelViewportClient\u002E\u007Bctor\u007D(
    [In] FEditorLevelViewportClient* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEditorLevelViewportClient\u002ESetMatineeRecordingWindow(
    [In] FEditorLevelViewportClient* obj0,
    [In] WxInterpEd* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxArrayString\u002E\u007Bdtor\u007D([In] wxArrayString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ulong wxArrayString\u002EAdd(
    [In] wxArrayString* obj0,
    [In] wxString* obj1,
    [In] ulong obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int EnumDisplayDevicesW(
    [In] char* obj0,
    [In] uint obj1,
    [In] _DISPLAY_DEVICEW* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UFactory\u002EValidForCurrentGame([In] UFactory* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void WxUnrealEdApp\u002EInstallHooksWPF();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ACameraActor* WxInterpEd\u002EGetCameraActor(
    [In] WxInterpEd* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int WxInterpEd\u002EGetNumCameraActors([In] WxInterpEd* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxInterpEd\u002EAddExtraViewport(
    [In] WxInterpEd* obj0,
    [In] FEditorLevelViewportClient* obj1,
    [In] AActor* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ObjectTools\u002ERenameObjectsWithRefs(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int ObjectTools\u002EForceDeleteObjects(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ObjectTools\u002EImportFiles(
    [In] wxArrayString* obj0,
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] FString* obj2,
    [In] FString* obj3,
    [In] FString* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void ObjectTools\u002ETagInUseObjects([In] EInUseSearchOption obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EShowReferencers(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FConsolidationResults* ObjectTools\u002EConsolidateObjects(
    [In] FConsolidationResults* obj0,
    [In] UObject* obj1,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj2,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002ECreateBrowsableObjectTypeMaps(
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TMap\u003CUGenericBrowserType\u0020\u002A\u002CTArray\u003CUClass\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int ObjectTools\u002EDeleteObjects(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EDuplicateWithRefs(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EShowReferenceGraph(
    [In] UObject* obj0,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002ESelectObjectAndExternalReferencersInLevel(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EExportObjects(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1,
    [In] FString* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EShowReferencedObjs([In] UObject* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ObjectTools\u002EAssembleListOfImportFactories(
    [In] TArray\u003CUFactory\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] FString* obj1,
    [In] FString* obj2,
    [In] TMultiMap\u003Cint\u002CUFactory\u0020\u002A\u002CFDefaultSetAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AWorldInfo* UWorld\u002EGetWorldInfo(
    [In] UWorld* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UWorld\u002EEditorDestroyActor(
    [In] UWorld* obj0,
    [In] AActor* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UWorld\u002EDestroyActor(
    [In] UWorld* obj0,
    [In] AActor* obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AActor* UWorld\u002ESpawnActor(
    [In] UWorld* obj0,
    [In] UClass* obj1,
    [In] FName obj2,
    [In] FVector* obj3,
    [In] FRotator* obj4,
    [In] AActor* obj5,
    [In] uint obj6,
    [In] uint obj7,
    [In] AActor* obj8,
    [In] APawn* obj9,
    [In] uint obj10,
    [In] ULevel* obj11);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UThumbnailManager* UUnrealEdEngine\u002EGetThumbnailManager(
    [In] UUnrealEdEngine* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UBrowserManager* UUnrealEdEngine\u002EGetBrowserManager(
    [In] UUnrealEdEngine* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FProjWizTemplate\u002EGetName(
    [In] FProjWizTemplate* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FProjWizTemplate\u002EGetDescription(
    [In] FProjWizTemplate* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe long FProjWizTemplate\u002EGetInstallSize([In] FProjWizTemplate* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FSourceControl\u002EInit();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FSourceControl\u002EConvertPackageNamesToSourceControlPaths(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSourceControl\u002ECheckOut(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSourceControl\u002ECheckIn(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj2,
    [In] FString* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSourceControl\u002ERevert(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSourceControl\u002ERevertUnchanged(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FSourceControl\u002EGetFilesModifiedFromServer(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FSourceControl\u002EGetFileHistory(
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CFSourceControl\u003A\u003AFSourceControlFileHistoryInfo\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ESourceControlState FSourceControl\u002ETranslateResultsToState(
    [In] TMap\u003CFString\u002CFString\u002CFDefaultSetAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FSourceControl\u002EIssueUpdateState(
    [In] FSourceControlEventListener* obj0,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint FSourceControl\u002EIsEnabled();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* FSourceControl\u002EFSourceControlFileHistoryInfo\u002EGetFileHistoryKeyString(
    [In] FSourceControl.FSourceControlFileHistoryInfo.EFileHistoryKeys obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool wxDialog\u002ECreate(
    [In] wxDialog* obj0,
    [In] wxWindow* obj1,
    [In] int obj2,
    [In] wxString* obj3,
    [In] wxPoint* obj4,
    [In] wxSize* obj5,
    [In] int obj6,
    [In] wxString* obj7);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxDialog\u002E\u007Bdtor\u007D([In] wxDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int wxDialog\u002EShowModal([In] wxDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FViewport\u002EDraw([In] FViewport* obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxChoiceDialogBase.Choice* WxChoiceDialogBase\u002EGetChoice(
    [In] WxChoiceDialogBase* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UBrowserManager\u002EShowWindow(
    [In] UBrowserManager* obj0,
    [In] int obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UBrowserManager\u002EIsCanonicalBrowser(
    [In] UBrowserManager* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UBrowserManager\u002EShowDockingContainer([In] UBrowserManager* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxChoiceDialog* WxChoiceDialog\u002E\u007Bctor\u007D(
    [In] WxChoiceDialog* obj0,
    [In] FString* obj1,
    [In] FString* obj2,
    [In] WxChoiceDialogBase.Choice* obj3,
    [In] WxChoiceDialogBase.Choice* obj4,
    [In] WxChoiceDialogBase.Choice* obj5,
    [In] WxChoiceDialogBase.Choice* obj6,
    [In] WxChoiceDialogBase.Choice* obj7);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxChoiceDialog\u002E\u007Bdtor\u007D([In] WxChoiceDialog* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FD3D9HardwareSurveyData* GetD3D9HardwareSurveyData(
    [In] FD3D9HardwareSurveyData* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GetDeviceCaps([In] HDC__* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appRootDir([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint appGetSplashPath([In] char* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FLightingToolsSettings\u002EInit();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint FLightingToolsSettings\u002EApplyToggle();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FLightingToolsSettings\u002EReset();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindowFrame\u002E\u007Bdtor\u007D(
    [In] WxPropertyWindowFrame* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ImportVertexTextureHelper\u002EApply(
    [In] ImportVertexTextureHelper* obj0,
    [In] FString* obj1,
    [In] int obj2,
    [In] int obj3,
    [In] byte obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxSoundCueEditor\u002EBatchProcessSoundClass(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxSoundCueEditor\u002EBatchProcessClusterSounds(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxSoundCueEditor\u002EBatchProcessInsertRadioChirp(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxSoundCueEditor\u002EBatchProcessInsertRadioChirp(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxSoundCueEditor\u002EBatchProcessInsertMatureNode(
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFString\u002CFDefaultAllocator\u003E* appGetKnownLanguageExtensions();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ParseParam([In] char* obj0, [In] char* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint FLightmapResRatioAdjustSettings\u002EApplyRatioAdjustment();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint appGetMacAddress([In] byte* obj0, [In] uint* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void __CxxUnregisterExceptionObject([In] void* obj0, [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UGenericBrowserType_Sounds\u002EPlay(
    [In] UGenericBrowserType_Sounds* obj0,
    [In] USoundNode* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UGenericBrowserType_Sounds\u002EPlay(
    [In] UGenericBrowserType_Sounds* obj0,
    [In] USoundCue* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool UGenericBrowserType_Sounds\u002EIsPlaying(
    [In] UGenericBrowserType_Sounds* obj0,
    [In] USoundNode* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool UGenericBrowserType_Sounds\u002EIsPlaying(
    [In] UGenericBrowserType_Sounds* obj0,
    [In] USoundCue* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UGenericBrowserType_Sounds\u002EStop(
    [In] UGenericBrowserType_Sounds* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appEngineDir([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ALandscape\u002EImportFromOldTerrain(
    [In] ALandscape* obj0,
    [In] ATerrain* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscape\u002EImport(
    [In] ALandscape* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4,
    [In] int obj5,
    [In] ushort* obj6,
    [In] char* obj7,
    [In] TArray\u003CFLandscapeLayerInfo\u002CFDefaultAllocator\u003E* obj8,
    [In] byte** obj9);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ULandscapeLayerInfoObject* ALandscapeProxy\u002EGetLayerInfo(
    [In] ALandscapeProxy* obj0,
    [In] char* obj1,
    [In] UPackage* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeProxy\u002EChangedPhysMaterial([In] ALandscapeProxy* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxFrame\u002E\u007Bdtor\u007D([In] wxFrame* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindow\u002ERebuildSubTree(
    [In] WxPropertyWindow* obj0,
    [In] FPropertyNode* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindow\u002ERefreshVisibleWindows(
    [In] WxPropertyWindow* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindow\u002ENotifyPreChange(
    [In] WxPropertyWindow* obj0,
    [In] WxPropertyControl* obj1,
    [In] UProperty* obj2,
    [In] UObject* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxPropertyWindow\u002ENotifyPostChange(
    [In] WxPropertyWindow* obj0,
    [In] WxPropertyControl* obj1,
    [In] FPropertyChangedEvent* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe HDC__* GetDC([In] HWND__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* appComputerName();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int TranslateMessage([In] tagMSG* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxExceptionFilter(
    [In] void* obj0,
    [In] void* obj1,
    [In] int obj2,
    [In] void* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FEditorBuildUtils\u002EEditorAutomatedBuildAndSubmit(
    [In] FEditorBuildUtils.FEditorAutomatedBuildSettings* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FEditorBuildUtils.FEditorAutomatedBuildSettings* FEditorBuildUtils\u002EFEditorAutomatedBuildSettings\u002E\u007Bctor\u007D(
    [In] FEditorBuildUtils.FEditorAutomatedBuildSettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxDirDialog* wxDirDialog\u002E\u007Bctor\u007D(
    [In] wxDirDialog* obj0,
    [In] wxWindow* obj1,
    [In] wxString* obj2,
    [In] wxString* obj3,
    [In] int obj4,
    [In] wxPoint* obj5,
    [In] wxSize* obj6,
    [In] wxString* obj7);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002ECopyDataToGizmo([In] FEdModeLandscape* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002ESetCurrentTool(
    [In] FEdModeLandscape* obj0,
    [In] int obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002ESetCurrentTool(
    [In] FEdModeLandscape* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002ESetMaskEnable(
    [In] FEdModeLandscape* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFLandscapeTargetListInfo\u002CFDefaultAllocator\u003E* FEdModeLandscape\u002EGetTargetList(
    [In] FEdModeLandscape* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFLandscapeListInfo\u002CFDefaultAllocator\u003E* FEdModeLandscape\u002EGetLandscapeList(
    [In] FEdModeLandscape* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002EAddLayerInfo(
    [In] FEdModeLandscape* obj0,
    [In] ULandscapeLayerInfoObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FEdModeLandscape\u002EUpdateLandscapeList([In] FEdModeLandscape* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeLandscape\u002EUpdateTargetList([In] FEdModeLandscape* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FPropertyNode\u002ESetExpanded(
    [In] FPropertyNode* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FFilename\u002EGetExtension(
    [In] FFilename* obj0,
    [In] FString* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FFilename\u002EGetBaseFilename(
    [In] FFilename* obj0,
    [In] FString* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FFilename\u002EGetPath(
    [In] FFilename* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void USelection\u002ESelect([In] USelection* obj0, [In] UObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void USelection\u002EDeselect([In] USelection* obj0, [In] UObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint GetModuleFileNameW([In] HINSTANCE__* obj0, [In] char* obj1, [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FEditorFileUtils\u002ENewMapInteractive();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void FEditorFileUtils\u002ELoadMap();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FEditorFileUtils.EPromptReturnCode FEditorFileUtils\u002EPromptForCheckoutAndSave(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FEditorFileUtils\u002EPromptToCheckoutPackages(
    [In] uint obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxFileDialog* WxFileDialog\u002E\u007Bctor\u007D(
    [In] WxFileDialog* obj0,
    [In] wxWindow* obj1,
    [In] wxString* obj2,
    [In] wxString* obj3,
    [In] wxString* obj4,
    [In] wxString* obj5,
    [In] int obj6,
    [In] wxPoint* obj7);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe WxDlgNewGeneric* WxDlgNewGeneric\u002E\u007Bctor\u007D(
    [In] WxDlgNewGeneric* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int WxDlgNewGeneric\u002EShowModal(
    [In] WxDlgNewGeneric* obj0,
    [In] FString* obj1,
    [In] FString* obj2,
    [In] UClass* obj3,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* ThumbnailTools\u002EGenerateThumbnailForObject(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ThumbnailTools\u002ECacheEmptyThumbnail(
    [In] FString* obj0,
    [In] UPackage* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ThumbnailTools\u002EQueryPackageFileNameForObject(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* ThumbnailTools\u002EFindCachedThumbnail(
    [In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ThumbnailTools\u002ELoadThumbnailsForObjects(
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj0,
    [In] TMap\u003CFName\u002CFObjectThumbnail\u002CFDefaultSetAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ThumbnailTools\u002ERenderThumbnail(
    [In] UObject* obj0,
    [In] uint obj1,
    [In] uint obj2,
    [In] ThumbnailTools.EThumbnailTextureFlushMode.Type obj3,
    [In] FObjectThumbnail* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* ThumbnailTools\u002ECacheThumbnail(
    [In] FString* obj0,
    [In] FObjectThumbnail* obj1,
    [In] UPackage* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* ThumbnailTools\u002EGetThumbnailForObject(
    [In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FObjectThumbnail* FObjectThumbnail\u002E\u007Bctor\u007D(
    [In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* FObjectThumbnail\u002EGetUncompressedImageData(
    [In] FObjectThumbnail* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEditorModeTools\u002EDeactivateMode(
    [In] FEditorModeTools* obj0,
    [In] EEditorMode obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* LocalizeUnrealEd(
    [In] FString* obj0,
    [In] sbyte* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* LocalizeUnrealEd(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* ULinker\u002EGetExportPathName(
    [In] ULinker* obj0,
    [In] FString* obj1,
    [In] int obj2,
    [In] char* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void WxEditorFrame\u002ESyncToContentBrowser([In] WxEditorFrame* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FOutputDevice\u002ELog(
    [In] FOutputDevice* obj0,
    [In] EName obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLocalizationExportFilter\u002ESetTagFilterType(
    [In] FLocalizationExportFilter* obj0,
    [In] FLocalizationExportFilter.ETagFilterType obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFString\u002CFDefaultAllocator\u003E* FLocalizationExportFilter\u002EGetFilterTags(
    [In] FLocalizationExportFilter* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GetVersionExW([In] _OSVERSIONINFOW* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int BringWindowToTop([In] HWND__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* ULinkerLoad\u002EGetExportClassPackage(
    [In] ULinkerLoad* obj0,
    [In] FName* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FName* ULinkerLoad\u002EGetExportClassName(
    [In] ULinkerLoad* obj0,
    [In] FName* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002EFlush(
    [In] FConfigCacheIni* obj0,
    [In] uint obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FConfigCacheIni\u002EGetString(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] FString* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002ESetString(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002EEmptySection(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FConfigCacheIni\u002EGetStr(
    [In] FConfigCacheIni* obj0,
    [In] FString* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FConfigCacheIni\u002EGetInt(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] int* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FConfigCacheIni\u002EGetDouble(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] double* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FConfigCacheIni\u002EGetBool(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FConfigCacheIni\u002EGetArray(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FConfigCacheIni\u002EGetSingleLineArray(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002ESetInt(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] int obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002ESetDouble(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] double obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002ESetBool(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] uint obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FConfigCacheIni\u002ESetSingleLineArray(
    [In] FConfigCacheIni* obj0,
    [In] char* obj1,
    [In] char* obj2,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj3,
    [In] char* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FName\u002EToString([In] FName* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FName\u002EToString([In] FName* obj0, [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int PeekMessageW(
    [In] tagMSG* obj0,
    [In] HWND__* obj1,
    [In] uint obj2,
    [In] uint obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void appLaunchURL([In] char* obj0, [In] char* obj1, [In] FString* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int ReleaseDC([In] HWND__* obj0, [In] HDC__* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe AInstancedFoliageActor* AInstancedFoliageActor\u002EGetInstancedFoliageActor(
    [In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void PackageTools\u002ECheckOutRootPackages(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint PackageTools\u002EIsPackageExternal([In] UPackage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint PackageTools\u002EIsPackagePathExternal([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* PackageTools\u002EDoBulkExport(
    [In] FString* obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] FString* obj2,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj3,
    [In] TSet\u003CUClass\u0020\u002A\u002CDefaultKeyFuncs\u003CUClass\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj4,
    [In] uint obj5,
    [In] FLocalizationExportFilter* obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* PackageTools\u002EExportLocalization(
    [In] FString* obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] FString* obj2,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint PackageTools\u002ESavePackages(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1,
    [In] FString* obj2,
    [In] TArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint PackageTools\u002EUnloadPackages(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void PackageTools\u002EGetObjectsInPackages(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint PackageTools\u002ECheckForReferencesToExternalPackages(
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] ULevel* obj2,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void PackageTools\u002EGetFilteredPackageList(
    [In] TMap\u003CUClass\u0020\u002A\u002CTArray\u003CUGenericBrowserType\u0020\u002A\u002CFDefaultAllocator\u003E\u002CFDefaultSetAllocator\u003E* obj0,
    [In] TSet\u003CUPackage\u0020const\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020const\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj1,
    [In] TSet\u003CUPackage\u0020\u002A\u002CDefaultKeyFuncs\u003CUPackage\u0020\u002A\u002C0\u003E\u002CFDefaultSetAllocator\u003E* obj2,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* PackageTools\u002EDoBulkImport(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* PackageTools\u002ELoadPackage([In] FFilename* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appCollapseRelativeDirectories(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbUseSelectedRegion(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbUseSelectedRegion(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002EGetbUseNegativeMask(
    [In] FLandscapeUISettings* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetbUseNegativeMask(
    [In] FLandscapeUISettings* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLandscapeUISettings\u002ESetPasteMode(
    [In] FLandscapeUISettings* obj0,
    [In] ELandscapeToolNoiseMode.Type obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLandscapeUISettings\u002ESetAlphaTexture(
    [In] FLandscapeUISettings* obj0,
    [In] char* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FRenderTarget\u002EReadPixels(
    [In] FRenderTarget* obj0,
    [In] TArray\u003CFColor\u002CFDefaultAllocator\u003E* obj1,
    [In] FReadSurfaceDataFlags obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FLevelUtils\u002EGetWorlds(
    [In] TArray\u003CUWorld\u0020\u002A\u002CFDefaultAllocator\u003E* obj0,
    [In] uint obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLevelUtils\u002EIsLevelVisible([In] ULevel* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FLevelUtils\u002EIsLevelVisible([In] ULevelStreaming* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GetCursorPos([In] tagPOINT* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FString\u002EReplace(
    [In] FString* obj0,
    [In] FString* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] uint obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FString\u002EReplaceInline(
    [In] FString* obj0,
    [In] char* obj1,
    [In] char* obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __CxxRegisterExceptionObject([In] void* obj0, [In] void* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint appLoadFileToArray(
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj0,
    [In] char* obj1,
    [In] FFileManager* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe wxDropSource* wxDropSource\u002E\u007Bctor\u007D(
    [In] wxDropSource* obj0,
    [In] wxDataObject* obj1,
    [In] wxWindow* obj2,
    [In] wxCursor* obj3,
    [In] wxCursor* obj4,
    [In] wxCursor* obj5);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void wxDropSource\u002E\u007Bdtor\u007D([In] wxDropSource* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  [return: MarshalAs(UnmanagedType.U1)]
  internal static extern unsafe bool wxWindowBase\u002EClose([In] wxWindowBase* obj0, [MarshalAs(UnmanagedType.U1)] bool _param1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ESaveSettingsForActor(
    [In] FEdModeMeshPaint* obj0,
    [In] AActor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ERemoveInstanceVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ECopyInstanceVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EPasteInstanceVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FEdModeMeshPaint\u002ERequiresInstanceVertexColorsFixup(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EFixupInstanceVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EFillInstanceVertexColors(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EPushInstanceVertexColorsToMesh(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ECreateInstanceMaterialAndTexture(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ERemoveInstanceMaterialAndTexture(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint FEdModeMeshPaint\u002EGetSelectedMeshInfo(
    [In] FEdModeMeshPaint* obj0,
    [In] int* obj1,
    [In] int* obj2,
    [In] uint* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EUpdateTexturePaintTargetList(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FEdModeMeshPaint\u002EGetMaxNumUVSets([In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFTextureTargetListInfo\u002CFDefaultAllocator\u003E* FEdModeMeshPaint\u002EGetTexturePaintTargetList(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UTexture2D* FEdModeMeshPaint\u002EGetSelectedTexture(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EFindSelectedTextureInContentBrowser(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ECommitAllPaintedTextures(
    [In] FEdModeMeshPaint* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ERestoreRenderTargets(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FEdModeMeshPaint\u002EGetNumberOfPendingPaintChanges(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int FEdModeMeshPaint\u002EGetCurrentTextureTargetIndex(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002EDuplicateTextureMaterialCombo(
    [In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeMeshPaint\u002ECreateNewTexture([In] FEdModeMeshPaint* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ALandscapeGizmoActor* ALandscapeGizmoActiveActor\u002ESpawnGizmoActor(
    [In] ALandscapeGizmoActiveActor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002EClearGizmoData(
    [In] ALandscapeGizmoActiveActor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002EFitToSelection(
    [In] ALandscapeGizmoActiveActor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002EFitMinMaxHeight(
    [In] ALandscapeGizmoActiveActor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002ESetTargetLandscape(
    [In] ALandscapeGizmoActiveActor* obj0,
    [In] ULandscapeInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002EImport(
    [In] ALandscapeGizmoActiveActor* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] ushort* obj3,
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj4,
    [In] byte** obj5);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ALandscapeGizmoActiveActor\u002EExport(
    [In] ALandscapeGizmoActiveActor* obj0,
    [In] int obj1,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor* FLinearColor\u002E\u007Bctor\u007D(
    [In] FLinearColor* obj0,
    [In] FColor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor* FLinearColor\u002ELinearRGBToHSV(
    [In] FLinearColor* obj0,
    [In] FLinearColor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FLinearColor* FLinearColor\u002EHSVToLinearRGB(
    [In] FLinearColor* obj0,
    [In] FLinearColor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* appCmdLine();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int IsWindowVisible([In] HWND__* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UPropertyWindowManager\u002EClearAllThatContainObjects(
    [In] UPropertyWindowManager* obj0,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* FPackageFileCache\u002EPackageFromPath(
    [In] FString* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FPackageFileCache\u002ENormalizePathSeparators([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FScopedBusyCursor* FScopedBusyCursor\u002E\u007Bctor\u007D(
    [In] FScopedBusyCursor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FScopedBusyCursor\u002E\u007Bdtor\u007D([In] FScopedBusyCursor* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002ENotifyNewCurrentLevel([In] FEdModeFoliage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002ENotifyToolChanged([In] FEdModeFoliage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002EUpdateFoliageMeshList([In] FEdModeFoliage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFFoliageMeshUIInfo\u002CFDefaultAllocator\u003E* FEdModeFoliage\u002EGetFoliageMeshList(
    [In] FEdModeFoliage* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002EAddFoliageMesh(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002ERemoveFoliageMesh(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002EReplaceStaticMesh(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1,
    [In] UStaticMesh* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002ECopySettingsObject(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002EReplaceSettingsObject(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1,
    [In] UInstancedFoliageSettings* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FEdModeFoliage\u002ESaveSettingsObject(
    [In] FEdModeFoliage* obj0,
    [In] UStaticMesh* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFTemplateTargetListInfo\u002CFDefaultAllocator\u003E* FNewUDKProjectWizard\u002EGetTemplateTargetList(
    [In] FNewUDKProjectWizard* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe TArray\u003CFUserProjectSettingsListInfo\u002CFDefaultAllocator\u003E* FNewUDKProjectWizard\u002EGetUserSettingsList(
    [In] FNewUDKProjectWizard* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* appUserName();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint UGenericBrowserType\u002ESupports(
    [In] UGenericBrowserType* obj0,
    [In] UObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UGenericBrowserType\u002EQueryStandardSupportedCommands(
    [In] USelection* obj0,
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UObject\u002EPostEditChange([In] UObject* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* UObject\u002EStaticFindObject(
    [In] UClass* obj0,
    [In] UObject* obj1,
    [In] char* obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* UObject\u002EStaticLoadObject(
    [In] UClass* obj0,
    [In] UObject* obj1,
    [In] char* obj2,
    [In] char* obj3,
    [In] uint obj4,
    [In] UPackageMap* obj5,
    [In] uint obj6);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* UObject\u002EStaticConstructObject(
    [In] UClass* obj0,
    [In] UObject* obj1,
    [In] FName obj2,
    [In] ulong obj3,
    [In] UObject* obj4,
    [In] FOutputDevice* obj5,
    [In] UObject* obj6,
    [In] FObjectInstancingGraph* obj7);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void UObject\u002ECollectGarbage([In] ulong obj0, [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void UObject\u002EBeginLoad();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UObject\u002EEndLoad([In] char* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* UObject\u002EFindPackage(
    [In] UObject* obj0,
    [In] char* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ULinkerLoad* UObject\u002EGetPackageLinker(
    [In] UPackage* obj0,
    [In] char* obj1,
    [In] uint obj2,
    [In] UPackageMap* obj3,
    [In] FGuid* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UPackage* UObject\u002EGetTransientPackage();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe char* UObject\u002EGetLanguage();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* UObject\u002EGetFullName(
    [In] UObject* obj0,
    [In] FString* obj1,
    [In] UObject* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* UObject\u002EGetPathName(
    [In] UObject* obj0,
    [In] FString* obj1,
    [In] UObject* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* UObject\u002EGetFullGroupName(
    [In] UObject* obj0,
    [In] FString* obj1,
    [In] uint obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UClass* UObject\u002EFindNearestCommonBaseClass(
    [In] UObject* obj0,
    [In] UClass* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appGameLogDir([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern uint appIs64bitOperatingSystem();

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageMeshInfo\u002EReallocateClusters(
    [In] FFoliageMeshInfo* obj0,
    [In] AInstancedFoliageActor* obj1,
    [In] UStaticMesh* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void FFoliageMeshInfo\u002EUpdateClusterSettings(
    [In] FFoliageMeshInfo* obj0,
    [In] AInstancedFoliageActor* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appConvertRelativePathToFull(
    [In] FString* obj0,
    [In] FString* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ULandscapeInfo\u002EGetLandscapeExtent(
    [In] ULandscapeInfo* obj0,
    [In] int* obj1,
    [In] int* obj2,
    [In] int* obj3,
    [In] int* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ULandscapeInfo\u002EExport(
    [In] ULandscapeInfo* obj0,
    [In] TArray\u003CFName\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CFString\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ULandscapeInfo\u002EReimportHeightmap(
    [In] ULandscapeInfo* obj0,
    [In] int obj1,
    [In] ushort* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint ULandscapeInfo\u002EReimportLayermap(
    [In] ULandscapeInfo* obj0,
    [In] FName obj1,
    [In] TArray\u003Cunsigned\u0020char\u002CFDefaultAllocator\u003E* obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe ALandscape* ULandscapeInfo\u002EChangeComponentSetting(
    [In] ULandscapeInfo* obj0,
    [In] int obj1,
    [In] int obj2,
    [In] int obj3,
    [In] int obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ULandscapeInfo\u002EDeleteLayer(
    [In] ULandscapeInfo* obj0,
    [In] FName obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ULandscapeInfo\u002EUpdateDebugColorMaterial(
    [In] ULandscapeInfo* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ULandscapeInfo\u002EClearSelectedRegion(
    [In] ULandscapeInfo* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void ULandscapeInfo\u002EUpdateLODBias(
    [In] ULandscapeInfo* obj0,
    [In] float obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe uint GetPixel([In] HDC__* obj0, [In] int obj1, [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe UObject* UClass\u002EGetDefaultObject(
    [In] UClass* obj0,
    [In] uint obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int GuardedMainWrapper(
    [In] char* obj0,
    [In] HINSTANCE__* obj1,
    [In] HINSTANCE__* obj2,
    [In] int obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FString* appGameDir([In] FString* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FCallbackEventParameters* FCallbackEventParameters\u002E\u007Bctor\u007D(
    [In] FCallbackEventParameters* obj0,
    [In] FCallbackEventDevice* obj1,
    [In] ECallbackEventType obj2,
    [In] uint obj3,
    [In] UObject* obj4);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FCallbackEventParameters* FCallbackEventParameters\u002E\u007Bctor\u007D(
    [In] FCallbackEventParameters* obj0,
    [In] FCallbackEventDevice* obj1,
    [In] ECallbackEventType obj2,
    [In] uint obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USelection* UEditorEngine\u002EGetSelectedActors(
    [In] UEditorEngine* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FSelectionIterator* UEditorEngine\u002EGetSelectedActorIterator(
    [In] UEditorEngine* obj0,
    [In] FSelectionIterator* obj1);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe USelection* UEditorEngine\u002EGetSelectedObjects(
    [In] UEditorEngine* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UEditorEngine\u002ECheckForTrashcanReferences(
    [In] UEditorEngine* obj0,
    [In] TArray\u003CUPackage\u0020\u002A\u002CFDefaultAllocator\u003E* obj1,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj2,
    [In] TArray\u003CUObject\u0020\u002A\u002CFDefaultAllocator\u003E* obj3);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void UEditorEngine\u002ECreateSoundClassMenuForContentBrowser(
    [In] UEditorEngine* obj0,
    [In] TArray\u003CFObjectSupportedCommandType\u002CFDefaultAllocator\u003E* obj1,
    [In] int obj2);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe FThumbnailRenderingInfo* UThumbnailManager\u002EGetRenderingInfo(
    [In] UThumbnailManager* obj0,
    [In] UObject* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe long DispatchMessageW([In] tagMSG* obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* _getFiberPtrId();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _amsg_exit([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [MethodImpl(MethodImplOptions.Unmanaged | MethodImplOptions.PreserveSig, MethodCodeType = MethodCodeType.Native)]
  internal static extern void __security_init_cookie();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void Sleep([In] uint obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void _cexit();

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe locale.facet* std\u002Elocale\u002Efacet\u002E_Decref(
    [In] locale.facet* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void _CxxThrowException([In] void* obj0, [In] _s__ThrowInfo* obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* memmove([In] void* obj0, [In] void* obj1, [In] ulong obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002E_Xlength_error([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void std\u002E_Lockit\u002E_Lockit_ctor([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void std\u002E_Lockit\u002E_Lockit_dtor([In] int obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void std\u002E_Xout_of_range([In] sbyte* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe exception* std\u002Eexception\u002E\u007Bctor\u007D(
    [In] exception* obj0,
    [In] sbyte** obj1);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe void* memcpy([In] void* obj0, [In] void* obj1, [In] ulong obj2);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern unsafe int __FrameUnwindFilter([In] _EXCEPTION_POINTERS* obj0);

  [SuppressUnmanagedCodeSecurity]
  [DllImport("", EntryPoint = "", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
  [MethodImpl(MethodImplOptions.Unmanaged, MethodCodeType = MethodCodeType.Native)]
  internal static extern void terminate();
}
